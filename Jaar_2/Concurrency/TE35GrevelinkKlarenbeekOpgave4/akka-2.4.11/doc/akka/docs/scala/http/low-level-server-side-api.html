


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Low-Level Server-Side API &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/toc.js"></script>
    <script type="text/javascript" src="../../_static/prettify.js"></script>
    <script type="text/javascript" src="../../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../../_static/effects.core.js"></script>
    <script type="text/javascript" src="../../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../../_static/ga.js"></script>
    <script type="text/javascript" src="../../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../../index.html" />
    <link rel="up" title="Akka HTTP" href="index.html" />
    <link rel="next" title="High-level Server-Side API" href="routing-dsl/index.html" />
    <link rel="prev" title="Implications of the streaming nature of Request/Response Entities" href="implications-of-streaming-http-entity.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Low-Level Server-Side API</div>
      <div class="pdf-link"><a href="../../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../../AkkaJava.pdf" title="Akka Java Documentation"><img src="../../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="routing-dsl/index.html">High-level Server-Side API</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../../java.html">Java Contents</a> <span class="divider">|</span> <a href="../../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="low-level-server-side-api">
<span id="http-low-level-server-side-api"></span><h1>Low-Level Server-Side API</h1>
<p>Apart from the <a class="reference internal" href="client-side/index.html#http-client-side"><em>HTTP Client</em></a> Akka HTTP also provides an embedded,
<a class="reference external" href="http://www.reactive-streams.org/">Reactive-Streams</a>-based, fully asynchronous HTTP/1.1 server implemented on top of <a class="reference internal" href="../stream/index.html#streams-scala"><em>Akka Stream</em></a>.</p>
<p>It sports the following features:</p>
<ul class="simple">
<li>Full support for <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP persistent connections</a></li>
<li>Full support for <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_pipelining">HTTP pipelining</a></li>
<li>Full support for asynchronous HTTP streaming including &quot;chunked&quot; transfer encoding accessible through an idiomatic API</li>
<li>Optional SSL/TLS encryption</li>
<li>WebSocket support</li>
</ul>
<p>The server-side components of Akka HTTP are split into two layers:</p>
<ol class="arabic simple">
<li>The basic low-level server implementation in the <tt class="docutils literal"><span class="pre">akka-http-core</span></tt> module</li>
<li>Higher-level functionality in the <tt class="docutils literal"><span class="pre">akka-http</span></tt> module</li>
</ol>
<p>The low-level server (1) is scoped with a clear focus on the essential functionality of an HTTP/1.1 server:</p>
<ul class="simple">
<li>Connection management</li>
<li>Parsing and rendering of messages and headers</li>
<li>Timeout management (for requests and connections)</li>
<li>Response ordering (for transparent pipelining support)</li>
</ul>
<p>All non-core features of typical HTTP servers (like request routing, file serving, compression, etc.) are left to
the higher layers, they are not implemented by the <tt class="docutils literal"><span class="pre">akka-http-core</span></tt>-level server itself.
Apart from general focus this design keeps the server core small and light-weight as well as easy to understand and
maintain.</p>
<p>Depending on your needs you can either use the low-level API directly or rely on the high-level
<a class="reference internal" href="routing-dsl/index.html#http-high-level-server-side-api"><em>Routing DSL</em></a> which can make the definition of more complex service logic much
easier.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is recommended to read the <a class="reference internal" href="implications-of-streaming-http-entity.html#implications-of-streaming-http-entities"><em>Implications of the streaming nature of Request/Response Entities</em></a> section,
as it explains the underlying full-stack streaming concepts, which may be unexpected when coming
from a background with non-&quot;streaming first&quot; HTTP Servers.</p>
</div>
<div class="section" id="streams-and-http">
<h2>Streams and HTTP</h2>
<p>The Akka HTTP server is implemented on top of <a class="reference internal" href="../stream/index.html#streams-scala"><em>Akka Stream</em></a> and makes heavy use of it - in its
implementation as well as on all levels of its API.</p>
<p>On the connection level Akka HTTP offers basically the same kind of interface as <a class="reference internal" href="../stream/stream-io.html#stream-io-scala"><em>Akka Stream IO</em></a>:
A socket binding is represented as a stream of incoming connections. The application pulls connections from this stream
source and, for each of them, provides a <tt class="docutils literal"><span class="pre">Flow[HttpRequest,</span> <span class="pre">HttpResponse,</span> <span class="pre">_]</span></tt> to &quot;translate&quot; requests into responses.</p>
<p>Apart from regarding a socket bound on the server-side as a <tt class="docutils literal"><span class="pre">Source[IncomingConnection]</span></tt> and each connection as a
<tt class="docutils literal"><span class="pre">Source[HttpRequest]</span></tt> with a <tt class="docutils literal"><span class="pre">Sink[HttpResponse]</span></tt> the stream abstraction is also present inside a single HTTP
message: The entities of HTTP requests and responses are generally modeled as a <tt class="docutils literal"><span class="pre">Source[ByteString]</span></tt>. See also
the <a class="reference internal" href="common/http-model.html#http-model-scala"><em>HTTP Model</em></a> for more information on how HTTP messages are represented in Akka HTTP.</p>
</div>
<div class="section" id="starting-and-stopping">
<h2>Starting and Stopping</h2>
<p>On the most basic level an Akka HTTP server is bound by invoking the <tt class="docutils literal"><span class="pre">bind</span></tt> method of the <a class="reference external" href="http://github.com/akka/akka/tree/v2.4.11/akka-http-core/src/main/scala/akka/http/scaladsl/Http.scala">akka.http.scaladsl.Http</a>
extension:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http</span>
<span class="k">import</span> <span class="nn">akka.stream.ActorMaterializer</span>
<span class="k">import</span> <span class="nn">akka.stream.scaladsl._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">executionContext</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span>

<span class="k">val</span> <span class="n">serverSource</span><span class="k">:</span> <span class="kt">Source</span><span class="o">[</span><span class="kt">Http.IncomingConnection</span>, <span class="kt">Future</span><span class="o">[</span><span class="kt">Http.ServerBinding</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Http</span><span class="o">().</span><span class="n">bind</span><span class="o">(</span><span class="n">interface</span> <span class="k">=</span> <span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="n">port</span> <span class="k">=</span> <span class="mi">8080</span><span class="o">)</span>
<span class="k">val</span> <span class="n">bindingFuture</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Http.ServerBinding</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">serverSource</span><span class="o">.</span><span class="n">to</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">connection</span> <span class="k">=&gt;</span> <span class="c1">// foreach materializes the source</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Accepted new connection from &quot;</span> <span class="o">+</span> <span class="n">connection</span><span class="o">.</span><span class="n">remoteAddress</span><span class="o">)</span>
    <span class="c1">// ... and then actually handle the connection</span>
  <span class="o">}).</span><span class="n">run</span><span class="o">()</span>
</pre></div>
</div>
<p>Arguments to the <tt class="docutils literal"><span class="pre">Http().bind</span></tt> method specify the interface and port to bind to and register interest in handling
incoming HTTP connections. Additionally, the method also allows for the definition of socket options as well as a larger
number of settings for configuring the server according to your needs.</p>
<p>The result of the <tt class="docutils literal"><span class="pre">bind</span></tt> method is a <tt class="docutils literal"><span class="pre">Source[Http.IncomingConnection]</span></tt> which must be drained by the application in
order to accept incoming connections.
The actual binding is not performed before this source is materialized as part of a processing pipeline. In
case the bind fails (e.g. because the port is already busy) the materialized stream will immediately be terminated with
a respective exception.
The binding is released (i.e. the underlying socket unbound) when the subscriber of the incoming
connection source has cancelled its subscription. Alternatively one can use the <tt class="docutils literal"><span class="pre">unbind()</span></tt> method of the
<tt class="docutils literal"><span class="pre">Http.ServerBinding</span></tt> instance that is created as part of the connection source's materialization process.
The <tt class="docutils literal"><span class="pre">Http.ServerBinding</span></tt> also provides a way to get a hold of the actual local address of the bound socket, which is
useful for example when binding to port zero (and thus letting the OS pick an available port).</p>
</div>
<div class="section" id="request-response-cycle">
<h2>Request-Response Cycle</h2>
<p>When a new connection has been accepted it will be published as an <tt class="docutils literal"><span class="pre">Http.IncomingConnection</span></tt> which consists
of the remote address and methods to provide a <tt class="docutils literal"><span class="pre">Flow[HttpRequest,</span> <span class="pre">HttpResponse,</span> <span class="pre">_]</span></tt> to handle requests coming in over
this connection.</p>
<p>Requests are handled by calling one of the <tt class="docutils literal"><span class="pre">handleWithXXX</span></tt> methods with a handler, which can either be</p>
<blockquote>
<div><ul class="simple">
<li>a <tt class="docutils literal"><span class="pre">Flow[HttpRequest,</span> <span class="pre">HttpResponse,</span> <span class="pre">_]</span></tt> for <tt class="docutils literal"><span class="pre">handleWith</span></tt>,</li>
<li>a function <tt class="docutils literal"><span class="pre">HttpRequest</span> <span class="pre">=&gt;</span> <span class="pre">HttpResponse</span></tt> for <tt class="docutils literal"><span class="pre">handleWithSyncHandler</span></tt>,</li>
<li>a function <tt class="docutils literal"><span class="pre">HttpRequest</span> <span class="pre">=&gt;</span> <span class="pre">Future[HttpResponse]</span></tt> for <tt class="docutils literal"><span class="pre">handleWithAsyncHandler</span></tt>.</li>
</ul>
</div></blockquote>
<p>Here is a complete example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.model.HttpMethods._</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.model._</span>
<span class="k">import</span> <span class="nn">akka.stream.ActorMaterializer</span>
<span class="k">import</span> <span class="nn">akka.stream.scaladsl.Sink</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">executionContext</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span>

<span class="k">val</span> <span class="n">serverSource</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">().</span><span class="n">bind</span><span class="o">(</span><span class="n">interface</span> <span class="k">=</span> <span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="n">port</span> <span class="k">=</span> <span class="mi">8080</span><span class="o">)</span>

<span class="k">val</span> <span class="n">requestHandler</span><span class="k">:</span> <span class="kt">HttpRequest</span> <span class="o">=&gt;</span> <span class="nc">HttpResponse</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">HttpRequest</span><span class="o">(</span><span class="nc">GET</span><span class="o">,</span> <span class="nc">Uri</span><span class="o">.</span><span class="nc">Path</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">),</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">HttpResponse</span><span class="o">(</span><span class="n">entity</span> <span class="k">=</span> <span class="nc">HttpEntity</span><span class="o">(</span>
      <span class="nc">ContentTypes</span><span class="o">.</span><span class="n">`text/html(UTF-8)`</span><span class="o">,</span>
      <span class="s">&quot;&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="o">))</span>

  <span class="k">case</span> <span class="nc">HttpRequest</span><span class="o">(</span><span class="nc">GET</span><span class="o">,</span> <span class="nc">Uri</span><span class="o">.</span><span class="nc">Path</span><span class="o">(</span><span class="s">&quot;/ping&quot;</span><span class="o">),</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">HttpResponse</span><span class="o">(</span><span class="n">entity</span> <span class="k">=</span> <span class="s">&quot;PONG!&quot;</span><span class="o">)</span>

  <span class="k">case</span> <span class="nc">HttpRequest</span><span class="o">(</span><span class="nc">GET</span><span class="o">,</span> <span class="nc">Uri</span><span class="o">.</span><span class="nc">Path</span><span class="o">(</span><span class="s">&quot;/crash&quot;</span><span class="o">),</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;BOOM!&quot;</span><span class="o">)</span>

  <span class="k">case</span> <span class="n">r</span><span class="k">:</span> <span class="kt">HttpRequest</span> <span class="o">=&gt;</span>
    <span class="n">r</span><span class="o">.</span><span class="n">discardEntityBytes</span><span class="o">()</span> <span class="c1">// important to drain incoming HTTP Entity stream</span>
    <span class="nc">HttpResponse</span><span class="o">(</span><span class="mi">404</span><span class="o">,</span> <span class="n">entity</span> <span class="k">=</span> <span class="s">&quot;Unknown resource!&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">bindingFuture</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Http.ServerBinding</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">serverSource</span><span class="o">.</span><span class="n">to</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">connection</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Accepted new connection from &quot;</span> <span class="o">+</span> <span class="n">connection</span><span class="o">.</span><span class="n">remoteAddress</span><span class="o">)</span>

    <span class="n">connection</span> <span class="n">handleWithSyncHandler</span> <span class="n">requestHandler</span>
    <span class="c1">// this is equivalent to</span>
    <span class="c1">// connection handleWith { Flow[HttpRequest] map requestHandler }</span>
  <span class="o">}).</span><span class="n">run</span><span class="o">()</span>
</pre></div>
</div>
<p>In this example, a request is handled by transforming the request stream with a function <tt class="docutils literal"><span class="pre">HttpRequest</span> <span class="pre">=&gt;</span> <span class="pre">HttpResponse</span></tt>
using <tt class="docutils literal"><span class="pre">handleWithSyncHandler</span></tt> (or equivalently, Akka Stream's <tt class="docutils literal"><span class="pre">map</span></tt> operator). Depending on the use case many
other ways of providing a request handler are conceivable using Akka Stream's combinators.</p>
<p>If the application provides a <tt class="docutils literal"><span class="pre">Flow</span></tt> it is also the responsibility of the application to generate exactly one response
for every request and that the ordering of responses matches the ordering of the associated requests (which is relevant
if HTTP pipelining is enabled where processing of multiple incoming requests may overlap). When relying on
<tt class="docutils literal"><span class="pre">handleWithSyncHandler</span></tt> or <tt class="docutils literal"><span class="pre">handleWithAsyncHandler</span></tt>, or the <tt class="docutils literal"><span class="pre">map</span></tt> or <tt class="docutils literal"><span class="pre">mapAsync</span></tt> stream operators, this
requirement will be automatically fulfilled.</p>
<div class="section" id="streaming-request-response-entities">
<h3>Streaming Request/Response Entities</h3>
<p>Streaming of HTTP message entities is supported through subclasses of <tt class="docutils literal"><span class="pre">HttpEntity</span></tt>. The application needs to be able
to deal with streamed entities when receiving a request as well as, in many cases, when constructing responses.
See <a class="reference internal" href="common/http-model.html#httpentity-scala"><em>HttpEntity</em></a> for a description of the alternatives.</p>
<p>If you rely on the <a class="reference internal" href="common/marshalling.html#http-marshalling-scala"><em>Marshalling</em></a> and/or <a class="reference internal" href="common/unmarshalling.html#http-unmarshalling-scala"><em>Unmarshalling</em></a> facilities provided by
Akka HTTP then the conversion of custom types to and from streamed entities can be quite convenient.</p>
</div>
<div class="section" id="closing-a-connection">
<span id="http-closing-connection-low-level"></span><h3>Closing a connection</h3>
<p>The HTTP connection will be closed when the handling <tt class="docutils literal"><span class="pre">Flow</span></tt> cancels its upstream subscription or the peer closes the
connection. An often times more convenient alternative is to explicitly add a <tt class="docutils literal"><span class="pre">Connection:</span> <span class="pre">close</span></tt> header to an
<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>. This response will then be the last one on the connection and the server will actively close the
connection when it has been sent out.</p>
<p>Connection will also be closed if request entity has been cancelled (e.g. by attaching it to <tt class="docutils literal"><span class="pre">Sink.cancelled</span></tt>)
or consumed only partially (e.g. by using <tt class="docutils literal"><span class="pre">take</span></tt> combinator). In order to prevent this behaviour entity should be
explicitly drained by attaching it to <tt class="docutils literal"><span class="pre">Sink.ignore</span></tt>.</p>
</div>
</div>
<div class="section" id="configuring-server-side-https">
<h2>Configuring Server-side HTTPS</h2>
<p>For detailed documentation about configuring and using HTTPS on the server-side refer to <a class="reference internal" href="server-side-https-support.html#serversidehttps-scala"><em>Server-Side HTTPS Support</em></a>.</p>
</div>
<div class="section" id="stand-alone-http-layer-usage">
<span id="http-server-layer-scala"></span><h2>Stand-Alone HTTP Layer Usage</h2>
<p>Due to its Reactive-Streams-based nature the Akka HTTP layer is fully detachable from the underlying TCP
interface. While in most applications this &quot;feature&quot; will not be crucial it can be useful in certain cases to be able
to &quot;run&quot; the HTTP layer (and, potentially, higher-layers) against data that do not come from the network but rather
some other source. Potential scenarios where this might be useful include tests, debugging or low-level event-sourcing
(e.g by replaying network traffic).</p>
<p>On the server-side the stand-alone HTTP layer forms a <tt class="docutils literal"><span class="pre">BidiFlow</span></tt> that is defined like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * The type of the server-side HTTP layer as a stand-alone BidiFlow</span>
<span class="cm"> * that can be put atop the TCP layer to form an HTTP server.</span>
<span class="cm"> *</span>
<span class="cm"> * {{{</span>
<span class="cm"> *                +------+</span>
<span class="cm"> * HttpResponse ~&gt;|      |~&gt; SslTlsOutbound</span>
<span class="cm"> *                | bidi |</span>
<span class="cm"> * HttpRequest  &lt;~|      |&lt;~ SslTlsInbound</span>
<span class="cm"> *                +------+</span>
<span class="cm"> * }}}</span>
<span class="cm"> */</span>
<span class="k">type</span> <span class="kt">ServerLayer</span> <span class="o">=</span> <span class="nc">BidiFlow</span><span class="o">[</span><span class="kt">HttpResponse</span>, <span class="kt">SslTlsOutbound</span>, <span class="kt">SslTlsInbound</span>, <span class="kt">HttpRequest</span>, <span class="kt">NotUsed</span><span class="o">]</span>
</pre></div>
</div>
<p>You create an instance of <tt class="docutils literal"><span class="pre">Http.ServerLayer</span></tt> by calling one of the two overloads of the <tt class="docutils literal"><span class="pre">Http().serverLayer</span></tt> method,
which also allows for varying degrees of configuration.</p>
</div>
<div class="section" id="controlling-server-parallelism">
<h2>Controlling server parallelism</h2>
<p>Request handling can be parallelized on two axes, by handling several connections in parallel and by
relying on HTTP pipelining to send several requests on one connection without waiting for a response first. In both
cases the client controls the number of ongoing requests. To prevent being overloaded by too many requests, Akka HTTP
can limit the number of requests it handles in parallel.</p>
<p>To limit the number of simultaneously open connections, use the <tt class="docutils literal"><span class="pre">akka.http.server.max-connections</span></tt> setting. This setting
applies to all of <tt class="docutils literal"><span class="pre">Http.bindAndHandle*</span></tt> methods. If you use <tt class="docutils literal"><span class="pre">Http.bind</span></tt>, incoming connections are represented by
a <tt class="docutils literal"><span class="pre">Source[IncomingConnection,</span> <span class="pre">...]</span></tt>. Use Akka Stream's combinators to apply backpressure to control the flow of
incoming connections, e.g. by using <tt class="docutils literal"><span class="pre">throttle</span></tt> or <tt class="docutils literal"><span class="pre">mapAsync</span></tt>.</p>
<p>HTTP pipelining is generally discouraged (and <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=HTTP_pipelining&amp;oldid=700966692#Implementation_in_web_browsers">disabled by most browsers</a>) but
is nevertheless fully supported in Akka HTTP. The limit is applied on two levels. First, there's the
<tt class="docutils literal"><span class="pre">akka.http.server.pipeline-limit</span></tt> config setting which prevents that more than the given number of outstanding requests
is ever given to the user-supplied handler-flow. On the other hand, the handler flow itself can apply any kind of throttling
itself. If you use one of the <tt class="docutils literal"><span class="pre">Http.bindAndHandleSync</span></tt> or <tt class="docutils literal"><span class="pre">Http.bindAndHandleAsync</span></tt>
entry-points, you can specify the <tt class="docutils literal"><span class="pre">parallelism</span></tt> argument (default = 1, i.e. pipelining disabled) to control the
number of concurrent requests per connection. If you use <tt class="docutils literal"><span class="pre">Http.bindAndHandle</span></tt> or <tt class="docutils literal"><span class="pre">Http.bind</span></tt>, the user-supplied handler
flow has full control over how many request it accepts simultaneously by applying backpressure. In this case, you can
e.g. use Akka Stream's <tt class="docutils literal"><span class="pre">mapAsync</span></tt> combinator with a given parallelism to limit the number of concurrently handled requests.
Effectively, the more constraining one of these two measures, config setting and manual flow shaping, will determine
how parallel requests on one connection are handled.</p>
</div>
<div class="section" id="handling-http-server-failures-in-the-low-level-api">
<span id="handling-http-server-failures-low-level-scala"></span><h2>Handling HTTP Server failures in the Low-Level API</h2>
<p>There are various situations when failure may occur while initialising or running an Akka HTTP server.
Akka by default will log all these failures, however sometimes one may want to react to failures in addition to them
just being logged, for example by shutting down the actor system, or notifying some external monitoring end-point explicitly.</p>
<p>There are multiple things that can fail when creating and materializing an HTTP Server (similarily, the same applied to
a plain streaming <tt class="docutils literal"><span class="pre">Tcp()</span></tt> server). The types of failures that can happen on different layers of the stack, starting
from being unable to start the server, and ending with failing to unmarshal an HttpRequest, examples of failures include
(from outer-most, to inner-most):</p>
<ul class="simple">
<li>Failure to <tt class="docutils literal"><span class="pre">bind</span></tt> to the specified address/port,</li>
<li>Failure while accepting new <tt class="docutils literal"><span class="pre">IncommingConnection</span></tt> s, for example when the OS has run out of file descriptors or memory,</li>
<li>Failure while handling a connection, for example if the incoming <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> is malformed.</li>
</ul>
<p>This section describes how to handle each failure situation, and in which situations these failures may occur.</p>
<p>The first type of failure is when the server is unable to bind to the given port. For example when the port
is already taken by another application, or if the port is privileged (i.e. only usable by <tt class="docutils literal"><span class="pre">root</span></tt>).
In this case the &quot;binding future&quot; will fail immediatly, and we can react to if by listening on the Future's completion:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http.ServerBinding</span>
<span class="k">import</span> <span class="nn">akka.stream.ActorMaterializer</span>

<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
<span class="c1">// needed for the future onFailure in the end</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">executionContext</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span>

<span class="c1">// let&#39;s say the OS won&#39;t allow us to bind to 80.</span>
<span class="k">val</span> <span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">80</span><span class="o">)</span>
<span class="k">val</span> <span class="n">serverSource</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">().</span><span class="n">bind</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span>

<span class="k">val</span> <span class="n">bindingFuture</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">ServerBinding</span><span class="o">]</span> <span class="k">=</span> <span class="n">serverSource</span>
  <span class="o">.</span><span class="n">to</span><span class="o">(</span><span class="n">handleConnections</span><span class="o">)</span> <span class="c1">// Sink[Http.IncomingConnection, _]</span>
  <span class="o">.</span><span class="n">run</span><span class="o">()</span>

<span class="n">bindingFuture</span><span class="o">.</span><span class="n">onFailure</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="n">ex</span><span class="o">,</span> <span class="s">&quot;Failed to bind to {}:{}!&quot;</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Once the server has successfully bound to a port, the <tt class="docutils literal"><span class="pre">Source[IncomingConnection,</span> <span class="pre">_]</span></tt> starts running and emiting
new incoming connections. This source technically can signal a failure as well, however this should only happen in very
dramantic situations such as running out of file descriptors or memory available to the system, such that it's not able
to accept a new incoming connection. Handling failures in Akka Streams is pretty stright forward, as failures are signaled
through the stream starting from the stage which failed, all the way downstream to the final stages.</p>
<p>In the example below we add a custom <tt class="docutils literal"><span class="pre">GraphStage</span></tt> (see <a class="reference internal" href="../stream/stream-customize.html#stream-customize-scala"><em>Custom stream processing</em></a>) in order to react to the
stream's failure. We signal a <tt class="docutils literal"><span class="pre">failureMonitor</span></tt> actor with the cause why the stream is going down, and let the Actor
handle the rest – maybe it'll decide to restart the server or shutdown the ActorSystem, that however is not our concern anymore.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorRef</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http</span>
<span class="k">import</span> <span class="nn">akka.stream.ActorMaterializer</span>
<span class="k">import</span> <span class="nn">akka.stream.scaladsl.Flow</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">executionContext</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span>

<span class="k">import</span> <span class="nn">Http._</span>
<span class="k">val</span> <span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">8080</span><span class="o">)</span>
<span class="k">val</span> <span class="n">serverSource</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">().</span><span class="n">bind</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span>

<span class="k">val</span> <span class="n">failureMonitor</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">MyExampleMonitoringActor</span><span class="o">.</span><span class="n">props</span><span class="o">)</span>

<span class="k">val</span> <span class="n">reactToTopLevelFailures</span> <span class="k">=</span> <span class="nc">Flow</span><span class="o">[</span><span class="kt">IncomingConnection</span><span class="o">]</span>
  <span class="o">.</span><span class="n">watchTermination</span><span class="o">()((</span><span class="k">_</span><span class="o">,</span> <span class="n">termination</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">termination</span><span class="o">.</span><span class="n">onFailure</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">cause</span> <span class="k">=&gt;</span> <span class="n">failureMonitor</span> <span class="o">!</span> <span class="n">cause</span>
  <span class="o">})</span>

<span class="n">serverSource</span>
  <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="n">reactToTopLevelFailures</span><span class="o">)</span>
  <span class="o">.</span><span class="n">to</span><span class="o">(</span><span class="n">handleConnections</span><span class="o">)</span> <span class="c1">// Sink[Http.IncomingConnection, _]</span>
  <span class="o">.</span><span class="n">run</span><span class="o">()</span>
</pre></div>
</div>
<p>The third type of failure that can occur is when the connection has been properly established,
however afterwards is terminated abruptly – for example by the client aborting the underlying TCP connection.
To handle this failure we can use the same pattern as in the previous snippet, however apply it to the connection's Flow:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.model._</span>
<span class="k">import</span> <span class="nn">akka.stream.ActorMaterializer</span>
<span class="k">import</span> <span class="nn">akka.stream.scaladsl.Flow</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">executionContext</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span>

<span class="k">val</span> <span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">8080</span><span class="o">)</span>
<span class="k">val</span> <span class="n">serverSource</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">().</span><span class="n">bind</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span>

<span class="k">val</span> <span class="n">reactToConnectionFailure</span> <span class="k">=</span> <span class="nc">Flow</span><span class="o">[</span><span class="kt">HttpRequest</span><span class="o">]</span>
  <span class="o">.</span><span class="n">recover</span><span class="o">[</span><span class="kt">HttpRequest</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span> <span class="k">=&gt;</span>
      <span class="c1">// handle the failure somehow</span>
      <span class="k">throw</span> <span class="n">ex</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">httpEcho</span> <span class="k">=</span> <span class="nc">Flow</span><span class="o">[</span><span class="kt">HttpRequest</span><span class="o">]</span>
  <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="n">reactToConnectionFailure</span><span class="o">)</span>
  <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">request</span> <span class="k">=&gt;</span>
    <span class="c1">// simple streaming (!) &quot;echo&quot; response:</span>
    <span class="nc">HttpResponse</span><span class="o">(</span><span class="n">entity</span> <span class="k">=</span> <span class="nc">HttpEntity</span><span class="o">(</span><span class="nc">ContentTypes</span><span class="o">.</span><span class="n">`text/plain(UTF-8)`</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">dataBytes</span><span class="o">))</span>
  <span class="o">}</span>

<span class="n">serverSource</span>
  <span class="o">.</span><span class="n">runForeach</span> <span class="o">{</span> <span class="n">con</span> <span class="k">=&gt;</span>
    <span class="n">con</span><span class="o">.</span><span class="n">handleWith</span><span class="o">(</span><span class="n">httpEcho</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>These failures can be described more or less infrastructure related, they are failing bindings or connections.
Most of the time you won't need to dive into those very deeply, as Akka will simply log errors of this kind
anyway, which is a reasonable default for such problems.</p>
<p>In order to learn more about handling exceptions in the actual routing layer, which is where your application code
comes into the picture, refer to <a class="reference internal" href="routing-dsl/exception-handling.html#exception-handling-scala"><em>Exception Handling</em></a> which focuses explicitly on explaining how exceptions
thrown in routes can be handled and transformed into <tt class="xref py py-class docutils literal"><span class="pre">HttpResponse</span></tt> s with apropriate error codes and human-readable failure descriptions.</p>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>