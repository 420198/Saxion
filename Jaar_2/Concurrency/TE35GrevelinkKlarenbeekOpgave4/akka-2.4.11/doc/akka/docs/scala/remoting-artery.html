


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Remoting (codename Artery) &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Networking" href="index-network.html" />
    <link rel="next" title="Serialization" href="serialization.html" />
    <link rel="prev" title="Remoting" href="remoting.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Remoting (codename Artery)</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="serialization.html">Serialization</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="remoting.html">Remoting</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="remoting-codename-artery">
<span id="remoting-artery-scala"></span><h1>Remoting (codename Artery)</h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This page describes the experimental remoting subsystem, codenamed <em>Artery</em> that will eventually replace the
old remoting implementation. For the current stable remoting system please refer to <a class="reference internal" href="remoting.html#remoting-scala"><em>Remoting</em></a>.</p>
</div>
<p>Remoting enables Actor systems on different hosts or JVMs to communicate with each other. By enabling remoting
the system will start listening on a provided network address and also gains the ability to connect to other
systems through the network. From the application's perspective there is no API difference between local or remote
systems, <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> instances that point to remote systems look exactly the same as local ones: they can be
sent messages to, watched, etc.
Every <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> contains hostname and port information and can be passed around even on the network. This means
that on a network every <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> is a unique identifier of an actor on that network.</p>
<p>Remoting is not a server-client technology. All systems using remoting can contact any other system on the network
if they possess an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> pointing to those system. This means that every system that is remoting enabled
acts as a &quot;server&quot; to which arbitrary systems on the same network can connect to.</p>
<div class="section" id="what-is-new-in-artery">
<h2>What is new in Artery</h2>
<p>Artery is a reimplementation of the old remoting module aimed at improving performance and stability. It is mostly
backwards compatible with the old implementation and it is a drop-in replacement in many cases. Main features
of Artery compared to the previous implementation:</p>
<ul class="simple">
<li>Based on <a class="reference external" href="https://github.com/real-logic/Aeron">Aeron</a> (UDP) instead of TCP</li>
<li>Focused on high-throughput, low-latency communication</li>
<li>Isolation of internal control messages from user messages improving stability and reducing false failure detection
in case of heavy traffic by using a dedicated subchannel.</li>
<li>Mostly allocation-free operation</li>
<li>Support for a separate subchannel for large messages to avoid interference with smaller messages</li>
<li>Compression of actor paths on the wire to reduce overhead for smaller messages</li>
<li>Support for faster serialization/deserialization using ByteBuffers directly</li>
<li>Built-in Flight-Recorder to help debugging implementation issues without polluting users logs with implementaiton
specific events</li>
<li>Providing protocol stability across major Akka versions to support rolling updates of large-scale systems</li>
</ul>
<p>The main incompatible change from the previous implementation that the protocol field of the string representation of an
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> is always <cite>akka</cite> instead of the previously used <cite>akka.tcp</cite> or <cite>akka.ssl.tcp</cite>. Configuration properties
are also different.</p>
</div>
<div class="section" id="preparing-your-actorsystem-for-remoting">
<h2>Preparing your ActorSystem for Remoting</h2>
<p>The Akka remoting is a separate jar file. Make sure that you have the following dependency in your project:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-remote&quot;</span> <span class="o">%</span> <span class="s">&quot;2.4.11&quot;</span>
</pre></div>
</div>
<p>To enable remote capabilities in your Akka project you should, at a minimum, add the following changes
to your <tt class="docutils literal"><span class="pre">application.conf</span></tt> file:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span> <span class="o">{</span>
  <span class="n">actor</span> <span class="o">{</span>
    <span class="n">provider</span> <span class="k">=</span> <span class="n">remote</span>
  <span class="o">}</span>
  <span class="n">remote</span> <span class="o">{</span>
    <span class="n">artery</span> <span class="o">{</span>
      <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">canonical</span><span class="o">.</span><span class="n">hostname</span> <span class="k">=</span> <span class="s">&quot;127.0.0.1&quot;</span>
      <span class="n">canonical</span><span class="o">.</span><span class="n">port</span> <span class="k">=</span> <span class="mi">25520</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>As you can see in the example above there are four things you need to add to get started:</p>
<ul class="simple">
<li>Change provider from <tt class="docutils literal"><span class="pre">local</span></tt> to <tt class="docutils literal"><span class="pre">remote</span></tt></li>
<li>Enable Artery to use it as the remoting implementation</li>
<li>Add host name - the machine you want to run the actor system on; this host
name is exactly what is passed to remote systems in order to identify this
system and consequently used for connecting back to this system if need be,
hence set it to a reachable IP address or resolvable name in case you want to
communicate across the network.</li>
<li>Add port number - the port the actor system should listen on, set to 0 to have it chosen automatically</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The port number needs to be unique for each actor system on the same machine even if the actor
systems have different names. This is because each actor system has its own networking subsystem
listening for connections and handling messages as not to interfere with other actor systems.</p>
</div>
<p>The example above only illustrates the bare minimum of properties you have to add to enable remoting.
All settings are described in <a class="reference internal" href="#remote-configuration-artery-scala"><em>Remote Configuration</em></a>.</p>
<div class="section" id="canonical-address">
<h3>Canonical address</h3>
<p>In order to remoting to work properly, where each system can send messages to any other system on the same network
(for example a system forwards a message to a third system, and the third replies directly to the sender system)
it is essential for every system to have a <em>unique, globally reachable</em> address and port. This address is part of the
unique name of the system and will be used by other systems to open a connection to it and send messages. This means
that if a host has multiple names (different DNS records pointing to the same IP address) then only one of these
can be <em>canonical</em>. If a message arrives to a system but it contains a different hostname than the expected canonical
name then the message will be dropped. If multiple names for a system would be allowed, then equality checks among
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> instances would no longer to be trusted and this would violate the fundamental assumption that
an actor has a globally unique reference on a given network. As a consequence, this also means that localhost addresses
(e.g. <cite>127.0.0.1</cite>) cannot be used in general (apart from local development) since they are not unique addresses in a
real network.</p>
<p>In cases, where Network Address Translation (NAT) is used or other network bridging is involved, it is important
to configure the system so that it understands that there is a difference between his externally visible, canonical
address and between the host-port pair that is used to listen for connections. See <a class="reference internal" href="#remote-configuration-nat-artery-scala"><em>Akka behind NAT or in a Docker container</em></a>
for details.</p>
</div>
</div>
<div class="section" id="acquiring-references-to-remote-actors">
<h2>Acquiring references to remote actors</h2>
<p>In order to communicate with an actor, it is necessary to have its <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>. In the local case it is usually
the creator of the actor (the caller of <tt class="docutils literal"><span class="pre">actorOf()</span></tt>) is who gets the <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> for an actor that it can
then send to other actors. In other words:</p>
<ul class="simple">
<li>An Actor can get a remote Actor's reference simply by receiving a message from it (as it's available as <cite>sender()</cite> then),
or inside of a remote message (e.g. <cite>PleaseReply(message: String, remoteActorRef: ActorRef)</cite>)</li>
</ul>
<p>Alternatively, an actor can look up another located at a known path using
<tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt>. These methods are available even in remoting enabled systems:</p>
<ul class="simple">
<li>Remote Lookup    : used to look up an actor on a remote node with <tt class="docutils literal"><span class="pre">actorSelection(path)</span></tt></li>
<li>Remote Creation  : used to create an actor on a remote node with <tt class="docutils literal"><span class="pre">actorOf(Props(...),</span> <span class="pre">actorName)</span></tt></li>
</ul>
<p>In the next sections the two alternatives are described in detail.</p>
<div class="section" id="looking-up-remote-actors">
<h3>Looking up Remote Actors</h3>
<p><tt class="docutils literal"><span class="pre">actorSelection(path)</span></tt> will obtain an <tt class="docutils literal"><span class="pre">ActorSelection</span></tt> to an Actor on a remote node, e.g.:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">selection</span> <span class="k">=</span>
  <span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;akka://actorSystemName@10.0.0.1:25520/user/actorName&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>As you can see from the example above the following pattern is used to find an actor on a remote node:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">://&lt;</span><span class="n">actor</span> <span class="n">system</span><span class="o">&gt;@&lt;</span><span class="n">hostname</span><span class="o">&gt;:&lt;</span><span class="n">port</span><span class="o">&gt;/&lt;</span><span class="n">actor</span> <span class="n">path</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike with earlier remoting, the protocol field is always <cite>akka</cite> as pluggable transports are no longer supported.</p>
</div>
<p>Once you obtained a selection to the actor you can interact with it in the same way you would with a local actor, e.g.:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">selection</span> <span class="o">!</span> <span class="s">&quot;Pretty awesome feature&quot;</span>
</pre></div>
</div>
<p>To acquire an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> for an <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt> you need to
send a message to the selection and use the <tt class="docutils literal"><span class="pre">sender</span></tt> reference of the reply from
the actor. There is a built-in <tt class="docutils literal"><span class="pre">Identify</span></tt> message that all Actors will understand
and automatically reply to with a <tt class="docutils literal"><span class="pre">ActorIdentity</span></tt> message containing the
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>. This can also be done with the <tt class="docutils literal"><span class="pre">resolveOne</span></tt> method of
the <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt>, which returns a <tt class="docutils literal"><span class="pre">Future</span></tt> of the matching
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>.</p>
<p>For more details on how actor addresses and paths are formed and used, please refer to <a class="reference internal" href="../general/addressing.html#addressing"><em>Actor References, Paths and Addresses</em></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Message sends to actors that are actually in the sending actor system do not
get delivered via the remote actor ref provider. They're delivered directly,
by the local actor ref provider.</p>
<p class="last">Aside from providing better performance, this also means that if the hostname
you configure remoting to listen as cannot actually be resolved from within
the very same actor system, such messages will (perhaps counterintuitively)
be delivered just fine.</p>
</div>
</div>
<div class="section" id="creating-actors-remotely">
<h3>Creating Actors Remotely</h3>
<p>If you want to use the creation functionality in Akka remoting you have to further amend the
<tt class="docutils literal"><span class="pre">application.conf</span></tt> file in the following way (only showing deployment section):</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span> <span class="o">{</span>
  <span class="n">actor</span> <span class="o">{</span>
    <span class="n">deployment</span> <span class="o">{</span>
      <span class="o">/</span><span class="n">sampleActor</span> <span class="o">{</span>
        <span class="n">remote</span> <span class="k">=</span> <span class="s">&quot;akka://sampleActorSystem@127.0.0.1:2553&quot;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The configuration above instructs Akka to react when an actor with path <tt class="docutils literal"><span class="pre">/sampleActor</span></tt> is created, i.e.
using <tt class="docutils literal"><span class="pre">system.actorOf(Props(...),</span> <span class="pre">&quot;sampleActor&quot;)</span></tt>. This specific actor will not be directly instantiated,
but instead the remote daemon of the remote system will be asked to create the actor,
which in this sample corresponds to <tt class="docutils literal"><span class="pre">sampleActorSystem&#64;127.0.0.1:2553</span></tt>.</p>
<p>Once you have configured the properties above you would do the following in code:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">actor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">SampleActor</span><span class="o">],</span> <span class="s">&quot;sampleActor&quot;</span><span class="o">)</span>
<span class="n">actor</span> <span class="o">!</span> <span class="s">&quot;Pretty slick&quot;</span>
</pre></div>
</div>
<p>The actor class <tt class="docutils literal"><span class="pre">SampleActor</span></tt> has to be available to the runtimes using it, i.e. the classloader of the
actor systems has to have a JAR containing the class.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In order to ensure serializability of <tt class="docutils literal"><span class="pre">Props</span></tt> when passing constructor
arguments to the actor being created, do not make the factory an inner class:
this will inherently capture a reference to its enclosing object, which in
most cases is not serializable. It is best to create a factory method in the
companion object of the actor’s class.</p>
<p class="last">Serializability of all Props can be tested by setting the configuration item
<tt class="docutils literal"><span class="pre">akka.actor.serialize-creators=on</span></tt>. Only Props whose <tt class="docutils literal"><span class="pre">deploy</span></tt> has
<tt class="docutils literal"><span class="pre">LocalScope</span></tt> are exempt from this check.</p>
</div>
<p>You can use asterisks as wildcard matches for the actor paths, so you could specify:
<tt class="docutils literal"><span class="pre">/*/sampleActor</span></tt> and that would match all <tt class="docutils literal"><span class="pre">sampleActor</span></tt> on that level in the hierarchy.
You can also use wildcard in the last position to match all actors at a certain level:
<tt class="docutils literal"><span class="pre">/someParent/*</span></tt>. Non-wildcard matches always have higher priority to match than wildcards, so:
<tt class="docutils literal"><span class="pre">/foo/bar</span></tt> is considered <strong>more specific</strong> than <tt class="docutils literal"><span class="pre">/foo/*</span></tt> and only the highest priority match is used.
Please note that it <strong>cannot</strong> be used to partially match section, like this: <tt class="docutils literal"><span class="pre">/foo*/bar</span></tt>, <tt class="docutils literal"><span class="pre">/f*o/bar</span></tt> etc.</p>
</div>
<div class="section" id="programmatic-remote-deployment">
<h3>Programmatic Remote Deployment</h3>
<p>To allow dynamically deployed systems, it is also possible to include
deployment configuration in the <tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> which are used to create an
actor: this information is the equivalent of a deployment section from the
configuration file, and if both are given, the external configuration takes
precedence.</p>
<p>With these imports:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Props</span><span class="o">,</span> <span class="nc">Deploy</span><span class="o">,</span> <span class="nc">Address</span><span class="o">,</span> <span class="nc">AddressFromURIString</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.remote.RemoteScope</span>
</pre></div>
</div>
<p>and a remote address like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">one</span> <span class="k">=</span> <span class="nc">AddressFromURIString</span><span class="o">(</span><span class="s">&quot;akka://sys@host:1234&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">two</span> <span class="k">=</span> <span class="nc">Address</span><span class="o">(</span><span class="s">&quot;akka&quot;</span><span class="o">,</span> <span class="s">&quot;sys&quot;</span><span class="o">,</span> <span class="s">&quot;host&quot;</span><span class="o">,</span> <span class="mi">1234</span><span class="o">)</span> <span class="c1">// this gives the same</span>
</pre></div>
</div>
<p>you can advise the system to create a child on that remote node like so:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">SampleActor</span><span class="o">].</span>
  <span class="n">withDeploy</span><span class="o">(</span><span class="nc">Deploy</span><span class="o">(</span><span class="n">scope</span> <span class="k">=</span> <span class="nc">RemoteScope</span><span class="o">(</span><span class="n">address</span><span class="o">))))</span>
</pre></div>
</div>
</div>
<div class="section" id="untrusted-mode">
<h3>Untrusted Mode</h3>
<p>As soon as an actor system can connect to another remotely, it may in principle
send any possible message to any actor contained within that remote system. One
example may be sending a <tt class="xref py py-class docutils literal"><span class="pre">PoisonPill</span></tt> to the system guardian, shutting
that system down. This is not always desired, and it can be disabled with the
following setting:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">remote</span><span class="o">.</span><span class="n">artery</span><span class="o">.</span><span class="n">untrusted</span><span class="o">-</span><span class="n">mode</span> <span class="k">=</span> <span class="n">on</span>
</pre></div>
</div>
<p>This disallows sending of system messages (actor life-cycle commands,
DeathWatch, etc.) and any message extending <tt class="xref py py-class docutils literal"><span class="pre">PossiblyHarmful</span></tt> to the
system on which this flag is set. Should a client send them nonetheless they
are dropped and logged (at DEBUG level in order to reduce the possibilities for
a denial of service attack). <tt class="xref py py-class docutils literal"><span class="pre">PossiblyHarmful</span></tt> covers the predefined
messages like <tt class="xref py py-class docutils literal"><span class="pre">PoisonPill</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">Kill</span></tt>, but it can also be added
as a marker trait to user-defined messages.</p>
<p>Messages sent with actor selection are by default discarded in untrusted mode, but
permission to receive actor selection messages can be granted to specific actors
defined in configuration:</p>
<div class="highlight-scala"><pre>akka.remote.artery..trusted-selection-paths = ["/user/receptionist", "/user/namingService"]</pre>
</div>
<p>The actual message must still not be of type <tt class="xref py py-class docutils literal"><span class="pre">PossiblyHarmful</span></tt>.</p>
<p>In summary, the following operations are ignored by a system configured in
untrusted mode when incoming via the remoting layer:</p>
<ul class="simple">
<li>remote deployment (which also means no remote supervision)</li>
<li>remote DeathWatch</li>
<li><tt class="docutils literal"><span class="pre">system.stop()</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">PoisonPill</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Kill</span></tt></li>
<li>sending any message which extends from the <tt class="xref py py-class docutils literal"><span class="pre">PossiblyHarmful</span></tt> marker
interface, which includes <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt></li>
<li>messages sent with actor selection, unless destination defined in <tt class="docutils literal"><span class="pre">trusted-selection-paths</span></tt>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Enabling the untrusted mode does not remove the capability of the client to
freely choose the target of its message sends, which means that messages not
prohibited by the above rules can be sent to any actor in the remote system.
It is good practice for a client-facing system to only contain a well-defined
set of entry point actors, which then forward requests (possibly after
performing validation) to another actor system containing the actual worker
actors. If messaging between these two server-side systems is done using
local <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> (they can be exchanged safely between actor systems
within the same JVM), you can restrict the messages on this interface by
marking them <tt class="xref py py-class docutils literal"><span class="pre">PossiblyHarmful</span></tt> so that a client cannot forge them.</p>
</div>
</div>
</div>
<div class="section" id="quarantine">
<h2>Quarantine</h2>
<p>Akka remoting is using Aeron as underlying message transport. Aeron is using UDP and adds
among other things reliable delivery and session semantics, very similar to TCP. This means that
the order of the messages are preserved, which is needed for the <a class="reference internal" href="../general/message-delivery-reliability.html#message-ordering"><em>Actor message ordering guarantees</em></a>.
Under normal circumstances all messages will be delivered but there are cases when messages
may not be delivered to the destination:</p>
<ul class="simple">
<li>during a network partition and the Aeron session is broken, this automatically recovered once the partition is over</li>
<li>when sending too many messages without flow control and thereby filling up the outbound send queue (<tt class="docutils literal"><span class="pre">outbound-message-queue-size</span></tt> config)</li>
<li>if serialization or deserialization of a message fails (only that message will be dropped)</li>
<li>if an unexpected exception occurs in the remoting infrastructure</li>
</ul>
<p>In short, Actor message delivery is “at-most-once” as described in <a class="reference internal" href="../general/message-delivery-reliability.html#message-delivery-reliability"><em>Message Delivery Reliability</em></a></p>
<p>Some messages in Akka are called system messages and those cannot be dropped because that would result
in an inconsistent state between the systems. Such messages are used for essentially two features; remote death
watch and remote deployment. These messages are delivered by Akka remoting with “exactly-once” guarantee by
confirming each message and resending unconfirmed messages. If a system message anyway cannot be delivered the
association with the destination system is irrecoverable failed, and Terminated is signaled for all watched
actors on the remote system. It is placed in a so called quarantined state. Quarantine usually does not
happen if remote watch or remote deployment is not used.</p>
<p>Each <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> instance has an unique identifier (UID), which is important for differentiating between
incarnations of a system when it is restarted with the same hostname and port. It is the specific
incarnation (UID) that is quarantined. The only way to recover from this state is to restart one of the
actor systems.</p>
<p>Messages that are sent to and received from a quarantined system will be dropped. However, it is possible to
send messages with <tt class="docutils literal"><span class="pre">actorSelection</span></tt> to the address of a quarantined system, which is useful to probe if the
system has been restarted.</p>
<p>An association will be quarantined when:</p>
<ul class="simple">
<li>Cluster node is removed from the cluster membership.</li>
<li>Remote failure detector triggers, i.e. remote watch is used. This is different when <a class="reference internal" href="cluster-usage.html#cluster-usage-scala"><em>Akka Cluster</em></a>
is used. The unreachable observation by the cluster failure detector can go back to reachable if the network
partition heals. A cluster member is not quarantined when the failure detector triggers.</li>
<li>Overflow of the system message delivery buffer, e.g. because of too many <tt class="docutils literal"><span class="pre">watch</span></tt> requests at the same time
(<tt class="docutils literal"><span class="pre">system-message-buffer-size</span></tt> config).</li>
<li>Unexpected exception occurs in the control subchannel of the remoting infrastructure.</li>
</ul>
<p>The UID of the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> is exchanged in a two-way handshake when the first message is sent to
a destination. The handshake will be retried until the other system replies and no other messages will
pass through until the handshake is completed. If the handshake cannot be established within a timeout
(<tt class="docutils literal"><span class="pre">handshake-timeout</span></tt> config) the association is stopped (freeing up resources). Queued messages will be
dropped if the handshake cannot be established. It will not be quarantined, because the UID is unknown.
New handshake attempt will start when next message is sent to the destination.</p>
<p>Handshake requests are actually also sent periodically to be able to establish a working connection
when the destination system has been restarted.</p>
<div class="section" id="watching-remote-actors">
<h3>Watching Remote Actors</h3>
<p>Watching a remote actor is API wise not different than watching a local actor, as described in
<a class="reference internal" href="actors.html#deathwatch-scala"><em>Lifecycle Monitoring aka DeathWatch</em></a>. However, it is important to note, that unlike in the local case, remoting has to handle
when a remote actor does not terminate in a graceful way sending a system message to notify the watcher actor about
the event, but instead being hosted on a system which stopped abruptly (crashed). These situations are handled
by the built-in failure detector.</p>
</div>
<div class="section" id="failure-detector">
<h3>Failure Detector</h3>
<p>Under the hood remote death watch uses heartbeat messages and a failure detector to generate <tt class="docutils literal"><span class="pre">Terminated</span></tt>
message from network failures and JVM crashes, in addition to graceful termination of watched
actor.</p>
<p>The heartbeat arrival times is interpreted by an implementation of
<a class="reference external" href="http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf">The Phi Accrual Failure Detector</a>.</p>
<p>The suspicion level of failure is given by a value called <em>phi</em>.
The basic idea of the phi failure detector is to express the value of <em>phi</em> on a scale that
is dynamically adjusted to reflect current network conditions.</p>
<p>The value of <em>phi</em> is calculated as:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">phi</span> <span class="k">=</span> <span class="o">-</span><span class="n">log10</span><span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="o">(</span><span class="n">timeSinceLastHeartbeat</span><span class="o">))</span>
</pre></div>
</div>
<p>where F is the cumulative distribution function of a normal distribution with mean
and standard deviation estimated from historical heartbeat inter-arrival times.</p>
<p>In the <a class="reference internal" href="#remote-configuration-artery-scala"><em>Remote Configuration</em></a> you can adjust the <tt class="docutils literal"><span class="pre">akka.remote.watch-failure-detector.threshold</span></tt>
to define when a <em>phi</em> value is considered to be a failure.</p>
<p>A low <tt class="docutils literal"><span class="pre">threshold</span></tt> is prone to generate many false positives but ensures
a quick detection in the event of a real crash. Conversely, a high <tt class="docutils literal"><span class="pre">threshold</span></tt>
generates fewer mistakes but needs more time to detect actual crashes. The
default <tt class="docutils literal"><span class="pre">threshold</span></tt> is 10 and is appropriate for most situations. However in
cloud environments, such as Amazon EC2, the value could be increased to 12 in
order to account for network issues that sometimes occur on such platforms.</p>
<p>The following chart illustrates how <em>phi</em> increase with increasing time since the
previous heartbeat.</p>
<img alt="../_images/phi11.png" src="../_images/phi11.png" />
<p>Phi is calculated from the mean and standard deviation of historical
inter arrival times. The previous chart is an example for standard deviation
of 200 ms. If the heartbeats arrive with less deviation the curve becomes steeper,
i.e. it is possible to determine failure more quickly. The curve looks like this for
a standard deviation of 100 ms.</p>
<img alt="../_images/phi21.png" src="../_images/phi21.png" />
<p>To be able to survive sudden abnormalities, such as garbage collection pauses and
transient network failures the failure detector is configured with a margin,
<tt class="docutils literal"><span class="pre">akka.remote.watch-failure-detector.acceptable-heartbeat-pause</span></tt>. You may want to
adjust the <a class="reference internal" href="#remote-configuration-artery-scala"><em>Remote Configuration</em></a> of this depending on you environment.
This is how the curve looks like for <tt class="docutils literal"><span class="pre">acceptable-heartbeat-pause</span></tt> configured to
3 seconds.</p>
<img alt="../_images/phi31.png" src="../_images/phi31.png" />
</div>
</div>
<div class="section" id="serialization">
<h2>Serialization</h2>
<p>When using remoting for actors you must ensure that the <tt class="docutils literal"><span class="pre">props</span></tt> and <tt class="docutils literal"><span class="pre">messages</span></tt> used for
those actors are serializable. Failing to do so will cause the system to behave in an unintended way.</p>
<p>For more information please see <a class="reference internal" href="serialization.html#serialization-scala"><em>Serialization</em></a>.</p>
<div class="section" id="bytebuffer-based-serialization">
<span id="remote-bytebuffer-serialization-scala"></span><h3>ByteBuffer based serialization</h3>
<p>Artery introduces a new serialization mechanism which allows the <tt class="docutils literal"><span class="pre">ByteBufferSerializer</span></tt> to directly write into a
shared <tt class="xref py py-class docutils literal"><span class="pre">java.nio.ByteBuffer</span></tt> instead of being forced to allocate and return an <tt class="docutils literal"><span class="pre">Array[Byte]</span></tt> for each serialized
message. For high-throughput messaging this API change can yield significant performance benefits, so we recommend
changing your serializers to use this new mechanism.</p>
<p>This new API also plays well with new versions of Google Protocol Buffers and other serialization libraries, which gained
the ability to serialize directly into and from ByteBuffers.</p>
<p>As the new feature only changes how bytes are read and written, and the rest of the serializatio infrastructure
remained the same, we recommend reading the <a class="reference internal" href="serialization.html#serialization-scala"><em>Serialization</em></a> documentation first.</p>
<p>Implementing an <tt class="xref py py-class docutils literal"><span class="pre">akka.serialization.ByteBufferSerializer</span></tt> works the same way as any other serializer,</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">trait</span> <span class="nc">ByteBufferSerializer</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Serializes the given object into the `ByteBuffer`.</span>
<span class="cm">   */</span>
  <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">,</span> <span class="n">buf</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>

  <span class="cm">/**</span>
<span class="cm">   * Produces an object from a `ByteBuffer`, with an optional type-hint;</span>
<span class="cm">   * the class should be loaded using ActorSystem.dynamicAccess.</span>
<span class="cm">   */</span>
  <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">AnyRef</span>

<span class="o">}</span>
</pre></div>
</div>
<p>Implementing a serializer for Artery is therefore as simple as implementing this interface, and binding the serializer
as usual (which is explained in <a class="reference internal" href="serialization.html#serialization-scala"><em>Serialization</em></a>).</p>
<p>Implementations should typically extend <tt class="docutils literal"><span class="pre">SerializerWithStringManifest</span></tt> and in addition to the <tt class="docutils literal"><span class="pre">ByteBuffer</span></tt> based
<tt class="docutils literal"><span class="pre">toBinary</span></tt> and <tt class="docutils literal"><span class="pre">fromBinary</span></tt> methods also implement the array based <tt class="docutils literal"><span class="pre">toBinary</span></tt> and <tt class="docutils literal"><span class="pre">fromBinary</span></tt> methods.
The array based methods will be used when <tt class="docutils literal"><span class="pre">ByteBuffer</span></tt> is not used, e.g. in Akka Persistence.</p>
<p>Note that the array based methods can be implemented by delegation like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">java.nio.ByteBuffer</span>
<span class="k">import</span> <span class="nn">akka.serialization.ByteBufferSerializer</span>
<span class="k">import</span> <span class="nn">akka.serialization.SerializerWithStringManifest</span>

  <span class="k">class</span> <span class="nc">ExampleByteBufSerializer</span> <span class="k">extends</span> <span class="nc">SerializerWithStringManifest</span> <span class="k">with</span> <span class="nc">ByteBufferSerializer</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1337</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;naive-toStringImpl&quot;</span>

    <span class="c1">// Implement this method for compatibility with `SerializerWithStringManifest`.</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="c1">// in production code, aquire this from a BufferPool</span>
      <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="n">allocate</span><span class="o">(</span><span class="mi">256</span><span class="o">)</span>

      <span class="n">toBinary</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">buf</span><span class="o">)</span>
      <span class="n">buf</span><span class="o">.</span><span class="n">flip</span><span class="o">()</span>
      <span class="k">val</span> <span class="n">bytes</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">ofDim</span><span class="o">[</span><span class="kt">Byte</span><span class="o">](</span><span class="n">buf</span><span class="o">.</span><span class="n">remaining</span><span class="o">)</span>
      <span class="n">buf</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
      <span class="n">bytes</span>
    <span class="o">}</span>

    <span class="c1">// Implement this method for compatibility with `SerializerWithStringManifest`.</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span>
      <span class="n">fromBinary</span><span class="o">(</span><span class="nc">ByteBuffer</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="n">bytes</span><span class="o">),</span> <span class="n">manifest</span><span class="o">)</span>

    <span class="c1">// Actual implementation in the ByteBuffer versions of to/fromBinary:</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">,</span> <span class="n">buf</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">???</span> <span class="c1">// implement actual logic here</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span> <span class="o">???</span> <span class="c1">// implement actual logic here</span>
  <span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="disabling-the-java-serializer">
<h3>Disabling the Java Serializer</h3>
<p>With Artery it is possible to completely disable Java Serialization for the entire Actor system.</p>
<p>Java serialization is known to be slow and prone to attacks of various kinds - it never was designed for high
throughput messaging after all. However it is very convenient to use, thus it remained the default serialization
mechanism that Akka used to serialize user messages as well as some of its internal messages in previous versions.
Since the release of Artery, Akka internals do not rely on Java serialization anymore (exceptions to that being <tt class="docutils literal"><span class="pre">java.lang.Throwable</span></tt> and &quot;remote deployment&quot;).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When using Artery, Akka does not use Java Serialization for any of it's internal messages.
It is highly encouraged to disable java serialization, so please plan to do so at the earliest possibility you have in your project.</p>
<p class="last">One may think that network bandwidth and latency limit the performance of remote messaging, but serialization is a more typical bottleneck.</p>
</div>
<p>For user messages, the default serializer, implemented using Java serialization, remains available and enabled in Artery.
We do however recommend to disable it entirely and utilise a proper serialization library instead in order effectively utilise
the improved performance and ability for rolling deployments using Artery. Libraries that we recommend to use include,
but are not limited to, <a class="reference external" href="https://github.com/EsotericSoftware/kryo">Kryo</a> by using the <a class="reference external" href="https://github.com/romix/akka-kryo-serialization">akka-kryo-serialization</a> library or <a class="reference external" href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a> if you want
more control over the schema evolution of your messages.</p>
<p>In order to completely disable Java Serialization in your Actor system you need to add the following configuration to
your <tt class="docutils literal"><span class="pre">application.conf</span></tt>:</p>
<div class="highlight-ruby"><div class="highlight"><pre><span class="n">akka</span> <span class="p">{</span>
  <span class="n">actor</span> <span class="p">{</span>
    <span class="n">serialization</span><span class="o">-</span><span class="n">bindings</span> <span class="p">{</span>
      <span class="s2">&quot;java.io.Serializable&quot;</span> <span class="o">=</span> <span class="n">none</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Please note that this means that you will have to configure different serializers which will able to handle all of your
remote messages. Please refer to the <a class="reference internal" href="serialization.html#serialization-scala"><em>Serialization</em></a> documentation as well as <a class="reference internal" href="#remote-bytebuffer-serialization-scala"><em>ByteBuffer based serialization</em></a> to learn how to do this.</p>
</div>
</div>
<div class="section" id="routers-with-remote-destinations">
<h2>Routers with Remote Destinations</h2>
<p>It is absolutely feasible to combine remoting with <a class="reference internal" href="routing.html#routing-scala"><em>Routing</em></a>.</p>
<p>A pool of remote deployed routees can be configured as:</p>
<div class="highlight-scala"><pre>akka.actor.deployment {
  /parent/remotePool {
    router = round-robin-pool
    nr-of-instances = 10
    target.nodes = ["tcp://app@10.0.0.2:2552", "akka://app@10.0.0.3:2552"]
  }
}
</pre>
</div>
<p>This configuration setting will clone the actor defined in the <tt class="docutils literal"><span class="pre">Props</span></tt> of the <tt class="docutils literal"><span class="pre">remotePool</span></tt> 10
times and deploy it evenly distributed across the two given target nodes.</p>
<p>A group of remote actors can be configured as:</p>
<div class="highlight-scala"><pre>akka.actor.deployment {
  /parent/remoteGroup2 {
    router = round-robin-group
    routees.paths = [
      "akka://app@10.0.0.1:2552/user/workers/w1",
      "akka://app@10.0.0.2:2552/user/workers/w1",
      "akka://app@10.0.0.3:2552/user/workers/w1"]
  }
}
</pre>
</div>
<p>This configuration setting will send messages to the defined remote actor paths.
It requires that you create the destination actors on the remote nodes with matching paths.
That is not done by the router.</p>
</div>
<div class="section" id="remoting-sample">
<span id="remote-sample-scala-artery"></span><h2>Remoting Sample</h2>
<p>There is a more extensive remote example that comes with <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a>.
The tutorial named <a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-remote-scala">Akka Remote Samples with Scala</a>
demonstrates both remote deployment and look-up of remote actors.</p>
</div>
<div class="section" id="performance-tuning">
<h2>Performance tuning</h2>
<div class="section" id="dedicated-subchannel-for-large-messages">
<h3>Dedicated subchannel for large messages</h3>
<p>All the communication between user defined remote actors are isolated from the channel of Akka internal messages so
a large user message cannot block an urgent system message. While this provides good isolation for Akka services, all
user communications by default happen through a shared network connection (an Aeron stream). When some actors
send large messages this can cause other messages to suffer higher latency as they need to wait until the full
message has been transported on the shared channel (and hence, shared bottleneck). In these cases it is usually
helpful to separate actors that have different QoS requirements: large messages vs. low latency.</p>
<p>Akka remoting provides a dedicated channel for large messages if configured. Since actor message ordering must
not be violated the channel is actually dedicated for <em>actors</em> instead of messages, to ensure all of the messages
arrive in send order. It is possible to assign actors on given paths to use this dedicated channel by using
path patterns:</p>
<div class="highlight-scala"><pre>akka.remote.artery.large-message-destinations = [
   "/user/largeMessageActor",
   "/user/largeMessagesGroup/*",
   "/user/anotherGroup/*/largeMesssages",
   "/user/thirdGroup/**",
]</pre>
</div>
<p>This means that all messages sent to the following actors will pass through the dedicated, large messages channel:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">/user/largeMessageActor</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/user/largeMessageActorGroup/actor1</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/user/largeMessageActorGroup/actor2</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/user/anotherGroup/actor1/largeMessages</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/user/anotherGroup/actor2/largeMessages</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/user/thirdGroup/actor3/</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/user/thirdGroup/actor4/actor5</span></tt></li>
</ul>
<p>Messages destined for actors not matching any of these patterns are sent using the default channel as before.</p>
</div>
<div class="section" id="external-shared-aeron-media-driver">
<h3>External, shared Aeron media driver</h3>
<p>The Aeron transport is running in a so called <a class="reference external" href="https://github.com/real-logic/Aeron/wiki/Media-Driver-Operation">media driver</a>.
By default, Akka starts the media driver embedded in the same JVM process as application. This is
convenient and simplifies operational concerns by only having one process to start and monitor.</p>
<p>The media driver may use rather much CPU resources. If you run more than one Akka application JVM on the
same machine it can therefore be wise to share the media driver by running it as a separate process.</p>
<p>The media driver has also different resource usage characteristics than a normal application and it can
therefore be more efficient and stable to run the media driver as a separate process.</p>
<p>Given that Aeron jar files are in the classpath the standalone media driver can be started with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">java</span> <span class="n">io</span><span class="o">.</span><span class="n">aeron</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="nc">MediaDriver</span>
</pre></div>
</div>
<p>The needed classpath:</p>
<div class="highlight-scala"><pre>Agrona-0.5.4.jar:aeron-driver-1.0.1.jar:aeron-client-1.0.1.jar</pre>
</div>
<p>You find those jar files on <a class="reference external" href="http://search.maven.org/">maven central</a>, or you can create a
package with your preferred build tool.</p>
<p>You can pass <a class="reference external" href="https://github.com/real-logic/Aeron/wiki/Configuration-Options">Aeron properties</a> as
command line <cite>-D</cite> system properties:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="o">-</span><span class="nc">Daeron</span><span class="o">.</span><span class="n">dir</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">shm</span><span class="o">/</span><span class="n">aeron</span>
</pre></div>
</div>
<p>You can also define Aeron properties in a file:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">java</span> <span class="n">io</span><span class="o">.</span><span class="n">aeron</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="nc">MediaDriver</span> <span class="n">config</span><span class="o">/</span><span class="n">aeron</span><span class="o">.</span><span class="n">properties</span>
</pre></div>
</div>
<p>An example of such a properties file:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">aeron</span><span class="o">.</span><span class="n">mtu</span><span class="o">.</span><span class="n">length</span><span class="k">=</span><span class="mi">16384</span>
<span class="n">aeron</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">so_sndbuf</span><span class="k">=</span><span class="mi">2097152</span>
<span class="n">aeron</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">so_rcvbuf</span><span class="k">=</span><span class="mi">2097152</span>
<span class="n">aeron</span><span class="o">.</span><span class="n">rcv</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">length</span><span class="k">=</span><span class="mi">16384</span>
<span class="n">aeron</span><span class="o">.</span><span class="n">rcv</span><span class="o">.</span><span class="n">initial</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">length</span><span class="k">=</span><span class="mi">2097152</span>
<span class="n">agrona</span><span class="o">.</span><span class="n">disable</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">checks</span><span class="k">=</span><span class="kc">true</span>

<span class="n">aeron</span><span class="o">.</span><span class="n">threading</span><span class="o">.</span><span class="n">mode</span><span class="k">=</span><span class="nc">SHARED_NETWORK</span>

<span class="k">#</span> <span class="n">low</span> <span class="n">latency</span> <span class="n">settings</span>
<span class="k">#</span><span class="n">aeron</span><span class="o">.</span><span class="n">threading</span><span class="o">.</span><span class="n">mode</span><span class="k">=</span><span class="nc">DEDICATED</span>
<span class="k">#</span><span class="n">aeron</span><span class="o">.</span><span class="n">sender</span><span class="o">.</span><span class="n">idle</span><span class="o">.</span><span class="n">strategy</span><span class="k">=</span><span class="n">org</span><span class="o">.</span><span class="n">agrona</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">BusySpinIdleStrategy</span>
<span class="k">#</span><span class="n">aeron</span><span class="o">.</span><span class="n">receiver</span><span class="o">.</span><span class="n">idle</span><span class="o">.</span><span class="n">strategy</span><span class="k">=</span><span class="n">org</span><span class="o">.</span><span class="n">agrona</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">BusySpinIdleStrategy</span>

<span class="k">#</span> <span class="n">use</span> <span class="n">same</span> <span class="n">director</span> <span class="n">in</span> <span class="n">akka</span><span class="o">.</span><span class="n">remote</span><span class="o">.</span><span class="n">artery</span><span class="o">.</span><span class="n">advanced</span><span class="o">.</span><span class="n">aeron</span><span class="o">-</span><span class="n">dir</span> <span class="n">config</span>
<span class="k">#</span> <span class="n">of</span> <span class="n">the</span> <span class="nc">Akka</span> <span class="n">application</span>
<span class="n">aeron</span><span class="o">.</span><span class="n">dir</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">shm</span><span class="o">/</span><span class="n">aeron</span>
</pre></div>
</div>
<p>Read more about the media driver in the <a class="reference external" href="https://github.com/real-logic/Aeron/wiki/Media-Driver-Operation">Aeron documentation</a>.</p>
<p>To use the external media driver from the Akka application you need to define the following two
configuration properties:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">remote</span><span class="o">.</span><span class="n">artery</span><span class="o">.</span><span class="n">advanced</span> <span class="o">{</span>
  <span class="n">embedded</span><span class="o">-</span><span class="n">media</span><span class="o">-</span><span class="n">driver</span> <span class="k">=</span> <span class="n">off</span>
  <span class="n">aeron</span><span class="o">-</span><span class="n">dir</span> <span class="k">=</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">shm</span><span class="o">/</span><span class="n">aeron</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">aeron-dir</span></tt> must match the directory you started the media driver with, i.e. the <tt class="docutils literal"><span class="pre">aeron.dir</span></tt> property.</p>
<p>Several Akka applications can then be configured to use the same media driver by pointing to the
same directory.</p>
<p>Note that if the media driver process is stopped the Akka applications that are using it will also be stopped.</p>
</div>
<div class="section" id="aeron-tuning">
<h3>Aeron Tuning</h3>
<p>See Aeron documentation about <a class="reference external" href="https://github.com/real-logic/Aeron/wiki/Performance-Testing">Performance Testing</a>.</p>
</div>
<div class="section" id="fine-tuning-cpu-usage-latency-tradeoff">
<h3>Fine-tuning CPU usage latency tradeoff</h3>
<p>Artery has been designed for low latency and as a result it can be CPU hungry when the system is mostly idle.
This is not always desirable. It is possible to tune the tradeoff between CPU usage and latency with
the following configuration:</p>
<blockquote>
<div># Values can be from 1 to 10, where 10 strongly prefers low latency
# and 1 strongly prefers less CPU usage
akka.remote.artery.advanced.idle-cpu-level = 1</div></blockquote>
<p>By setting this value to a lower number, it tells Akka to do longer &quot;sleeping&quot; periods on its thread dedicated
for <a class="reference external" href="https://en.wikipedia.org/wiki/Busy_waiting">spin-waiting</a> and hence reducing CPU load when there is no
immediate task to execute at the cost of a longer reaction time to an event when it actually happens. It is worth
to be noted though that during a continuously high-throughput period this setting makes not much difference
as the thread mostly has tasks to execute. This also means that under high throughput (but below maximum capacity)
the system might have less latency than at low message rates.</p>
</div>
</div>
<div class="section" id="internal-event-log-for-debugging-flight-recorder">
<h2>Internal Event Log for Debugging (Flight Recorder)</h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this version (2.4.11) the flight-recorder is disabled by default because there is no automatic
file name and path calculation implemented to make it possible to reuse the same file for every restart of
the same actor system without clashing with files produced by other systems (possibly running on the same machine).
Currently, you have to set the path and file names yourself to avoid creating an unbounded number
of files and enable flight recorder manually by adding <cite>akka.remote.artery.advanced.flight-recorder.enabled=on</cite> to
your configuration file. This a limitation of the current version and will not be necessary in the future.</p>
</div>
<p>Emitting event information (logs) from internals is always a tradeoff. The events that are usable for
the Akka developers are usually too low level to be of any use for users and usually need to be fine-grained enough
to provide enough information to be able to debug issues in the internal implementation. This usually means that
these logs are hidden behind special flags and emitted at low log levels to not clutter the log output of the user
system. Unfortunately this means that during production or integration testing these flags are usually off and
events are not available when an actual failure happens - leaving maintainers in the dark about details of the event.
To solve this contradiction, remoting has an internal, high-performance event store for debug events which is always on.
This log and the events that it contains are highly specialized and not directly exposed to users, their primary purpose
is to help the maintainers of Akka to identify and solve issues discovered during daily usage. When you encounter
production issues involving remoting, you can include the flight recorder log file in your bug report to give us
more insight into the nature of the failure.</p>
<p>There are various important features of this event log:</p>
<ul class="simple">
<li>Flight Recorder produces a fixed size file completely encapsulating log rotation. This means that this
file will never grow in size and will not cause any unexpected disk space shortage in production.</li>
<li>This file is crash resistant, i.e. its contents can be recovered even if the JVM hosting the <tt class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></tt>
crashes unexpectedly.</li>
<li>Very low overhead, specialized, binary logging that has no significant overhead and can be safely left enabled
for production systems.</li>
</ul>
<p>The location of the file can be controlled via the <cite>akka.remote.artery.advanced.flight-recoder.destination</cite> setting (see
<a class="reference internal" href="../general/configuration.html#config-akka-remote-artery"><em>akka-remote (artery)</em></a> for details). By default, a file with the <cite>.afr</cite> extension is produced in the temporary
directory of the operating system. In cases where the flight recorder casuses issues, it can be disabled by adding the
setting <cite>akka.remote.artery.advanced.flight-recorder.enabled=off</cite>, although this is not recommended.</p>
</div>
<div class="section" id="remote-configuration">
<span id="remote-configuration-artery-scala"></span><h2>Remote Configuration</h2>
<p>There are lots of configuration properties that are related to remoting in Akka. We refer to the
<a class="reference internal" href="../general/configuration.html#config-akka-remote-artery"><em>reference configuration</em></a> for more information.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Setting properties like the listening IP and port number programmatically is
best done by using something like the following:</p>
<div class="last highlight-scala"><div class="highlight"><pre><span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;akka.remote.artery.canonical.hostname=\&quot;1.2.3.4\&quot;&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withFallback</span><span class="o">(</span><span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">());</span>
</pre></div>
</div>
</div>
<div class="section" id="akka-behind-nat-or-in-a-docker-container">
<span id="remote-configuration-nat-artery-scala"></span><h3>Akka behind NAT or in a Docker container</h3>
<p>In setups involving Network Address Translation (NAT), Load Balancers or Docker
containers the hostname and port pair that Akka binds to will be different than the &quot;logical&quot;
host name and port pair that is used to connect to the system from the outside. This requires
special configuration that sets both the logical and the bind pairs for remoting.</p>
<div class="highlight-ruby"><div class="highlight"><pre><span class="n">akka</span> <span class="p">{</span>
  <span class="n">remote</span> <span class="p">{</span>
    <span class="n">artery</span> <span class="p">{</span>
      <span class="n">canonical</span><span class="o">.</span><span class="n">hostname</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">com</span>      <span class="c1"># external (logical) hostname</span>
      <span class="n">canonical</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">8000</span>                   <span class="c1"># external (logical) port</span>

      <span class="n">bind</span><span class="o">.</span><span class="n">hostname</span> <span class="o">=</span> <span class="n">local</span><span class="o">.</span><span class="n">address</span> <span class="c1"># internal (bind) hostname</span>
      <span class="n">bind</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">25520</span>              <span class="c1"># internal (bind) port</span>
    <span class="p">}</span>
 <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>