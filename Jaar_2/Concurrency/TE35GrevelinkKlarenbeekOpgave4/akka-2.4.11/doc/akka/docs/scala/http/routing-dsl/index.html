


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>High-level Server-Side API &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/toc.js"></script>
    <script type="text/javascript" src="../../../_static/prettify.js"></script>
    <script type="text/javascript" src="../../../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../../../_static/effects.core.js"></script>
    <script type="text/javascript" src="../../../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../../../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../../../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../../../_static/ga.js"></script>
    <script type="text/javascript" src="../../../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../../../index.html" />
    <link rel="up" title="Akka HTTP" href="../index.html" />
    <link rel="next" title="Routing DSL Overview" href="overview.html" />
    <link rel="prev" title="Low-Level Server-Side API" href="../low-level-server-side-api.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../../../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">High-level Server-Side API</div>
      <div class="pdf-link"><a href="../../../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../../../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../../../AkkaJava.pdf" title="Akka Java Documentation"><img src="../../../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="overview.html">Routing DSL Overview</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../../../java.html">Java Contents</a> <span class="divider">|</span> <a href="../../../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="../low-level-server-side-api.html">Low-Level Server-Side API</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="high-level-server-side-api">
<span id="http-high-level-server-side-api"></span><h1>High-level Server-Side API</h1>
<p>In addition to the <a class="reference internal" href="../low-level-server-side-api.html#http-low-level-server-side-api"><em>Low-Level Server-Side API</em></a> Akka HTTP provides a very flexible &quot;Routing DSL&quot; for elegantly
defining RESTful web services. It picks up where the low-level API leaves off and offers much of the higher-level
functionality of typical web servers or frameworks, like deconstruction of URIs, content negotiation or
static content serving.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is recommended to read the <a class="reference internal" href="../implications-of-streaming-http-entity.html#implications-of-streaming-http-entities"><em>Implications of the streaming nature of Request/Response Entities</em></a> section,
as it explains the underlying full-stack streaming concepts, which may be unexpected when coming
from a background with non-&quot;streaming first&quot; HTTP Servers.</p>
</div>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Routing DSL Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="routes.html">Routes</a></li>
<li class="toctree-l1"><a class="reference internal" href="directives/index.html">Directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="rejections.html">Rejections</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception-handling.html">Exception Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="path-matchers.html">The PathMatcher DSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="case-class-extraction.html">Case Class Extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="source-streaming-support.html">Source Streaming</a></li>
<li class="toctree-l1"><a class="reference internal" href="source-streaming-support.html#json-streaming">JSON Streaming</a></li>
<li class="toctree-l1"><a class="reference internal" href="testkit.html">Route TestKit</a></li>
<li class="toctree-l1"><a class="reference internal" href="websocket-support.html">Server-Side WebSocket Support</a></li>
</ul>
</div>
<div class="section" id="minimal-example">
<h2>Minimal Example</h2>
<p>This is a complete, very basic Akka HTTP application relying on the Routing DSL:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.model._</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.server.Directives._</span>
<span class="k">import</span> <span class="nn">akka.stream.ActorMaterializer</span>
<span class="k">import</span> <span class="nn">scala.io.StdIn</span>

<span class="k">object</span> <span class="nc">WebServer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;my-system&quot;</span><span class="o">)</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
    <span class="c1">// needed for the future flatMap/onComplete in the end</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">executionContext</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span>

    <span class="k">val</span> <span class="n">route</span> <span class="k">=</span>
      <span class="n">path</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">get</span> <span class="o">{</span>
          <span class="n">complete</span><span class="o">(</span><span class="nc">HttpEntity</span><span class="o">(</span><span class="nc">ContentTypes</span><span class="o">.</span><span class="n">`text/html(UTF-8)`</span><span class="o">,</span> <span class="s">&quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;</span><span class="o">))</span>
        <span class="o">}</span>
      <span class="o">}</span>

    <span class="k">val</span> <span class="n">bindingFuture</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">().</span><span class="n">bindAndHandle</span><span class="o">(</span><span class="n">route</span><span class="o">,</span> <span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">8080</span><span class="o">)</span>

    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;</span><span class="o">)</span>
    <span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span> <span class="c1">// let it run until user presses return</span>
    <span class="n">bindingFuture</span>
      <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">unbind</span><span class="o">())</span> <span class="c1">// trigger unbinding from the port</span>
      <span class="o">.</span><span class="n">onComplete</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">system</span><span class="o">.</span><span class="n">terminate</span><span class="o">())</span> <span class="c1">// and shutdown when done</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It starts an HTTP Server on localhost and replies to GET requests to <tt class="docutils literal"><span class="pre">/hello</span></tt> with a simple response.</p>
</div>
<div class="section" id="longer-example">
<span id="long-example"></span><h2>Longer Example</h2>
<p>The following is an Akka HTTP route definition that tries to show off a few features. The resulting service does
not really do anything useful but its definition should give you a feel for what an actual API definition with
the Routing DSL will look like:</p>
<div class="highlight-scala"><pre>import akka.actor.{ActorRef, ActorSystem}
import akka.http.scaladsl.coding.Deflate
import akka.http.scaladsl.marshalling.ToResponseMarshaller
import akka.http.scaladsl.model.StatusCodes.MovedPermanently
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.unmarshalling.FromRequestUnmarshaller
import akka.pattern.ask
import akka.stream.ActorMaterializer
import akka.util.Timeout

// types used by the API routes
type Money = Double // only for demo purposes, don't try this at home!
type TransactionResult = String
case class User(name: String)
case class Order(email: String, amount: Money)
case class Update(order: Order)
case class OrderItem(i: Int, os: Option[String], s: String)

// marshalling would usually be derived automatically using libraries
implicit val orderUM: FromRequestUnmarshaller[Order] = ???
implicit val orderM: ToResponseMarshaller[Order] = ???
implicit val orderSeqM: ToResponseMarshaller[Seq[Order]] = ???
implicit val timeout: Timeout = ??? // for actor asks
implicit val ec: ExecutionContext = ???
implicit val mat: ActorMaterializer = ???
implicit val sys: ActorSystem = ???

// backend entry points
def myAuthenticator: Authenticator[User] = ???
def retrieveOrdersFromDB: Seq[Order] = ???
def myDbActor: ActorRef = ???
def processOrderRequest(id: Int, complete: Order =&gt; Unit): Unit = ???

val route = {
  path("orders") {
    authenticateBasic(realm = "admin area", myAuthenticator) { user =&gt;
      get {
        encodeResponseWith(Deflate) {
          complete {
            // marshal custom object with in-scope marshaller
            retrieveOrdersFromDB
          }
        }
      } ~
      post {
        // decompress gzipped or deflated requests if required
        decodeRequest {
          // unmarshal with in-scope unmarshaller
          entity(as[Order]) { order =&gt;
            complete {
              // ... write order to DB
              "Order received"
            }
          }
        }
      }
    }
  } ~
  // extract URI path element as Int
  pathPrefix("order" / IntNumber) { orderId =&gt;
    pathEnd {
      (put | parameter('method ! "put")) {
        // form extraction from multipart or www-url-encoded forms
        formFields(('email, 'total.as[Money])).as(Order) { order =&gt;
          complete {
            // complete with serialized Future result
            (myDbActor ? Update(order)).mapTo[TransactionResult]
          }
        }
      } ~
      get {
        // debugging helper
        logRequest("GET-ORDER") {
          // use in-scope marshaller to create completer function
          completeWith(instanceOf[Order]) { completer =&gt;
            // custom
            processOrderRequest(orderId, completer)
          }
        }
      }
    } ~
    path("items") {
      get {
        // parameters to case class extraction
        parameters(('size.as[Int], 'color ?, 'dangerous ? "no"))
          .as(OrderItem) { orderItem =&gt;
            // ... route using case class instance created from
            // required and optional query parameters
          }
      }
    }
  } ~
  pathPrefix("documentation") {
    // optionally compresses the response with Gzip or Deflate
    // if the client accepts compressed responses
    encodeResponse {
      // serve up static content from a JAR resource
      getFromResourceDirectory("docs")
    }
  } ~
  path("oldApi" / Remaining) { pathRest =&gt;
    redirect("http://oldapi.example.com/" + pathRest, MovedPermanently)
  }
}


tream random numbers" in compileOnlySpec {
</pre>
</div>
</div>
<div class="section" id="handling-http-server-failures-in-the-high-level-api">
<span id="handling-http-server-failures-high-level-scala"></span><h2>Handling HTTP Server failures in the High-Level API</h2>
<p>There are various situations when failure may occur while initialising or running an Akka HTTP server.
Akka by default will log all these failures, however sometimes one may want to react to failures in addition
to them just being logged, for example by shutting down the actor system, or notifying some external monitoring
end-point explicitly.</p>
<div class="section" id="bind-failures">
<h3>Bind failures</h3>
<p>For example the server might be unable to bind to the given port. For example when the port
is already taken by another application, or if the port is privileged (i.e. only usable by <tt class="docutils literal"><span class="pre">root</span></tt>).
In this case the &quot;binding future&quot; will fail immediately, and we can react to if by listening on the Future's completion:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.Http.ServerBinding</span>
<span class="k">import</span> <span class="nn">akka.http.scaladsl.server.Directives._</span>
<span class="k">import</span> <span class="nn">akka.stream.ActorMaterializer</span>

<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">object</span> <span class="nc">WebServer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
    <span class="c1">// needed for the future onFailure in the end</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">executionContext</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span>

    <span class="k">val</span> <span class="n">handler</span> <span class="k">=</span> <span class="n">get</span> <span class="o">{</span>
      <span class="n">complete</span><span class="o">(</span><span class="s">&quot;Hello world!&quot;</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">// let&#39;s say the OS won&#39;t allow us to bind to 80.</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">80</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">bindingFuture</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">ServerBinding</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Http</span><span class="o">().</span><span class="n">bindAndHandle</span><span class="o">(</span><span class="n">handler</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span>

    <span class="n">bindingFuture</span><span class="o">.</span><span class="n">onFailure</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="n">ex</span><span class="o">,</span> <span class="s">&quot;Failed to bind to {}:{}!&quot;</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a more low-level overview of the kinds of failures that can happen and also more fine-grained control over them
refer to the <a class="reference internal" href="../low-level-server-side-api.html#handling-http-server-failures-low-level-scala"><em>Handling HTTP Server failures in the Low-Level API</em></a> documentation.</p>
</div>
</div>
<div class="section" id="failures-and-exceptions-inside-the-routing-dsl">
<h3>Failures and exceptions inside the Routing DSL</h3>
<p>Exception handling within the Routing DSL is done by providing <tt class="xref py py-class docutils literal"><span class="pre">ExceptionHandler</span></tt> s which are documented in-depth
in the <a class="reference internal" href="exception-handling.html#exception-handling-scala"><em>Exception Handling</em></a> section of the documtnation. You can use them to transform exceptions into
<tt class="xref py py-class docutils literal"><span class="pre">HttpResponse</span></tt> s with apropriate error codes and human-readable failure descriptions.</p>
</div>
<div class="section" id="file-uploads">
<h3>File uploads</h3>
<p>For high level directives to handle uploads see the <a class="reference internal" href="directives/file-upload-directives/index.html#fileuploaddirectives"><em>FileUploadDirectives</em></a>.</p>
<p>Handling a simple file upload from for example a browser form with a <cite>file</cite> input can be done
by accepting a <cite>Multipart.FormData</cite> entity, note that the body parts are <cite>Source</cite> rather than
all available right away, and so is the individual body part payload so you will need to consume
those streams both for the file and for the form fields.</p>
<p>Here is a simple example which just dumps the uploaded file into a temporary file on disk, collects
some form fields and saves an entry to a fictive database:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">uploadVideo</span> <span class="k">=</span>
  <span class="n">path</span><span class="o">(</span><span class="s">&quot;video&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">entity</span><span class="o">(</span><span class="n">as</span><span class="o">[</span><span class="kt">Multipart.FormData</span><span class="o">])</span> <span class="o">{</span> <span class="n">formData</span> <span class="k">=&gt;</span>

      <span class="c1">// collect all parts of the multipart as it arrives into a map</span>
      <span class="k">val</span> <span class="n">allPartsF</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="n">formData</span><span class="o">.</span><span class="n">parts</span><span class="o">.</span><span class="n">mapAsync</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">)](</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">case</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BodyPart</span> <span class="kt">if</span> <span class="kt">b.name</span> <span class="o">=</span><span class="k">=</span> <span class="s">&quot;file&quot;</span> <span class="k">=&gt;</span>
          <span class="c1">// stream into a file as the chunks of it arrives and return a future</span>
          <span class="c1">// file to where it got stored</span>
          <span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="nc">File</span><span class="o">.</span><span class="n">createTempFile</span><span class="o">(</span><span class="s">&quot;upload&quot;</span><span class="o">,</span> <span class="s">&quot;tmp&quot;</span><span class="o">)</span>
          <span class="n">b</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">dataBytes</span><span class="o">.</span><span class="n">runWith</span><span class="o">(</span><span class="nc">FileIO</span><span class="o">.</span><span class="n">toPath</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">toPath</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span>
            <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">file</span><span class="o">))</span>

        <span class="k">case</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BodyPart</span> <span class="o">=&gt;</span>
          <span class="c1">// collect form field values</span>
          <span class="n">b</span><span class="o">.</span><span class="n">toStrict</span><span class="o">(</span><span class="mf">2.</span><span class="n">seconds</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">strict</span> <span class="k">=&gt;</span>
            <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">strict</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">utf8String</span><span class="o">))</span>

      <span class="o">}.</span><span class="n">runFold</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">])((</span><span class="n">map</span><span class="o">,</span> <span class="n">tuple</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">map</span> <span class="o">+</span> <span class="n">tuple</span><span class="o">)</span>

      <span class="k">val</span> <span class="n">done</span> <span class="k">=</span> <span class="n">allPartsF</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">allParts</span> <span class="k">=&gt;</span>
        <span class="c1">// You would have some better validation/unmarshalling here</span>
        <span class="n">db</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">Video</span><span class="o">(</span>
          <span class="n">file</span> <span class="k">=</span> <span class="n">allParts</span><span class="o">(</span><span class="s">&quot;file&quot;</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">File</span><span class="o">],</span>
          <span class="n">title</span> <span class="k">=</span> <span class="n">allParts</span><span class="o">(</span><span class="s">&quot;title&quot;</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
          <span class="n">author</span> <span class="k">=</span> <span class="n">allParts</span><span class="o">(</span><span class="s">&quot;author&quot;</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]))</span>
      <span class="o">}</span>

      <span class="c1">// when processing have finished create a response for the user</span>
      <span class="n">onSuccess</span><span class="o">(</span><span class="n">allPartsF</span><span class="o">)</span> <span class="o">{</span> <span class="n">allParts</span> <span class="k">=&gt;</span>
        <span class="n">complete</span> <span class="o">{</span>
          <span class="s">&quot;ok!&quot;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>You can transform the uploaded files as they arrive rather than storing then in a temporary file as
in the previous example. In this example we accept any number of <tt class="docutils literal"><span class="pre">.csv</span></tt> files, parse those into lines
and split each line before we send it to an actor for further processing:</p>
<div class="highlight-scala"><pre>val splitLines = Framing.delimiter(ByteString("\n"), 256)

val csvUploads =
  path("metadata" / LongNumber) { id =&gt;
    entity(as[Multipart.FormData]) { formData =&gt;
      val done: Future[Done] = formData.parts.mapAsync(1) {
        case b: BodyPart if b.filename.exists(_.endsWith(".csv")) =&gt;
          b.entity.dataBytes
            .via(splitLines)
            .map(_.utf8String.split(",").toVector)
            .runForeach(csv =&gt;
              metadataActor ! MetadataActor.Entry(id, csv))
        case _ =&gt; Future.successful(Done)
      }.runWith(Sink.ignore)

      // when processing have finished create a response for the user
      onSuccess(done) { _ =&gt;
        complete {
          "ok!"
        }
      }
    }
  }
</pre>
</div>
</div>
</div>
<div class="section" id="configuring-server-side-https">
<h2>Configuring Server-side HTTPS</h2>
<p>For detailed documentation about configuring and using HTTPS on the server-side refer to <a class="reference internal" href="../server-side-https-support.html#serversidehttps-scala"><em>Server-Side HTTPS Support</em></a>.</p>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../../../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>