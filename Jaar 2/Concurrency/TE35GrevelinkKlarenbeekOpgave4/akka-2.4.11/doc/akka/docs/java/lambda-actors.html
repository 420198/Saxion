


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Actors (Java with Lambda Support) &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Experimental Modules" href="../experimental/index.html" />
    <link rel="next" title="FSM (Java with Lambda Support)" href="lambda-fsm.html" />
    <link rel="prev" title="Multi Node Testing" href="../dev/multi-node-testing.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Actors (Java with Lambda Support)</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="lambda-fsm.html">FSM (Java with Lambda Support)</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="../dev/multi-node-testing.html">Multi Node Testing</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="actors-java-with-lambda-support">
<span id="lambda-actors-java"></span><h1>Actors (Java with Lambda Support)</h1>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a> provides a higher level of abstraction for writing concurrent
and distributed systems. It alleviates the developer from having to deal with
explicit locking and thread management, making it easier to write correct
concurrent and parallel systems. Actors were defined in the 1973 paper by Carl
Hewitt but have been popularized by the Erlang language, and used for example at
Ericsson with great success to build highly concurrent and reliable telecom
systems.</p>
<p>The API of Akka’s Actors is similar to Scala Actors which has borrowed some of
its syntax from Erlang.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The Java with lambda support part of Akka is marked as <strong>“experimental”</strong> as of its introduction in
Akka 2.3.0. We will continue to improve this API based on our users’ feedback, which implies that
while we try to keep incompatible changes to a minimum, but the binary compatibility guarantee for
maintenance releases does not apply to the <tt class="xref py py-class docutils literal"><span class="pre">akka.actor.AbstractActor</span></tt>, related classes and
the <tt class="xref py py-class docutils literal"><span class="pre">akka.japi.pf</span></tt> package.</p>
</div>
<div class="section" id="creating-actors">
<h2>Creating Actors</h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since Akka enforces parental supervision every actor is supervised and
(potentially) the supervisor of its children, it is advisable that you
familiarize yourself with <a class="reference internal" href="../general/actor-systems.html#actor-systems"><em>Actor Systems</em></a> and <a class="reference internal" href="../general/supervision.html#supervision"><em>Supervision and Monitoring</em></a> and it
may also help to read <a class="reference internal" href="../general/addressing.html#addressing"><em>Actor References, Paths and Addresses</em></a>.</p>
</div>
<div class="section" id="defining-an-actor-class">
<h3>Defining an Actor class</h3>
<p>Actor classes are implemented by extending the <tt class="xref py py-class docutils literal"><span class="pre">AbstractActor</span></tt> class and setting
the “initial behavior” in the constructor by calling the <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> method in
the <tt class="xref py py-class docutils literal"><span class="pre">AbstractActor</span></tt>.</p>
<p>The argument to the <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> method is a <tt class="docutils literal"><span class="pre">PartialFunction&lt;Object,BoxedUnit&gt;</span></tt>
that defines which messages your Actor can handle, along with the implementation of
how the messages should be processed.</p>
<p>Don't let the type signature scare you. To allow you to easily build up a partial
function there is a builder named <tt class="docutils literal"><span class="pre">ReceiveBuilder</span></tt> that you can use.</p>
<p>Here is an example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.AbstractActor</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.event.Logging</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.event.LoggingAdapter</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.japi.pf.ReceiveBuilder</span><span class="o">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">LoggingAdapter</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="n">context</span><span class="o">().</span><span class="n">system</span><span class="o">(),</span> <span class="k">this</span><span class="o">);</span>

  <span class="n">public</span> <span class="nc">MyActor</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Received String message: {}&quot;</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
      <span class="o">}).</span>
      <span class="n">matchAny</span><span class="o">(</span><span class="n">o</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;received unknown message&quot;</span><span class="o">)).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Please note that the Akka Actor <tt class="docutils literal"><span class="pre">receive</span></tt> message loop is exhaustive, which
is different compared to Erlang and the late Scala Actors. This means that you
need to provide a pattern match for all messages that it can accept and if you
want to be able to handle unknown messages then you need to have a default case
as in the example above. Otherwise an <tt class="docutils literal"><span class="pre">akka.actor.UnhandledMessage(message,</span>
<span class="pre">sender,</span> <span class="pre">recipient)</span></tt> will be published to the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt>'s
<tt class="docutils literal"><span class="pre">EventStream</span></tt>.</p>
<p>Note further that the return type of the behavior defined above is <tt class="docutils literal"><span class="pre">Unit</span></tt>; if
the actor shall reply to the received message then this must be done explicitly
as explained below.</p>
<p>The argument to the <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> method is a partial function object, which is
stored within the actor as its “initial behavior”, see <a class="reference internal" href="#become-unbecome">Become/Unbecome</a> for
further information on changing the behavior of an actor after its
construction.</p>
</div>
<div class="section" id="props">
<h3>Props</h3>
<p><tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> is a configuration class to specify options for the creation
of actors, think of it as an immutable and thus freely shareable recipe for
creating an actor including associated deployment information (e.g. which
dispatcher to use, see more below). Here are some examples of how to create a
<tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> instance.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Props</span><span class="o">;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Props</span> <span class="n">props1</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">MyActor</span><span class="o">.</span><span class="n">class</span><span class="o">);</span>
<span class="nc">Props</span> <span class="n">props2</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">ActorWithArgs</span><span class="o">.</span><span class="n">class</span><span class="o">,</span>
  <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ActorWithArgs</span><span class="o">(</span><span class="s">&quot;arg&quot;</span><span class="o">));</span> <span class="c1">// careful, see below</span>
<span class="nc">Props</span> <span class="n">props3</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">ActorWithArgs</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="s">&quot;arg&quot;</span><span class="o">);</span>
</pre></div>
</div>
<p>The second variant shows how to pass constructor arguments to the
<tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> being created, but it should only be used outside of actors as
explained below.</p>
<p>The last line shows a possibility to pass constructor arguments regardless of
the context it is being used in. The presence of a matching constructor is
verified during construction of the <tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> object, resulting in an
<tt class="xref py py-class docutils literal"><span class="pre">IllegalArgumentException</span></tt> if no or multiple matching constructors are
found.</p>
<div class="section" id="dangerous-variants">
<h4>Dangerous Variants</h4>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// NOT RECOMMENDED within another actor:</span>
<span class="c1">// encourages to close over enclosing class</span>
<span class="nc">Props</span> <span class="n">props7</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">ActorWithArgs</span><span class="o">.</span><span class="n">class</span><span class="o">,</span>
  <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ActorWithArgs</span><span class="o">(</span><span class="s">&quot;arg&quot;</span><span class="o">));</span>
</pre></div>
</div>
<p>This method is not recommended to be used within another actor because it
encourages to close over the enclosing scope, resulting in non-serializable
<tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> and possibly race conditions (breaking the actor encapsulation).
On the other hand using this variant in a <tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> factory in the actor’s
companion object as documented under “Recommended Practices” below is completely
fine.</p>
<p>There were two use-cases for these methods: passing constructor arguments to
the actor—which is solved by the newly introduced
<tt class="xref py py-meth docutils literal"><span class="pre">Props.create(clazz,&nbsp;args)</span></tt> method above or the recommended practice
below—and creating actors “on the spot” as anonymous classes. The latter should
be solved by making these actors named classes instead (if they are not
declared within a top-level <tt class="docutils literal"><span class="pre">object</span></tt> then the enclosing instance’s <tt class="docutils literal"><span class="pre">this</span></tt>
reference needs to be passed as the first argument).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Declaring one actor within another is very dangerous and breaks actor
encapsulation. Never pass an actor’s <tt class="docutils literal"><span class="pre">this</span></tt> reference into <tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt>!</p>
</div>
</div>
<div class="section" id="recommended-practices">
<h4>Recommended Practices</h4>
<p>It is a good idea to provide factory methods on the companion object of each
<tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> which help keeping the creation of suitable <tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> as
close to the actor definition as possible. This also avoids the pitfalls
associated with using the <tt class="docutils literal"><span class="pre">Props.create(...)</span></tt> method which takes a by-name
argument, since within a companion object the given code block will not retain
a reference to its enclosing scope:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">DemoActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Create Props for an actor of this type.</span>
<span class="cm">   * @param magicNumber The magic number to be passed to this actor’s constructor.</span>
<span class="cm">   * @return a Props for creating this actor, which can then be further configured</span>
<span class="cm">   *         (e.g. calling `.withDispatcher()` on it)</span>
<span class="cm">   */</span>
  <span class="n">static</span> <span class="nc">Props</span> <span class="n">props</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">magicNumber</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// You need to specify the actual type of the returned actor</span>
    <span class="c1">// since Java 8 lambdas have some runtime type information erased</span>
    <span class="k">return</span> <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">DemoActor</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">DemoActor</span><span class="o">(</span><span class="n">magicNumber</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">Integer</span> <span class="n">magicNumber</span><span class="o">;</span>

  <span class="nc">DemoActor</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">magicNumber</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">magicNumber</span> <span class="k">=</span> <span class="n">magicNumber</span><span class="o">;</span>
    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">magicNumber</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">SomeOtherActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="c1">// Props(new DemoActor(42)) would not be safe</span>
  <span class="nc">ActorRef</span> <span class="n">demoActor</span> <span class="k">=</span> <span class="n">context</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">DemoActor</span><span class="o">.</span><span class="n">props</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="s">&quot;demo&quot;</span><span class="o">);</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Another good practice is to declare what messages an Actor can receive
as close to the actor definition as possible (e.g. as static classes
inside the Actor or using other suitable class), which makes it easier to know
what it can receive.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">DemoMessagesActor</span> <span class="k">extends</span> <span class="nc">AbstractLoggingActor</span> <span class="o">{</span>

  <span class="n">static</span> <span class="n">public</span> <span class="k">class</span> <span class="nc">Greeting</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">final</span> <span class="nc">String</span> <span class="n">from</span><span class="o">;</span>

    <span class="n">public</span> <span class="nc">Greeting</span><span class="o">(</span><span class="nc">String</span> <span class="n">from</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="n">from</span> <span class="k">=</span> <span class="n">from</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="nc">String</span> <span class="n">getGreeter</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">from</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nc">DemoMessagesActor</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">Greeting</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">g</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">().</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;I was greeted by {}&quot;</span><span class="o">,</span> <span class="n">g</span><span class="o">.</span><span class="n">getGreeter</span><span class="o">());</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">};</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="creating-actors-with-props">
<h3>Creating Actors with Props</h3>
<p>Actors are created by passing a <tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> instance into the
<tt class="xref py py-meth docutils literal"><span class="pre">actorOf</span></tt> factory method which is available on <tt class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></tt> and
<tt class="xref py py-class docutils literal"><span class="pre">ActorContext</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorRef</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span><span class="o">;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// ActorSystem is a heavy object: create only one per application</span>
<span class="k">final</span> <span class="nc">ActorSystem</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;MySystem&quot;</span><span class="o">,</span> <span class="n">config</span><span class="o">);</span>
<span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">MyActor</span><span class="o">.</span><span class="n">class</span><span class="o">),</span> <span class="s">&quot;myactor&quot;</span><span class="o">);</span>
</pre></div>
</div>
<p>Using the <tt class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></tt> will create top-level actors, supervised by the
actor system’s provided guardian actor, while using an actor’s context will
create a child actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">FirstActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">child</span> <span class="k">=</span> <span class="n">context</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">MyActor</span><span class="o">.</span><span class="n">class</span><span class="o">),</span> <span class="s">&quot;myChild&quot;</span><span class="o">);</span>
  <span class="c1">// plus some behavior ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It is recommended to create a hierarchy of children, grand-children and so on
such that it fits the logical failure-handling structure of the application,
see <a class="reference internal" href="../general/actor-systems.html#actor-systems"><em>Actor Systems</em></a>.</p>
<p>The call to <tt class="xref py py-meth docutils literal"><span class="pre">actorOf</span></tt> returns an instance of <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>. This is a
handle to the actor instance and the only way to interact with it. The
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> is immutable and has a one to one relationship with the Actor
it represents. The <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> is also serializable and network-aware.
This means that you can serialize it, send it over the wire and use it on a
remote host and it will still be representing the same Actor on the original
node, across the network.</p>
<p>The name parameter is optional, but you should preferably name your actors,
since that is used in log messages and for identifying actors. The name must
not be empty or start with <tt class="docutils literal"><span class="pre">$</span></tt>, but it may contain URL encoded characters
(eg. <tt class="docutils literal"><span class="pre">%20</span></tt> for a blank space).  If the given name is already in use by
another child to the same parent an <cite>InvalidActorNameException</cite> is thrown.</p>
<p>Actors are automatically started asynchronously when created.</p>
</div>
<div class="section" id="dependency-injection">
<span id="actor-create-factory-lambda"></span><h3>Dependency Injection</h3>
<p>If your UntypedActor has a constructor that takes parameters then those need to
be part of the <tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> as well, as described <a class="reference internal" href="#props">above</a>. But there
are cases when a factory method must be used, for example when the actual
constructor arguments are determined by a dependency injection framework.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.IndirectActorProducer</span><span class="o">;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DependencyInjector</span> <span class="n">implements</span> <span class="nc">IndirectActorProducer</span> <span class="o">{</span>
  <span class="k">final</span> <span class="nc">Object</span> <span class="n">applicationContext</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">;</span>
  
  <span class="n">public</span> <span class="nc">DependencyInjector</span><span class="o">(</span><span class="nc">Object</span> <span class="n">applicationContext</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">applicationContext</span> <span class="k">=</span> <span class="n">applicationContext</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">beanName</span> <span class="k">=</span> <span class="n">beanName</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="k">extends</span> <span class="nc">Actor</span><span class="o">&gt;</span> <span class="n">actorClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">MyActor</span><span class="o">.</span><span class="n">class</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">MyActor</span> <span class="n">produce</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">MyActor</span> <span class="n">result</span><span class="o">;</span>
    <span class="c1">// obtain fresh Actor instance from DI framework ...</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
  
  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">getContext</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span>
    <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">DependencyInjector</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">applicationContext</span><span class="o">,</span> <span class="s">&quot;MyActor&quot;</span><span class="o">),</span>
      <span class="s">&quot;myactor3&quot;</span><span class="o">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>You might be tempted at times to offer an <tt class="xref py py-class docutils literal"><span class="pre">IndirectActorProducer</span></tt>
which always returns the same instance, e.g. by using a static field. This is
not supported, as it goes against the meaning of an actor restart, which is
described here: <a class="reference internal" href="../general/supervision.html#supervision-restart"><em>What Restarting Means</em></a>.</p>
<p class="last">When using a dependency injection framework, actor beans <em>MUST NOT</em> have
singleton scope.</p>
</div>
<p>Techniques for dependency injection and integration with dependency injection frameworks
are described in more depth in the
<a class="reference external" href="http://letitcrash.com/post/55958814293/akka-dependency-injection">Using Akka with Dependency Injection</a>
guideline and the <a class="reference external" href="http://www.lightbend.com/activator/template/akka-java-spring">Akka Java Spring</a> tutorial
in Lightbend Activator.</p>
</div>
<div class="section" id="the-inbox">
<h3>The Inbox</h3>
<p>When writing code outside of actors which shall communicate with actors, the
<tt class="docutils literal"><span class="pre">ask</span></tt> pattern can be a solution (see below), but there are two things it
cannot do: receiving multiple replies (e.g. by subscribing an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>
to a notification service) and watching other actors’ lifecycle. For these
purposes there is the <tt class="xref py py-class docutils literal"><span class="pre">Inbox</span></tt> class:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Inbox</span> <span class="n">inbox</span> <span class="k">=</span> <span class="nc">Inbox</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">system</span><span class="o">);</span>
<span class="n">inbox</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">);</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="n">assert</span> <span class="n">inbox</span><span class="o">.</span><span class="n">receive</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="nc">SECONDS</span><span class="o">)).</span><span class="n">equals</span><span class="o">(</span><span class="s">&quot;world&quot;</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">TimeoutException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// timeout</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">send</span></tt> method wraps a normal <tt class="xref py py-meth docutils literal"><span class="pre">tell</span></tt> and supplies the internal
actor’s reference as the sender. This allows the reply to be received on the
last line.  Watching an actor is quite simple as well:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Inbox</span> <span class="n">inbox</span> <span class="k">=</span> <span class="nc">Inbox</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">system</span><span class="o">);</span>
<span class="n">inbox</span><span class="o">.</span><span class="n">watch</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
<span class="n">target</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">PoisonPill</span><span class="o">.</span><span class="n">getInstance</span><span class="o">(),</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="n">assert</span> <span class="n">inbox</span><span class="o">.</span><span class="n">receive</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="nc">SECONDS</span><span class="o">))</span> <span class="n">instanceof</span> <span class="nc">Terminated</span><span class="o">;</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">TimeoutException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// timeout</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="actor-api">
<h2>Actor API</h2>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">AbstractActor</span></tt> class defines a method called <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt>,
that is used to set the “initial behavior” of the actor.</p>
<p>If the current actor behavior does not match a received message,
<tt class="xref py py-meth docutils literal"><span class="pre">unhandled</span></tt> is called, which by default publishes an
<tt class="docutils literal"><span class="pre">akka.actor.UnhandledMessage(message,</span> <span class="pre">sender,</span> <span class="pre">recipient)</span></tt> on the actor
system’s event stream (set configuration item
<tt class="docutils literal"><span class="pre">akka.actor.debug.unhandled</span></tt> to <tt class="docutils literal"><span class="pre">on</span></tt> to have them converted into
actual Debug messages).</p>
<p>In addition, it offers:</p>
<ul>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">self</span></tt> reference to the <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> of the actor</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">sender</span></tt> reference sender Actor of the last received message, typically used as described in <a class="reference internal" href="#lambdaactor-reply"><em>Reply to messages</em></a></p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">supervisorStrategy</span></tt> user overridable definition the strategy to use for supervising child actors</p>
<p>This strategy is typically declared inside the actor in order to have access
to the actor’s internal state within the decider function: since failure is
communicated as a message sent to the supervisor and processed like other
messages (albeit outside of the normal behavior), all values and variables
within the actor are available, as is the <tt class="docutils literal"><span class="pre">sender</span></tt> reference (which will
be the immediate child reporting the failure; if the original failure
occurred within a distant descendant it is still reported one level up at a
time).</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">context</span></tt> exposes contextual information for the actor and the current message, such as:</p>
<ul class="simple">
<li>factory methods to create child actors (<tt class="xref py py-meth docutils literal"><span class="pre">actorOf</span></tt>)</li>
<li>system that the actor belongs to</li>
<li>parent supervisor</li>
<li>supervised children</li>
<li>lifecycle monitoring</li>
<li>hotswap behavior stack as described in <a class="reference internal" href="#actor-hotswap-lambda"><em>Become/Unbecome</em></a></li>
</ul>
</li>
</ul>
<p>The remaining visible methods are user-overridable life-cycle hooks which are
described in the following:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>

<span class="n">public</span> <span class="n">void</span> <span class="n">preRestart</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">reason</span><span class="o">,</span> <span class="n">scala</span><span class="o">.</span><span class="nc">Option</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">ActorRef</span> <span class="n">each</span> <span class="k">:</span> <span class="kt">getContext</span><span class="o">()</span><span class="kt">.getChildren</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">getContext</span><span class="o">().</span><span class="n">unwatch</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
    <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">postStop</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">public</span> <span class="n">void</span> <span class="n">postRestart</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">reason</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">preStart</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">public</span> <span class="n">void</span> <span class="n">postStop</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The implementations shown above are the defaults provided by the <tt class="xref py py-class docutils literal"><span class="pre">AbstractActor</span></tt>
class.</p>
<div class="section" id="actor-lifecycle">
<h3>Actor Lifecycle</h3>
<img alt="../_images/actor_lifecycle.png" class="align-center" src="../_images/actor_lifecycle.png" style="width: 680px;" />
<p>A path in an actor system represents a &quot;place&quot; which might be occupied
by a living actor. Initially (apart from system initialized actors) a path is
empty. When <tt class="docutils literal"><span class="pre">actorOf()</span></tt> is called it assigns an <em>incarnation</em> of the actor
described by the passed <tt class="docutils literal"><span class="pre">Props</span></tt> to the given path. An actor incarnation is
identified by the path <em>and a UID</em>. A restart only swaps the <tt class="docutils literal"><span class="pre">Actor</span></tt>
instance defined by the <tt class="docutils literal"><span class="pre">Props</span></tt> but the incarnation and hence the UID remains
the same.</p>
<p>The lifecycle of an incarnation ends when the actor is stopped. At
that point the appropriate lifecycle events are called and watching actors
are notified of the termination. After the incarnation is stopped, the path can
be reused again by creating an actor with <tt class="docutils literal"><span class="pre">actorOf()</span></tt>. In this case the
name of the new incarnation will be the same as the previous one but the
UIDs will differ.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is important to note that Actors do not stop automatically when no longer
referenced, every Actor that is created must also explicitly be destroyed.
The only simplification is that stopping a parent Actor will also recursively
stop all the child Actors that this parent has created.</p>
</div>
<p>An <tt class="docutils literal"><span class="pre">ActorRef</span></tt> always represents an incarnation (path and UID) not just a
given path. Therefore if an actor is stopped and a new one with the same
name is created an <tt class="docutils literal"><span class="pre">ActorRef</span></tt> of the old incarnation will not point
to the new one.</p>
<p><tt class="docutils literal"><span class="pre">ActorSelection</span></tt> on the other hand points to the path (or multiple paths
if wildcards are used) and is completely oblivious to which incarnation is currently
occupying it. <tt class="docutils literal"><span class="pre">ActorSelection</span></tt> cannot be watched for this reason. It is
possible to resolve the current incarnation's <tt class="docutils literal"><span class="pre">ActorRef</span></tt> living under the
path by sending an <tt class="docutils literal"><span class="pre">Identify</span></tt> message to the <tt class="docutils literal"><span class="pre">ActorSelection</span></tt> which
will be replied to with an <tt class="docutils literal"><span class="pre">ActorIdentity</span></tt> containing the correct reference
(see <a class="reference internal" href="#actorselection-lambda"><em>Identifying Actors via Actor Selection</em></a>). This can also be done with the <tt class="docutils literal"><span class="pre">resolveOne</span></tt>
method of the <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt>, which returns a <tt class="docutils literal"><span class="pre">Future</span></tt> of the matching
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>.</p>
</div>
<div class="section" id="lifecycle-monitoring-aka-deathwatch">
<span id="deathwatch-lambda"></span><h3>Lifecycle Monitoring aka DeathWatch</h3>
<p>In order to be notified when another actor terminates (i.e. stops permanently,
not temporary failure and restart), an actor may register itself for reception
of the <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt> message dispatched by the other actor upon
termination (see <a class="reference internal" href="#stopping-actors">Stopping Actors</a>). This service is provided by the
<tt class="xref py py-class docutils literal"><span class="pre">DeathWatch</span></tt> component of the actor system.</p>
<p>Registering a monitor is easy:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">WatchActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">child</span> <span class="k">=</span> <span class="n">context</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">empty</span><span class="o">(),</span> <span class="s">&quot;target&quot;</span><span class="o">);</span>
  <span class="k">private</span> <span class="nc">ActorRef</span> <span class="n">lastSender</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">deadLetters</span><span class="o">();</span>

  <span class="n">public</span> <span class="nc">WatchActor</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">context</span><span class="o">().</span><span class="n">watch</span><span class="o">(</span><span class="n">child</span><span class="o">);</span> <span class="c1">// &lt;-- this is the only call needed for registration</span>

    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;kill&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
        <span class="n">lastSender</span> <span class="k">=</span> <span class="n">sender</span><span class="o">();</span>
      <span class="o">}).</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">Terminated</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">actor</span><span class="o">().</span><span class="n">equals</span><span class="o">(</span><span class="n">child</span><span class="o">),</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">lastSender</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="s">&quot;finished&quot;</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It should be noted that the <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt> message is generated
independent of the order in which registration and termination occur.
In particular, the watching actor will receive a <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt> message
even if the watched actor has already been terminated at the time of registration.</p>
<p>Registering multiple times does not necessarily lead to multiple messages being
generated, but there is no guarantee that only exactly one such message is
received: if termination of the watched actor has generated and queued the
message, and another registration is done before this message has been
processed, then a second message will be queued, because registering for
monitoring of an already terminated actor leads to the immediate generation of
the <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt> message.</p>
<p>It is also possible to deregister from watching another actor’s liveliness
using <tt class="docutils literal"><span class="pre">context.unwatch(target)</span></tt>. This works even if the <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt>
message has already been enqueued in the mailbox; after calling <tt class="xref py py-meth docutils literal"><span class="pre">unwatch</span></tt>
no <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt> message for that actor will be processed anymore.</p>
</div>
<div class="section" id="start-hook">
<span id="start-hook-lambda"></span><h3>Start Hook</h3>
<p>Right after starting the actor, its <tt class="xref py py-meth docutils literal"><span class="pre">preStart</span></tt> method is invoked.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nd">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">target</span> <span class="k">=</span> <span class="n">context</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">MyActor</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="s">&quot;target&quot;</span><span class="o">));</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This method is called when the actor is first created. During restarts it is
called by the default implementation of <tt class="xref py py-meth docutils literal"><span class="pre">postRestart</span></tt>, which means that
by overriding that method you can choose whether the initialization code in
this method is called only exactly once for this actor or for every restart.
Initialization code which is part of the actor’s constructor will always be
called when an instance of the actor class is created, which happens at every
restart.</p>
</div>
<div class="section" id="restart-hooks">
<span id="restart-hook-lambda"></span><h3>Restart Hooks</h3>
<p>All actors are supervised, i.e. linked to another actor with a fault
handling strategy. Actors may be restarted in case an exception is thrown while
processing a message (see <a class="reference internal" href="../general/supervision.html#supervision"><em>Supervision and Monitoring</em></a>). This restart involves the hooks
mentioned above:</p>
<ol class="arabic">
<li><p class="first">The old actor is informed by calling <tt class="xref py py-meth docutils literal"><span class="pre">preRestart</span></tt> with the exception
which caused the restart and the message which triggered that exception; the
latter may be <tt class="docutils literal"><span class="pre">None</span></tt> if the restart was not caused by processing a
message, e.g. when a supervisor does not trap the exception and is restarted
in turn by its supervisor, or if an actor is restarted due to a sibling’s
failure. If the message is available, then that message’s sender is also
accessible in the usual way (i.e. by calling <tt class="docutils literal"><span class="pre">sender</span></tt>).</p>
<p>This method is the best place for cleaning up, preparing hand-over to the
fresh actor instance, etc.  By default it stops all children and calls
<tt class="xref py py-meth docutils literal"><span class="pre">postStop</span></tt>.</p>
</li>
<li><p class="first">The initial factory from the <tt class="docutils literal"><span class="pre">actorOf</span></tt> call is used
to produce the fresh instance.</p>
</li>
<li><p class="first">The new actor’s <tt class="xref py py-meth docutils literal"><span class="pre">postRestart</span></tt> method is invoked with the exception
which caused the restart. By default the <tt class="xref py py-meth docutils literal"><span class="pre">preStart</span></tt>
is called, just as in the normal start-up case.</p>
</li>
</ol>
<p>An actor restart replaces only the actual actor object; the contents of the
mailbox is unaffected by the restart, so processing of messages will resume
after the <tt class="xref py py-meth docutils literal"><span class="pre">postRestart</span></tt> hook returns. The message
that triggered the exception will not be received again. Any message
sent to an actor while it is being restarted will be queued to its mailbox as
usual.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be aware that the ordering of failure notifications relative to user messages
is not deterministic. In particular, a parent might restart its child before
it has processed the last messages sent by the child before the failure.
See <a class="reference internal" href="../general/message-delivery-reliability.html#message-ordering"><em>Discussion: Message Ordering</em></a> for details.</p>
</div>
</div>
<div class="section" id="stop-hook">
<span id="stop-hook-lambda"></span><h3>Stop Hook</h3>
<p>After stopping an actor, its <tt class="xref py py-meth docutils literal"><span class="pre">postStop</span></tt> hook is called, which may be used
e.g. for deregistering this actor from other services. This hook is guaranteed
to run after message queuing has been disabled for this actor, i.e. messages
sent to a stopped actor will be redirected to the <tt class="xref py py-obj docutils literal"><span class="pre">deadLetters</span></tt> of the
<tt class="xref py py-obj docutils literal"><span class="pre">ActorSystem</span></tt>.</p>
</div>
</div>
<div class="section" id="actorselection-lambda">
<span id="identifying-actors-via-actor-selection"></span><h2>Identifying Actors via Actor Selection</h2>
<p>As described in <a class="reference internal" href="../general/addressing.html#addressing"><em>Actor References, Paths and Addresses</em></a>, each actor has a unique logical path, which
is obtained by following the chain of actors from child to parent until
reaching the root of the actor system, and it has a physical path, which may
differ if the supervision chain includes any remote supervisors. These paths
are used by the system to look up actors, e.g. when a remote message is
received and the recipient is searched, but they are also useful more directly:
actors may look up other actors by specifying absolute or relative
paths—logical or physical—and receive back an <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt> with the
result:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// will look up this absolute path</span>
<span class="n">context</span><span class="o">().</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;/user/serviceA/actor&quot;</span><span class="o">);</span>
<span class="c1">// will look up sibling beneath same supervisor</span>
<span class="n">context</span><span class="o">().</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;../joe&quot;</span><span class="o">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>It is always preferable to communicate with other Actors using their ActorRef
instead of relying upon ActorSelection. Exceptions are</p>
<blockquote>
<div><ul class="simple">
<li>sending messages using the <a class="reference internal" href="lambda-persistence.html#at-least-once-delivery-java-lambda"><em>At-Least-Once Delivery</em></a> facility</li>
<li>initiating first contact with a remote system</li>
</ul>
</div></blockquote>
<p class="last">In all other cases ActorRefs can be provided during Actor creation or
initialization, passing them from parent to child or introducing Actors by
sending their ActorRefs to other Actors within messages.</p>
</div>
<p>The supplied path is parsed as a <tt class="xref py py-class docutils literal"><span class="pre">java.net.URI</span></tt>, which basically means
that it is split on <tt class="docutils literal"><span class="pre">/</span></tt> into path elements. If the path starts with <tt class="docutils literal"><span class="pre">/</span></tt>, it
is absolute and the look-up starts at the root guardian (which is the parent of
<tt class="docutils literal"><span class="pre">&quot;/user&quot;</span></tt>); otherwise it starts at the current actor. If a path element equals
<tt class="docutils literal"><span class="pre">..</span></tt>, the look-up will take a step “up” towards the supervisor of the
currently traversed actor, otherwise it will step “down” to the named child.
It should be noted that the <tt class="docutils literal"><span class="pre">..</span></tt> in actor paths here always means the logical
structure, i.e. the supervisor.</p>
<p>The path elements of an actor selection may contain wildcard patterns allowing for
broadcasting of messages to that section:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// will look all children to serviceB with names starting with worker</span>
<span class="n">context</span><span class="o">().</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;/user/serviceB/worker*&quot;</span><span class="o">);</span>
<span class="c1">// will look up all siblings beneath same supervisor</span>
<span class="n">context</span><span class="o">().</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;../*&quot;</span><span class="o">);</span>
</pre></div>
</div>
<p>Messages can be sent via the <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt> and the path of the
<tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt> is looked up when delivering each message. If the selection
does not match any actors the message will be dropped.</p>
<p>To acquire an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> for an <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt> you need to send
a message to the selection and use the <tt class="docutils literal"><span class="pre">sender()</span></tt> reference of the reply from
the actor. There is a built-in <tt class="docutils literal"><span class="pre">Identify</span></tt> message that all Actors will
understand and automatically reply to with a <tt class="docutils literal"><span class="pre">ActorIdentity</span></tt> message
containing the <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>. This message is handled specially by the
actors which are traversed in the sense that if a concrete name lookup fails
(i.e. a non-wildcard path element does not correspond to a live actor) then a
negative result is generated. Please note that this does not mean that delivery
of that reply is guaranteed, it still is a normal message.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorIdentity</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSelection</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.Identify</span><span class="o">;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">Follower</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="k">final</span> <span class="nc">Integer</span> <span class="n">identifyId</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">Follower</span><span class="o">(){</span>
    <span class="nc">ActorSelection</span> <span class="n">selection</span> <span class="k">=</span> <span class="n">context</span><span class="o">().</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;/user/another&quot;</span><span class="o">);</span>
    <span class="n">selection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="k">new</span> <span class="nc">Identify</span><span class="o">(</span><span class="n">identifyId</span><span class="o">),</span> <span class="n">self</span><span class="o">());</span>

    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">ActorIdentity</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="n">id</span><span class="o">.</span><span class="n">getRef</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">ActorRef</span> <span class="n">ref</span> <span class="k">=</span> <span class="n">id</span><span class="o">.</span><span class="n">getRef</span><span class="o">();</span>
        <span class="n">context</span><span class="o">().</span><span class="n">watch</span><span class="o">(</span><span class="n">ref</span><span class="o">);</span>
        <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">ref</span><span class="o">));</span>
      <span class="o">}).</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">ActorIdentity</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="n">id</span><span class="o">.</span><span class="n">getRef</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">,</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>

  <span class="k">final</span> <span class="nc">PartialFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">BoxedUnit</span><span class="o">&gt;</span> <span class="n">active</span><span class="o">(</span><span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">another</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">Terminated</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">actor</span><span class="o">().</span><span class="n">equals</span><span class="o">(</span><span class="n">another</span><span class="o">),</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You can also acquire an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> for an <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt> with
the <tt class="docutils literal"><span class="pre">resolveOne</span></tt> method of the <tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt>. It returns a
<tt class="docutils literal"><span class="pre">Future</span></tt> of the matching <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> if such an actor exists (see also
<a class="reference internal" href="lambda-index-actors.html#actor-java-lambda"><em>Actors (Java with Lambda Support)</em></a> for Java compatibility). It is completed with failure
[[akka.actor.ActorNotFound]] if no such actor exists or the identification
didn't complete within the supplied <cite>timeout</cite>.</p>
<p>Remote actor addresses may also be looked up, if <a class="reference internal" href="remoting.html#remoting-java"><em>remoting</em></a> is enabled:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">context</span><span class="o">().</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;akka.tcp://app@otherhost:1234/user/serviceB&quot;</span><span class="o">);</span>
</pre></div>
</div>
<p>An example demonstrating actor look-up is given in <a class="reference internal" href="remoting.html#remote-sample-java"><em>Remoting Sample</em></a>.</p>
</div>
<div class="section" id="messages-and-immutability">
<h2>Messages and immutability</h2>
<p><strong>IMPORTANT</strong>: Messages can be any kind of object but have to be
immutable. Akka can’t enforce immutability (yet) so this has to be by
convention.</p>
<p>Here is an example of an immutable message:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">ImmutableMessage</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">final</span> <span class="n">int</span> <span class="n">sequenceNumber</span><span class="o">;</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">ImmutableMessage</span><span class="o">(</span><span class="n">int</span> <span class="n">sequenceNumber</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">sequenceNumber</span> <span class="k">=</span> <span class="n">sequenceNumber</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">values</span> <span class="k">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="n">unmodifiableList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">values</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="n">int</span> <span class="n">getSequenceNumber</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sequenceNumber</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">getValues</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">values</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="send-messages">
<h2>Send messages</h2>
<p>Messages are sent to an Actor through one of the following methods.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tell</span></tt> means “fire-and-forget”, e.g. send a message asynchronously and return
immediately.</li>
<li><tt class="docutils literal"><span class="pre">ask</span></tt> sends a message asynchronously and returns a <tt class="xref py py-class docutils literal"><span class="pre">Future</span></tt>
representing a possible reply.</li>
</ul>
<p>Message ordering is guaranteed on a per-sender basis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are performance implications of using <tt class="docutils literal"><span class="pre">ask</span></tt> since something needs to
keep track of when it times out, there needs to be something that bridges
a <tt class="docutils literal"><span class="pre">Promise</span></tt> into an <tt class="docutils literal"><span class="pre">ActorRef</span></tt> and it also needs to be reachable through
remoting. So always prefer <tt class="docutils literal"><span class="pre">tell</span></tt> for performance, and only <tt class="docutils literal"><span class="pre">ask</span></tt> if you must.</p>
</div>
<p>In all these methods you have the option of passing along your own <tt class="docutils literal"><span class="pre">ActorRef</span></tt>.
Make it a practice of doing so because it will allow the receiver actors to be able to respond
to your message, since the sender reference is sent along with the message.</p>
<div class="section" id="tell-fire-forget">
<span id="actors-tell-sender-lambda"></span><h3>Tell: Fire-forget</h3>
<p>This is the preferred way of sending messages. No blocking waiting for a
message. This gives the best concurrency and scalability characteristics.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// don’t forget to think about who is the sender (2nd argument)</span>
<span class="n">target</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
</pre></div>
</div>
<p>The sender reference is passed along with the message and available within the
receiving actor via its <tt class="xref py py-meth docutils literal"><span class="pre">sender</span></tt> method while processing this
message. Inside of an actor it is usually <tt class="xref py py-meth docutils literal"><span class="pre">self</span></tt> who shall be the
sender, but there can be cases where replies shall be routed to some other
actor—e.g. the parent—in which the second argument to <tt class="xref py py-meth docutils literal"><span class="pre">tell</span></tt> would be a
different one. Outside of an actor and if no reply is needed the second
argument can be <tt class="docutils literal"><span class="pre">null</span></tt>; if a reply is needed outside of an actor you can use
the ask-pattern described next..</p>
</div>
<div class="section" id="ask-send-and-receive-future">
<span id="actors-ask-lambda"></span><h3>Ask: Send-And-Receive-Future</h3>
<p>The <tt class="docutils literal"><span class="pre">ask</span></tt> pattern involves actors as well as futures, hence it is offered as
a use pattern rather than a method on <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">static</span> <span class="n">akka</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="nc">Patterns</span><span class="o">.</span><span class="n">ask</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">static</span> <span class="n">akka</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="nc">Patterns</span><span class="o">.</span><span class="n">pipe</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration.Duration</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.dispatch.Futures</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.dispatch.Mapper</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.util.Timeout</span><span class="o">;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Timeout</span> <span class="n">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Timeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="nc">SECONDS</span><span class="o">));</span>

<span class="k">final</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;&gt;();</span>
<span class="n">futures</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">ask</span><span class="o">(</span><span class="n">actorA</span><span class="o">,</span> <span class="s">&quot;request&quot;</span><span class="o">,</span> <span class="mi">1000</span><span class="o">));</span> <span class="c1">// using 1000ms timeout</span>
<span class="n">futures</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">ask</span><span class="o">(</span><span class="n">actorB</span><span class="o">,</span> <span class="s">&quot;another request&quot;</span><span class="o">,</span> <span class="n">t</span><span class="o">));</span> <span class="c1">// using timeout from</span>
                                                <span class="c1">// above</span>

<span class="k">final</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">aggregate</span> <span class="k">=</span> <span class="nc">Futures</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="n">futures</span><span class="o">,</span>
    <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">());</span>

<span class="k">final</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Result</span><span class="o">&gt;</span> <span class="n">transformed</span> <span class="k">=</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
    <span class="k">new</span> <span class="nc">Mapper</span><span class="o">&lt;</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;,</span> <span class="nc">Result</span><span class="o">&gt;()</span> <span class="o">{</span>
      <span class="n">public</span> <span class="nc">Result</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">coll</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">final</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">it</span> <span class="k">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span><span class="o">();</span>
        <span class="k">final</span> <span class="nc">String</span> <span class="n">x</span> <span class="k">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">();</span>
        <span class="k">final</span> <span class="nc">String</span> <span class="n">s</span> <span class="k">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Result</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">},</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">());</span>

<span class="n">pipe</span><span class="o">(</span><span class="n">transformed</span><span class="o">,</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">()).</span><span class="n">to</span><span class="o">(</span><span class="n">actorC</span><span class="o">);</span>
</pre></div>
</div>
<p>This example demonstrates <tt class="docutils literal"><span class="pre">ask</span></tt> together with the <tt class="docutils literal"><span class="pre">pipe</span></tt> pattern on
futures, because this is likely to be a common combination. Please note that
all of the above is completely non-blocking and asynchronous: <tt class="docutils literal"><span class="pre">ask</span></tt> produces
a <tt class="xref py py-class docutils literal"><span class="pre">Future</span></tt>, two of which are composed into a new future using the
<tt class="xref py py-meth docutils literal"><span class="pre">Futures.sequence</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">map</span></tt> methods and then <tt class="docutils literal"><span class="pre">pipe</span></tt> installs
an <tt class="docutils literal"><span class="pre">onComplete</span></tt>-handler on the future to effect the submission of the
aggregated <tt class="xref py py-class docutils literal"><span class="pre">Result</span></tt> to another actor.</p>
<p>Using <tt class="docutils literal"><span class="pre">ask</span></tt> will send a message to the receiving Actor as with <tt class="docutils literal"><span class="pre">tell</span></tt>, and
the receiving actor must reply with <tt class="docutils literal"><span class="pre">sender().tell(reply,</span> <span class="pre">self())</span></tt> in order to
complete the returned <tt class="xref py py-class docutils literal"><span class="pre">Future</span></tt> with a value. The <tt class="docutils literal"><span class="pre">ask</span></tt> operation
involves creating an internal actor for handling this reply, which needs to
have a timeout after which it is destroyed in order not to leak resources; see
more below.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">To complete the future with an exception you need send a Failure message to the sender.
This is <em>not done automatically</em> when an actor throws an exception while processing a message.</p>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">try</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="n">result</span> <span class="k">=</span> <span class="n">operation</span><span class="o">();</span>
  <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="k">new</span> <span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="nc">Status</span><span class="o">.</span><span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">),</span> <span class="n">self</span><span class="o">());</span>
  <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If the actor does not complete the future, it will expire after the timeout period,
specified as parameter to the <tt class="docutils literal"><span class="pre">ask</span></tt> method; this will complete the
<tt class="xref py py-class docutils literal"><span class="pre">Future</span></tt> with an <tt class="xref py py-class docutils literal"><span class="pre">AskTimeoutException</span></tt>.</p>
<p>See <a class="reference internal" href="futures.html#futures-java"><em>Futures</em></a> for more information on how to await or query a
future.</p>
<p>The <tt class="docutils literal"><span class="pre">onComplete</span></tt>, <tt class="docutils literal"><span class="pre">onSuccess</span></tt>, or <tt class="docutils literal"><span class="pre">onFailure</span></tt> methods of the <tt class="docutils literal"><span class="pre">Future</span></tt> can be
used to register a callback to get a notification when the Future completes.
Gives you a way to avoid blocking.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When using future callbacks, inside actors you need to carefully avoid closing over
the containing actor’s reference, i.e. do not call methods or access mutable state
on the enclosing actor from within the callback. This would break the actor
encapsulation and may introduce synchronization bugs and race conditions because
the callback will be scheduled concurrently to the enclosing actor. Unfortunately
there is not yet a way to detect these illegal accesses at compile time. See also:
<a class="reference internal" href="../general/jmm.html#jmm-shared-state"><em>Actors and shared mutable state</em></a></p>
</div>
</div>
<div class="section" id="forward-message">
<h3>Forward message</h3>
<p>You can forward a message from one actor to another. This means that the
original sender address/reference is maintained even though the message is going
through a 'mediator'. This can be useful when writing actors that work as
routers, load-balancers, replicators etc.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">target</span><span class="o">.</span><span class="n">forward</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">context</span><span class="o">());</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="receive-messages">
<h2>Receive messages</h2>
<p>An Actor either has to set its initial receive behavior in the constructor by
calling the <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> method in the <tt class="xref py py-class docutils literal"><span class="pre">AbstractActor</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="nc">SomeActor</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
    <span class="c1">// and some behavior ...</span>
  <span class="n">build</span><span class="o">());</span>
<span class="o">}</span>
</pre></div>
</div>
<p>or by implementing the <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> method in the <tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> interface:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">abstract</span> <span class="nc">PartialFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">BoxedUnit</span><span class="o">&gt;</span> <span class="n">receive</span><span class="o">();</span>
</pre></div>
</div>
<p>Both the argument to the <tt class="xref py py-class docutils literal"><span class="pre">AbstractActor</span></tt> <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> method and the return
type of the <tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> method is a <tt class="docutils literal"><span class="pre">PartialFunction&lt;Object,</span> <span class="pre">BoxedUnit&gt;</span></tt>
that defines which messages your Actor can handle, along with the implementation of how the messages
should be processed.</p>
<p>Don't let the type signature scare you. To allow you to easily build up a partial
function there is a builder named <tt class="docutils literal"><span class="pre">ReceiveBuilder</span></tt> that you can use.</p>
<p>Here is an example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.AbstractActor</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.event.Logging</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.event.LoggingAdapter</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.japi.pf.ReceiveBuilder</span><span class="o">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">LoggingAdapter</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="n">context</span><span class="o">().</span><span class="n">system</span><span class="o">(),</span> <span class="k">this</span><span class="o">);</span>

  <span class="n">public</span> <span class="nc">MyActor</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Received String message: {}&quot;</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
      <span class="o">}).</span>
      <span class="n">matchAny</span><span class="o">(</span><span class="n">o</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;received unknown message&quot;</span><span class="o">)).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reply-to-messages">
<span id="lambdaactor-reply"></span><h2>Reply to messages</h2>
<p>If you want to have a handle for replying to a message, you can use
<tt class="docutils literal"><span class="pre">sender()</span></tt>, which gives you an ActorRef. You can reply by sending to
that ActorRef with <tt class="docutils literal"><span class="pre">sender().tell(replyMsg,</span> <span class="pre">self())</span></tt>. You can also store the ActorRef
for replying later, or passing on to other actors. If there is no sender (a
message was sent without an actor or future context) then the sender
defaults to a 'dead-letter' actor ref.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
</pre></div>
</div>
</div>
<div class="section" id="receive-timeout">
<h2>Receive timeout</h2>
<p>The <cite>ActorContext</cite> <tt class="xref py py-meth docutils literal"><span class="pre">setReceiveTimeout</span></tt> defines the inactivity timeout after which
the sending of a <cite>ReceiveTimeout</cite> message is triggered.
When specified, the receive function should be able to handle an <cite>akka.actor.ReceiveTimeout</cite> message.
1 millisecond is the minimum supported timeout.</p>
<p>Please note that the receive timeout might fire and enqueue the <cite>ReceiveTimeout</cite> message right after
another message was enqueued; hence it is <strong>not guaranteed</strong> that upon reception of the receive
timeout there must have been an idle period beforehand as configured via this method.</p>
<p>Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
periods). Pass in <cite>Duration.Undefined</cite> to switch off this feature.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">ReceiveTimeoutActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="n">public</span> <span class="nc">ReceiveTimeoutActor</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// To set an initial delay</span>
    <span class="n">context</span><span class="o">().</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;10 seconds&quot;</span><span class="o">));</span>

    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// To set in a response to a message</span>
        <span class="n">context</span><span class="o">().</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;1 second&quot;</span><span class="o">));</span>
      <span class="o">}).</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">ReceiveTimeout</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// To turn it off</span>
        <span class="n">context</span><span class="o">().</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="nc">Undefined</span><span class="o">());</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Messages marked with <tt class="docutils literal"><span class="pre">NotInfluenceReceiveTimeout</span></tt> will not reset the timer. This can be useful when
<tt class="docutils literal"><span class="pre">ReceiveTimeout</span></tt> should be fired by external inactivity but not influenced by internal activity,
e.g. scheduled tick messages.</p>
</div>
<div class="section" id="stopping-actors">
<span id="stopping-actors-lambda"></span><h2>Stopping actors</h2>
<p>Actors are stopped by invoking the <tt class="xref py py-meth docutils literal"><span class="pre">stop</span></tt> method of a <tt class="docutils literal"><span class="pre">ActorRefFactory</span></tt>,
i.e. <tt class="docutils literal"><span class="pre">ActorContext</span></tt> or <tt class="docutils literal"><span class="pre">ActorSystem</span></tt>. Typically the context is used for stopping
child actors and the system for stopping top level actors. The actual termination of
the actor is performed asynchronously, i.e. <tt class="xref py py-meth docutils literal"><span class="pre">stop</span></tt> may return before the actor is
stopped.</p>
<p>Processing of the current message, if any, will continue before the actor is stopped,
but additional messages in the mailbox will not be processed. By default these
messages are sent to the <tt class="xref py py-obj docutils literal"><span class="pre">deadLetters</span></tt> of the <tt class="xref py py-obj docutils literal"><span class="pre">ActorSystem</span></tt>, but that
depends on the mailbox implementation.</p>
<p>Termination of an actor proceeds in two steps: first the actor suspends its
mailbox processing and sends a stop command to all its children, then it keeps
processing the internal termination notifications from its children until the last one is
gone, finally terminating itself (invoking <tt class="xref py py-meth docutils literal"><span class="pre">postStop</span></tt>, dumping mailbox,
publishing <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt> on the <a class="reference internal" href="#deathwatch-lambda"><em>DeathWatch</em></a>, telling
its supervisor). This procedure ensures that actor system sub-trees terminate
in an orderly fashion, propagating the stop command to the leaves and
collecting their confirmation back to the stopped supervisor. If one of the
actors does not respond (i.e. processing a message for extended periods of time
and therefore not receiving the stop command), this whole process will be
stuck.</p>
<p>Upon <tt class="xref py py-meth docutils literal"><span class="pre">ActorSystem.terminate</span></tt>, the system guardian actors will be
stopped, and the aforementioned process will ensure proper termination of the
whole system.</p>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">postStop</span></tt> hook is invoked after an actor is fully stopped. This
enables cleaning up of resources:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nd">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">postStop</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// clean up some resources ...</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since stopping an actor is asynchronous, you cannot immediately reuse the
name of the child you just stopped; this will result in an
<tt class="xref py py-class docutils literal"><span class="pre">InvalidActorNameException</span></tt>. Instead, <tt class="xref py py-meth docutils literal"><span class="pre">watch</span></tt> the terminating
actor and create its replacement in response to the <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt>
message which will eventually arrive.</p>
</div>
<div class="section" id="poisonpill">
<span id="poison-pill-lambda"></span><h3>PoisonPill</h3>
<p>You can also send an actor the <tt class="docutils literal"><span class="pre">akka.actor.PoisonPill</span></tt> message, which will
stop the actor when the message is processed. <tt class="docutils literal"><span class="pre">PoisonPill</span></tt> is enqueued as
ordinary messages and will be handled after messages that were already queued
in the mailbox.</p>
</div>
<div class="section" id="graceful-stop">
<h3>Graceful Stop</h3>
<p><tt class="xref py py-meth docutils literal"><span class="pre">gracefulStop</span></tt> is useful if you need to wait for termination or compose ordered
termination of several actors:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">static</span> <span class="n">akka</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="nc">Patterns</span><span class="o">.</span><span class="n">gracefulStop</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration.Duration</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.pattern.AskTimeoutException</span><span class="o">;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">try</span> <span class="o">{</span>
  <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">stopped</span> <span class="k">=</span>
    <span class="n">gracefulStop</span><span class="o">(</span><span class="n">actorRef</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="nc">SECONDS</span><span class="o">),</span> <span class="nc">Manager</span><span class="o">.</span><span class="nc">SHUTDOWN</span><span class="o">);</span>
  <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">stopped</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="nc">SECONDS</span><span class="o">));</span>
  <span class="c1">// the actor has been stopped</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">AskTimeoutException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// the actor wasn&#39;t stopped within 5 seconds</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">Manager</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="k">private</span> <span class="n">static</span> <span class="n">enum</span> <span class="nc">Shutdown</span> <span class="o">{</span>
    <span class="nc">Shutdown</span>
  <span class="o">}</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="nc">Shutdown</span> <span class="nc">SHUTDOWN</span> <span class="k">=</span> <span class="nc">Shutdown</span><span class="o">.</span><span class="nc">Shutdown</span><span class="o">;</span>

  <span class="k">private</span> <span class="nc">ActorRef</span> <span class="n">worker</span> <span class="k">=</span>
  <span class="n">context</span><span class="o">().</span><span class="n">watch</span><span class="o">(</span><span class="n">context</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">Cruncher</span><span class="o">.</span><span class="n">class</span><span class="o">),</span> <span class="s">&quot;worker&quot;</span><span class="o">));</span>

  <span class="n">public</span> <span class="nc">Manager</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;job&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="s">&quot;crunch&quot;</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="nc">SHUTDOWN</span><span class="o">,</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">PoisonPill</span><span class="o">.</span><span class="n">getInstance</span><span class="o">(),</span> <span class="n">self</span><span class="o">());</span>
        <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">shuttingDown</span><span class="o">);</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="nc">PartialFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">BoxedUnit</span><span class="o">&gt;</span> <span class="n">shuttingDown</span> <span class="k">=</span>
    <span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;job&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="s">&quot;service unavailable, shutting down&quot;</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span>
      <span class="k">match</span><span class="o">(</span><span class="nc">Terminated</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">actor</span><span class="o">().</span><span class="n">equals</span><span class="o">(</span><span class="n">worker</span><span class="o">),</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">gracefulStop()</span></tt> returns successfully, the actor’s <tt class="docutils literal"><span class="pre">postStop()</span></tt> hook
will have been executed: there exists a happens-before edge between the end of
<tt class="docutils literal"><span class="pre">postStop()</span></tt> and the return of <tt class="docutils literal"><span class="pre">gracefulStop()</span></tt>.</p>
<p>In the above example a custom <tt class="docutils literal"><span class="pre">Manager.Shutdown</span></tt> message is sent to the target
actor to initiate the process of stopping the actor. You can use <tt class="docutils literal"><span class="pre">PoisonPill</span></tt> for
this, but then you have limited possibilities to perform interactions with other actors
before stopping the target actor. Simple cleanup tasks can be handled in <tt class="docutils literal"><span class="pre">postStop</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Keep in mind that an actor stopping and its name being deregistered are
separate events which happen asynchronously from each other. Therefore it may
be that you will find the name still in use after <tt class="docutils literal"><span class="pre">gracefulStop()</span></tt>
returned. In order to guarantee proper deregistration, only reuse names from
within a supervisor you control and only in response to a <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt>
message, i.e. not for top-level actors.</p>
</div>
</div>
</div>
<div class="section" id="become-unbecome">
<span id="actor-hotswap-lambda"></span><h2>Become/Unbecome</h2>
<div class="section" id="upgrade">
<h3>Upgrade</h3>
<p>Akka supports hotswapping the Actor’s message loop (e.g. its implementation) at
runtime: invoke the <tt class="docutils literal"><span class="pre">context.become</span></tt> method from within the Actor.
<tt class="xref py py-meth docutils literal"><span class="pre">become</span></tt> takes a <tt class="docutils literal"><span class="pre">PartialFunction&lt;Object,</span> <span class="pre">BoxedUnit&gt;</span></tt> that implements the new
message handler. The hotswapped code is kept in a Stack which can be pushed and
popped.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Please note that the actor will revert to its original behavior when restarted by its Supervisor.</p>
</div>
<p>To hotswap the Actor behavior using <tt class="docutils literal"><span class="pre">become</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">HotSwapActor</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>
  <span class="k">private</span> <span class="nc">PartialFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">BoxedUnit</span><span class="o">&gt;</span> <span class="n">angry</span><span class="o">;</span>
  <span class="k">private</span> <span class="nc">PartialFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">BoxedUnit</span><span class="o">&gt;</span> <span class="n">happy</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">HotSwapActor</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">angry</span> <span class="k">=</span>
      <span class="nc">ReceiveBuilder</span><span class="o">.</span>
        <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
          <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="s">&quot;I am already angry?&quot;</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
        <span class="o">}).</span>
        <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
          <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">happy</span><span class="o">);</span>
        <span class="o">}).</span><span class="n">build</span><span class="o">();</span>

    <span class="n">happy</span> <span class="k">=</span> <span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="s">&quot;I am already happy :-)&quot;</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
      <span class="o">}).</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">angry</span><span class="o">);</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">();</span>

    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">angry</span><span class="o">);</span>
      <span class="o">}).</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">happy</span><span class="o">);</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This variant of the <tt class="xref py py-meth docutils literal"><span class="pre">become</span></tt> method is useful for many different things,
such as to implement a Finite State Machine (FSM, for an example see <a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-fsm-java-lambda">Dining
Hakkers</a>). It will replace the current behavior (i.e. the top of the behavior
stack), which means that you do not use <tt class="xref py py-meth docutils literal"><span class="pre">unbecome</span></tt>, instead always the
next behavior is explicitly installed.</p>
<p>The other way of using <tt class="xref py py-meth docutils literal"><span class="pre">become</span></tt> does not replace but add to the top of
the behavior stack. In this case care must be taken to ensure that the number
of “pop” operations (i.e. <tt class="xref py py-meth docutils literal"><span class="pre">unbecome</span></tt>) matches the number of “push” ones
in the long run, otherwise this amounts to a memory leak (which is why this
behavior is not the default).</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">Swapper</span> <span class="k">extends</span> <span class="nc">AbstractLoggingActor</span> <span class="o">{</span>
  <span class="n">public</span> <span class="nc">Swapper</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
          <span class="n">log</span><span class="o">().</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Hi&quot;</span><span class="o">);</span>
          <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
                  <span class="n">matchEquals</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="n">log</span><span class="o">().</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Ho&quot;</span><span class="o">);</span>
                    <span class="n">context</span><span class="o">().</span><span class="n">unbecome</span><span class="o">();</span> <span class="c1">// resets the latest &#39;become&#39; (just for fun)</span>
                  <span class="o">}).</span><span class="n">build</span><span class="o">(),</span> <span class="kc">false</span><span class="o">);</span> <span class="c1">// push on top instead of replace</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">SwapperApp</span> <span class="o">{</span>
  <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ActorSystem</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;SwapperSystem&quot;</span><span class="o">);</span>
    <span class="nc">ActorRef</span> <span class="n">swapper</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">Swapper</span><span class="o">.</span><span class="n">class</span><span class="o">),</span> <span class="s">&quot;swapper&quot;</span><span class="o">);</span>
    <span class="n">swapper</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span> <span class="c1">// logs Hi</span>
    <span class="n">swapper</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span> <span class="c1">// logs Ho</span>
    <span class="n">swapper</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span> <span class="c1">// logs Hi</span>
    <span class="n">swapper</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span> <span class="c1">// logs Ho</span>
    <span class="n">swapper</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span> <span class="c1">// logs Hi</span>
    <span class="n">swapper</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">Swap</span><span class="o">,</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span> <span class="c1">// logs Ho</span>
    <span class="n">system</span><span class="o">.</span><span class="n">terminate</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="stash">
<span id="stash-lambda"></span><h2>Stash</h2>
<p>The <tt class="docutils literal"><span class="pre">AbstractActorWithStash</span></tt> class enables an actor to temporarily stash away messages
that can not or should not be handled using the actor's current
behavior. Upon changing the actor's message handler, i.e., right
before invoking <tt class="docutils literal"><span class="pre">context().become()</span></tt> or <tt class="docutils literal"><span class="pre">context().unbecome()</span></tt>, all
stashed messages can be &quot;unstashed&quot;, thereby prepending them to the actor's
mailbox. This way, the stashed messages can be processed in the same
order as they have been received originally. An actor that extends
<tt class="docutils literal"><span class="pre">AbstractActorWithStash</span></tt> will automatically get a deque-based mailbox.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The abstract class <tt class="docutils literal"><span class="pre">AbstractActorWithStash</span></tt> implements the marker
interface <tt class="docutils literal"><span class="pre">RequiresMessageQueue&lt;DequeBasedMessageQueueSemantics&gt;</span></tt>
which requests the system to automatically choose a deque based
mailbox implementation for the actor. If you want more
control over the mailbox, see the documentation on mailboxes: <a class="reference internal" href="mailboxes.html#mailboxes-java"><em>Mailboxes</em></a>.</p>
</div>
<p>Here is an example of the <tt class="docutils literal"><span class="pre">AbstractActorWithStash</span></tt> class in action:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">ActorWithProtocol</span> <span class="k">extends</span> <span class="nc">AbstractActorWithStash</span> <span class="o">{</span>
  <span class="n">public</span> <span class="nc">ActorWithProtocol</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
      <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;open&quot;</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
          <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;write&quot;</span><span class="o">,</span> <span class="n">ws</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="cm">/* do writing */</span> <span class="o">}).</span>
          <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;close&quot;</span><span class="o">,</span> <span class="n">cs</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">unstashAll</span><span class="o">();</span>
            <span class="n">context</span><span class="o">().</span><span class="n">unbecome</span><span class="o">();</span>
          <span class="o">}).</span>
          <span class="n">matchAny</span><span class="o">(</span><span class="n">msg</span> <span class="o">-&gt;</span> <span class="n">stash</span><span class="o">()).</span><span class="n">build</span><span class="o">(),</span> <span class="kc">false</span><span class="o">);</span>
      <span class="o">}).</span>
      <span class="n">matchAny</span><span class="o">(</span><span class="n">msg</span> <span class="o">-&gt;</span> <span class="n">stash</span><span class="o">()).</span><span class="n">build</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Invoking <tt class="docutils literal"><span class="pre">stash()</span></tt> adds the current message (the message that the
actor received last) to the actor's stash. It is typically invoked
when handling the default case in the actor's message handler to stash
messages that aren't handled by the other cases. It is illegal to
stash the same message twice; to do so results in an
<tt class="docutils literal"><span class="pre">IllegalStateException</span></tt> being thrown. The stash may also be bounded
in which case invoking <tt class="docutils literal"><span class="pre">stash()</span></tt> may lead to a capacity violation,
which results in a <tt class="docutils literal"><span class="pre">StashOverflowException</span></tt>. The capacity of the
stash can be configured using the <tt class="docutils literal"><span class="pre">stash-capacity</span></tt> setting (an <tt class="docutils literal"><span class="pre">Int</span></tt>) of the
mailbox's configuration.</p>
<p>Invoking <tt class="docutils literal"><span class="pre">unstashAll()</span></tt> enqueues messages from the stash to the
actor's mailbox until the capacity of the mailbox (if any) has been
reached (note that messages from the stash are prepended to the
mailbox). In case a bounded mailbox overflows, a
<tt class="docutils literal"><span class="pre">MessageQueueAppendFailedException</span></tt> is thrown.
The stash is guaranteed to be empty after calling <tt class="docutils literal"><span class="pre">unstashAll()</span></tt>.</p>
<p>The stash is backed by a <tt class="docutils literal"><span class="pre">scala.collection.immutable.Vector</span></tt>. As a
result, even a very large number of messages may be stashed without a
major impact on performance.</p>
<p>Note that the stash is part of the ephemeral actor state, unlike the
mailbox. Therefore, it should be managed like other parts of the
actor's state which have the same property. The <tt class="xref py py-class docutils literal"><span class="pre">AbstractActorWithStash</span></tt>
implementation of <tt class="xref py py-meth docutils literal"><span class="pre">preRestart</span></tt> will call <tt class="docutils literal"><span class="pre">unstashAll()</span></tt>, which is
usually the desired behavior.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want to enforce that your actor can only work with an unbounded stash,
then you should use the <tt class="docutils literal"><span class="pre">AbstractActorWithUnboundedStash</span></tt> class instead.</p>
</div>
</div>
<div class="section" id="killing-an-actor">
<span id="killing-actors-lambda"></span><h2>Killing an Actor</h2>
<p>You can kill an actor by sending a <tt class="docutils literal"><span class="pre">Kill</span></tt> message. This will cause the actor
to throw a <tt class="xref py py-class docutils literal"><span class="pre">ActorKilledException</span></tt>, triggering a failure. The actor will
suspend operation and its supervisor will be asked how to handle the failure,
which may mean resuming the actor, restarting it or terminating it completely.
See <a class="reference internal" href="../general/supervision.html#supervision-directives"><em>What Supervision Means</em></a> for more information.</p>
<p>Use <tt class="docutils literal"><span class="pre">Kill</span></tt> like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">victim</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="nc">Kill</span><span class="o">.</span><span class="n">getInstance</span><span class="o">(),</span> <span class="nc">ActorRef</span><span class="o">.</span><span class="n">noSender</span><span class="o">());</span>
</pre></div>
</div>
</div>
<div class="section" id="actors-and-exceptions">
<h2>Actors and exceptions</h2>
<p>It can happen that while a message is being processed by an actor, that some
kind of exception is thrown, e.g. a database exception.</p>
<div class="section" id="what-happens-to-the-message">
<h3>What happens to the Message</h3>
<p>If an exception is thrown while a message is being processed (i.e. taken out of
its mailbox and handed over to the current behavior), then this message will be
lost. It is important to understand that it is not put back on the mailbox. So
if you want to retry processing of a message, you need to deal with it yourself
by catching the exception and retry your flow. Make sure that you put a bound
on the number of retries since you don't want a system to livelock (so
consuming a lot of cpu cycles without making progress). Another possibility
would be to have a look at the <a class="reference internal" href="../contrib/peek-mailbox.html#mailbox-acking"><em>PeekMailbox pattern</em></a>.</p>
</div>
<div class="section" id="what-happens-to-the-mailbox">
<h3>What happens to the mailbox</h3>
<p>If an exception is thrown while a message is being processed, nothing happens to
the mailbox. If the actor is restarted, the same mailbox will be there. So all
messages on that mailbox will be there as well.</p>
</div>
<div class="section" id="what-happens-to-the-actor">
<h3>What happens to the actor</h3>
<p>If code within an actor throws an exception, that actor is suspended and the
supervision process is started (see <a class="reference internal" href="../general/supervision.html#supervision"><em>Supervision and Monitoring</em></a>). Depending on the
supervisor’s decision the actor is resumed (as if nothing happened), restarted
(wiping out its internal state and starting from scratch) or terminated.</p>
</div>
</div>
<div class="section" id="initialization-patterns">
<h2>Initialization patterns</h2>
<p>The rich lifecycle hooks of Actors provide a useful toolkit to implement various initialization patterns. During the
lifetime of an <tt class="docutils literal"><span class="pre">ActorRef</span></tt>, an actor can potentially go through several restarts, where the old instance is replaced by
a fresh one, invisibly to the outside observer who only sees the <tt class="docutils literal"><span class="pre">ActorRef</span></tt>.</p>
<p>One may think about the new instances as &quot;incarnations&quot;. Initialization might be necessary for every incarnation
of an actor, but sometimes one needs initialization to happen only at the birth of the first instance when the
<tt class="docutils literal"><span class="pre">ActorRef</span></tt> is created. The following sections provide patterns for different initialization needs.</p>
<div class="section" id="initialization-via-constructor">
<h3>Initialization via constructor</h3>
<p>Using the constructor for initialization has various benefits. First of all, it makes it possible to use <tt class="docutils literal"><span class="pre">val</span></tt> fields to store
any state that does not change during the life of the actor instance, making the implementation of the actor more robust.
The constructor is invoked for every incarnation of the actor, therefore the internals of the actor can always assume
that proper initialization happened. This is also the drawback of this approach, as there are cases when one would
like to avoid reinitializing internals on restart. For example, it is often useful to preserve child actors across
restarts. The following section provides a pattern for this case.</p>
</div>
<div class="section" id="initialization-via-prestart">
<h3>Initialization via preStart</h3>
<p>The method <tt class="docutils literal"><span class="pre">preStart()</span></tt> of an actor is only called once directly during the initialization of the first instance, that
is, at creation of its <tt class="docutils literal"><span class="pre">ActorRef</span></tt>. In the case of restarts, <tt class="docutils literal"><span class="pre">preStart()</span></tt> is called from <tt class="docutils literal"><span class="pre">postRestart()</span></tt>, therefore
if not overridden, <tt class="docutils literal"><span class="pre">preStart()</span></tt> is called on every incarnation. However, overriding <tt class="docutils literal"><span class="pre">postRestart()</span></tt> one can disable
this behavior, and ensure that there is only one call to <tt class="docutils literal"><span class="pre">preStart()</span></tt>.</p>
<p>One useful usage of this pattern is to disable creation of new <tt class="docutils literal"><span class="pre">ActorRefs</span></tt> for children during restarts. This can be
achieved by overriding <tt class="docutils literal"><span class="pre">preRestart()</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nd">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// Initialize children here</span>
<span class="o">}</span>

<span class="c1">// Overriding postRestart to disable the call to preStart()</span>
<span class="c1">// after restarts</span>
<span class="nd">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">postRestart</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">reason</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>

<span class="c1">// The default implementation of preRestart() stops all the children</span>
<span class="c1">// of the actor. To opt-out from stopping the children, we</span>
<span class="c1">// have to override preRestart()</span>
<span class="nd">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">preRestart</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">reason</span><span class="o">,</span> <span class="nc">Option</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">message</span><span class="o">)</span>
  <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
  <span class="c1">// Keep the call to postStop(), but no stopping of children</span>
  <span class="n">postStop</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Please note, that the child actors are <em>still restarted</em>, but no new <tt class="docutils literal"><span class="pre">ActorRef</span></tt> is created. One can recursively apply
the same principles for the children, ensuring that their <tt class="docutils literal"><span class="pre">preStart()</span></tt> method is called only at the creation of their
refs.</p>
<p>For more information see <a class="reference internal" href="../general/supervision.html#supervision-restart"><em>What Restarting Means</em></a>.</p>
</div>
<div class="section" id="initialization-via-message-passing">
<h3>Initialization via message passing</h3>
<p>There are cases when it is impossible to pass all the information needed for actor initialization in the constructor,
for example in the presence of circular dependencies. In this case the actor should listen for an initialization message,
and use <tt class="docutils literal"><span class="pre">become()</span></tt> or a finite state-machine state transition to encode the initialized and uninitialized states
of the actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">receive</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
    <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;init&quot;</span><span class="o">,</span> <span class="n">m1</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="n">initializeMe</span> <span class="k">=</span> <span class="s">&quot;Up and running&quot;</span><span class="o">;</span>
      <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="nc">ReceiveBuilder</span><span class="o">.</span>
        <span class="n">matchEquals</span><span class="o">(</span><span class="s">&quot;U OK?&quot;</span><span class="o">,</span> <span class="n">m2</span> <span class="o">-&gt;</span> <span class="o">{</span>
          <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="n">initializeMe</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
        <span class="o">}).</span><span class="n">build</span><span class="o">());</span>

    <span class="o">}).</span><span class="n">build</span><span class="o">()</span>
</pre></div>
</div>
<p>If the actor may receive messages before it has been initialized, a useful tool can be the <tt class="docutils literal"><span class="pre">Stash</span></tt> to save messages
until the initialization finishes, and replaying them after the actor became initialized.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This pattern should be used with care, and applied only when none of the patterns above are applicable. One of
the potential issues is that messages might be lost when sent to remote actors. Also, publishing an <tt class="docutils literal"><span class="pre">ActorRef</span></tt> in
an uninitialized state might lead to the condition that it receives a user message before the initialization has been
done.</p>
</div>
</div>
</div>
<div class="section" id="lambdas-and-performance">
<span id="actor-performance-lambda"></span><h2>Lambdas and Performance</h2>
<p>There is one big difference between the optimized partial functions created by the Scala compiler and the ones created by the
<tt class="docutils literal"><span class="pre">ReceiveBuilder</span></tt>. The partial functions created by the <tt class="docutils literal"><span class="pre">ReceiveBuilder</span></tt> consist of multiple lambda expressions for every match
statement, where each lambda is an object referencing the code to be run. This is something that the JVM can have problems
optimizing and the resulting code might not be as performant as the Scala equivalent or the corresponding
<a class="reference internal" href="untyped-actors.html#untyped-actors-java"><em>untyped actor</em></a> version.</p>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>