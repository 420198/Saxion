


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Streams Cookbook &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/toc.js"></script>
    <script type="text/javascript" src="../../_static/prettify.js"></script>
    <script type="text/javascript" src="../../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../../_static/effects.core.js"></script>
    <script type="text/javascript" src="../../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../../_static/ga.js"></script>
    <script type="text/javascript" src="../../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../../index.html" />
    <link rel="up" title="Streams" href="index.html" />
    <link rel="next" title="Configuration" href="../../general/stream/stream-configuration.html" />
    <link rel="prev" title="Overview of built-in stages and their semantics" href="stages-overview.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Streams Cookbook</div>
      <div class="pdf-link"><a href="../../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../../AkkaJava.pdf" title="Akka Java Documentation"><img src="../../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="../../general/stream/stream-configuration.html">Configuration</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../../java.html">Java Contents</a> <span class="divider">|</span> <a href="../../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="stages-overview.html">Overview of built-in stages and their semantics</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="streams-cookbook">
<span id="stream-cookbook-java"></span><h1>Streams Cookbook</h1>
<div class="section" id="introduction">
<h2>Introduction</h2>
<p>This is a collection of patterns to demonstrate various usage of the Akka Streams API by solving small targeted
problems in the format of &quot;recipes&quot;. The purpose of this page is to give inspiration and ideas how to approach
various small tasks involving streams. The recipes in this page can be used directly as-is, but they are most powerful as
starting points: customization of the code snippets is warmly encouraged.</p>
<p>This part also serves as supplementary material for the main body of documentation. It is a good idea to have this page
open while reading the manual and look for examples demonstrating various streaming concepts
as they appear in the main body of documentation.</p>
<p>If you need a quick reference of the available processing stages used in the recipes see <a class="reference internal" href="stages-overview.html#stages-overview-java"><em>Overview of built-in stages and their semantics</em></a>.</p>
</div>
<div class="section" id="working-with-flows">
<h2>Working with Flows</h2>
<p>In this collection we show simple recipes that involve linear flows. The recipes in this section are rather
general, more targeted recipes are available as separate sections (<a class="reference internal" href="stream-rate.html#stream-rate-java"><em>Buffers and working with rate</em></a>, <a class="reference internal" href="stream-io.html#stream-io-java"><em>Working with streaming IO</em></a>).</p>
<div class="section" id="logging-elements-of-a-stream">
<h3>Logging elements of a stream</h3>
<p><strong>Situation:</strong> During development it is sometimes helpful to see what happens in a particular section of a stream.</p>
<p>The simplest solution is to simply use a <tt class="docutils literal"><span class="pre">map</span></tt> operation and use <tt class="docutils literal"><span class="pre">println</span></tt> to print the elements received to the console.
While this recipe is rather simplistic, it is often suitable for a quick debug session.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">mySource</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">elem</span> <span class="o">-&gt;</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">elem</span><span class="o">;</span>
<span class="o">});</span>
</pre></div>
</div>
<p>Another approach to logging is to use <tt class="docutils literal"><span class="pre">log()</span></tt> operation which allows configuring logging for elements flowing through
the stream as well as completion and erroring.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// customise log levels</span>
<span class="n">mySource</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;before-map&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withAttributes</span><span class="o">(</span><span class="nc">Attributes</span><span class="o">.</span><span class="n">createLogLevels</span><span class="o">(</span><span class="n">onElement</span><span class="o">,</span> <span class="n">onFinish</span><span class="o">,</span> <span class="n">onFailure</span><span class="o">))</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">analyse</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>

<span class="c1">// or provide custom logging adapter</span>
<span class="k">final</span> <span class="nc">LoggingAdapter</span> <span class="n">adapter</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="n">system</span><span class="o">,</span> <span class="s">&quot;customLogger&quot;</span><span class="o">);</span>
<span class="n">mySource</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;custom&quot;</span><span class="o">,</span> <span class="n">adapter</span><span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="flattening-a-stream-of-sequences">
<h3>Flattening a stream of sequences</h3>
<p><strong>Situation:</strong> A stream is given as a stream of sequence of elements, but a stream of elements needed instead, streaming
all the nested elements inside the sequences separately.</p>
<p>The <tt class="docutils literal"><span class="pre">mapConcat</span></tt> operation can be used to implement a one-to-many transformation of elements using a mapper function
in the form of <tt class="docutils literal"><span class="pre">In</span> <span class="pre">-&gt;</span> <span class="pre">List&lt;Out&gt;</span></tt>. In this case we want to map a <tt class="docutils literal"><span class="pre">List</span></tt> of elements to the elements in the
collection itself, so we can just call <tt class="docutils literal"><span class="pre">mapConcat(l</span> <span class="pre">-&gt;</span> <span class="pre">l)</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Source</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">myData</span> <span class="k">=</span> <span class="n">someDataSource</span><span class="o">;</span>
<span class="nc">Source</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">flattened</span> <span class="k">=</span> <span class="n">myData</span><span class="o">.</span><span class="n">mapConcat</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="draining-a-stream-to-a-strict-collection">
<h3>Draining a stream to a strict collection</h3>
<p><strong>Situation:</strong> A possibly unbounded sequence of elements is given as a stream, which needs to be collected into a Scala collection while ensuring boundedness</p>
<p>A common situation when working with streams is one where we need to collect incoming elements into a Scala collection.
This operation is supported via <tt class="docutils literal"><span class="pre">Sink.seq</span></tt> which materializes into a <tt class="docutils literal"><span class="pre">CompletionStage&lt;List&lt;T&gt;&gt;</span></tt>.</p>
<p>The function <tt class="docutils literal"><span class="pre">limit</span></tt> or <tt class="docutils literal"><span class="pre">take</span></tt> should always be used in conjunction in order to guarantee stream boundedness, thus preventing the program from running out of memory.</p>
<p>For example, this is best avoided:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// Dangerous: might produce a collection with 2 billion elements!</span>
<span class="k">final</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">strings</span> <span class="k">=</span> <span class="n">mySource</span><span class="o">.</span><span class="n">runWith</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">seq</span><span class="o">(),</span> <span class="n">mat</span><span class="o">);</span>
</pre></div>
</div>
<p>Rather, use <tt class="docutils literal"><span class="pre">limit</span></tt> or <tt class="docutils literal"><span class="pre">take</span></tt> to ensure that the resulting <tt class="docutils literal"><span class="pre">List</span></tt> will contain only up to <tt class="docutils literal"><span class="pre">MAX_ALLOWED_SIZE</span></tt> elements:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="n">int</span> <span class="nc">MAX_ALLOWED_SIZE</span> <span class="k">=</span> <span class="mi">100</span><span class="o">;</span>

<span class="c1">// OK. Future will fail with a `StreamLimitReachedException`</span>
<span class="c1">// if the number of incoming elements is larger than max</span>
<span class="k">final</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">strings</span> <span class="k">=</span>
  <span class="n">mySource</span><span class="o">.</span><span class="n">limit</span><span class="o">(</span><span class="nc">MAX_ALLOWED_SIZE</span><span class="o">).</span><span class="n">runWith</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">seq</span><span class="o">(),</span> <span class="n">mat</span><span class="o">);</span>

<span class="c1">// OK. Collect up until max-th elements only, then cancel upstream</span>
<span class="k">final</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">strings</span> <span class="k">=</span>
  <span class="n">mySource</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="nc">MAX_ALLOWED_SIZE</span><span class="o">).</span><span class="n">runWith</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">seq</span><span class="o">(),</span> <span class="n">mat</span><span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="calculating-the-digest-of-a-bytestring-stream">
<h3>Calculating the digest of a ByteString stream</h3>
<p><strong>Situation:</strong> A stream of bytes is given as a stream of <tt class="docutils literal"><span class="pre">ByteStrings</span></tt> and we want to calculate the cryptographic digest
of the stream.</p>
<p>This recipe uses a <tt class="xref py py-class docutils literal"><span class="pre">GraphStage</span></tt> to host a mutable <tt class="xref py py-class docutils literal"><span class="pre">MessageDigest</span></tt> class (part of the Java Cryptography
API) and update it with the bytes arriving from the stream. When the stream starts, the <tt class="docutils literal"><span class="pre">onPull</span></tt> handler of the
stage is called, which just bubbles up the <tt class="docutils literal"><span class="pre">pull</span></tt> event to its upstream. As a response to this pull, a ByteString
chunk will arrive (<tt class="docutils literal"><span class="pre">onPush</span></tt>) which we use to update the digest, then it will pull for the next chunk.</p>
<p>Eventually the stream of <tt class="docutils literal"><span class="pre">ByteStrings</span></tt> depletes and we get a notification about this event via <tt class="docutils literal"><span class="pre">onUpstreamFinish</span></tt>.
At this point we want to emit the digest value, but we cannot do it with <tt class="docutils literal"><span class="pre">push</span></tt> in this handler directly since there may
be no downstream demand. Instead we call <tt class="docutils literal"><span class="pre">emit</span></tt> which will temporarily replace the handlers, emit the provided value when
demand comes in and then reset the stage state. It will then complete the stage.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DigestCalculator</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">String</span> <span class="n">algorithm</span><span class="o">;</span>
  <span class="n">public</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;DigestCalculator.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;DigestCalculator.out&quot;</span><span class="o">);</span>
  <span class="k">private</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="n">public</span> <span class="nc">DigestCalculator</span><span class="o">(</span><span class="nc">String</span> <span class="n">algorithm</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">algorithm</span> <span class="k">=</span> <span class="n">algorithm</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">final</span> <span class="nc">MessageDigest</span> <span class="n">digest</span><span class="o">;</span>

      <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">digest</span> <span class="k">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="n">getInstance</span><span class="o">(</span><span class="n">algorithm</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">NoSuchAlgorithmException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="nc">ByteString</span> <span class="n">chunk</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="n">digest</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">toArray</span><span class="o">());</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>

          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onUpstreamFinish</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="c1">// If the stream is finished, we need to emit the digest</span>
            <span class="c1">// before completing</span>
            <span class="n">emit</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">.</span><span class="n">fromArray</span><span class="o">(</span><span class="n">digest</span><span class="o">.</span><span class="n">digest</span><span class="o">()));</span>
            <span class="n">completeStage</span><span class="o">();</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>


    <span class="o">};</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Source</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">digest</span> <span class="k">=</span> <span class="n">data</span>
  <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="k">new</span> <span class="nc">DigestCalculator</span><span class="o">(</span><span class="s">&quot;SHA-256&quot;</span><span class="o">));</span>
</pre></div>
</div>
</div>
<div class="section" id="parsing-lines-from-a-stream-of-bytestrings">
<span id="cookbook-parse-lines-java"></span><h3>Parsing lines from a stream of ByteStrings</h3>
<p><strong>Situation:</strong> A stream of bytes is given as a stream of <tt class="docutils literal"><span class="pre">ByteStrings</span></tt> containing lines terminated by line ending
characters (or, alternatively, containing binary frames delimited by a special delimiter byte sequence) which
needs to be parsed.</p>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">Framing</span></tt> helper class contains a convenience method to parse messages from a stream of <tt class="docutils literal"><span class="pre">ByteStrings</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Source</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="k">=</span> <span class="n">rawData</span>
  <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="nc">Framing</span><span class="o">.</span><span class="n">delimiter</span><span class="o">(</span><span class="nc">ByteString</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="s">&quot;\r\n&quot;</span><span class="o">),</span> <span class="mi">100</span><span class="o">,</span> <span class="nc">FramingTruncation</span><span class="o">.</span><span class="nc">ALLOW</span><span class="o">))</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">utf8String</span><span class="o">());</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-reduce-by-key">
<h3>Implementing reduce-by-key</h3>
<p><strong>Situation:</strong> Given a stream of elements, we want to calculate some aggregated value on different subgroups of the
elements.</p>
<p>The &quot;hello world&quot; of reduce-by-key style operations is <em>wordcount</em> which we demonstrate below. Given a stream of words
we first create a new stream that groups the words according to the <tt class="docutils literal"><span class="pre">i&nbsp;-&gt;&nbsp;i</span></tt> function, i.e. now
we have a stream of streams, where every substream will serve identical words.</p>
<p>To count the words, we need to process the stream of streams (the actual groups
containing identical words). <tt class="docutils literal"><span class="pre">groupBy</span></tt> returns a <tt class="xref py py-class docutils literal"><span class="pre">SubSource</span></tt>, which
means that we transform the resulting substreams directly. In this case we use
the <tt class="docutils literal"><span class="pre">reduce</span></tt> combinator to aggregate the word itself and the number of its
occurrences within a <tt class="xref py py-class docutils literal"><span class="pre">Pair</span></tt>. Each substream will then
emit one final value—precisely such a pair—when the overall input completes. As
a last step we merge back these values from the substreams into one single
output stream.</p>
<p>One noteworthy detail pertains to the <tt class="docutils literal"><span class="pre">MAXIMUM_DISTINCT_WORDS</span></tt> parameter:
this defines the breadth of the merge operation. Akka Streams is focused on
bounded resource consumption and the number of concurrently open inputs to the
merge operator describes the amount of resources needed by the merge itself.
Therefore only a finite number of substreams can be active at any given time.
If the <tt class="docutils literal"><span class="pre">groupBy</span></tt> operator encounters more keys than this number then the
stream cannot continue without violating its resource bound, in this case
<tt class="docutils literal"><span class="pre">groupBy</span></tt> will terminate with a failure.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="n">int</span> <span class="nc">MAXIMUM_DISTINCT_WORDS</span> <span class="k">=</span> <span class="mi">1000</span><span class="o">;</span>

<span class="k">final</span> <span class="nc">Source</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">words</span>
    <span class="c1">// split the words into separate streams first</span>
  <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="nc">MAXIMUM_DISTINCT_WORDS</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">)</span>
  <span class="c1">//transform each element to pair with number of words in it</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">i</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
  <span class="c1">// add counting logic to the streams</span>
  <span class="o">.</span><span class="n">reduce</span><span class="o">((</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">left</span><span class="o">.</span><span class="n">first</span><span class="o">(),</span> <span class="n">left</span><span class="o">.</span><span class="n">second</span><span class="o">()</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">second</span><span class="o">()))</span>
  <span class="c1">// get a stream of word counts</span>
  <span class="o">.</span><span class="n">mergeSubstreams</span><span class="o">();</span>
</pre></div>
</div>
<p>By extracting the parts specific to <em>wordcount</em> into</p>
<ul class="simple">
<li>a <tt class="docutils literal"><span class="pre">groupKey</span></tt> function that defines the groups</li>
<li>a <tt class="docutils literal"><span class="pre">map</span></tt> map each element to value that is used by the reduce on the substream</li>
<li>a <tt class="docutils literal"><span class="pre">reduce</span></tt> function that does the actual reduction</li>
</ul>
<p>we get a generalized version below:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">static</span> <span class="n">public</span> <span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="n">K</span><span class="o">,</span> <span class="nc">Out</span><span class="o">&gt;</span> <span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="nc">Out</span><span class="o">&gt;,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">reduceByKey</span><span class="o">(</span>
    <span class="n">int</span> <span class="n">maximumGroupSize</span><span class="o">,</span>
    <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">groupKey</span><span class="o">,</span>
    <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="nc">Out</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span>
    <span class="nc">Function2</span><span class="o">&lt;</span><span class="nc">Out</span><span class="o">,</span> <span class="nc">Out</span><span class="o">,</span> <span class="nc">Out</span><span class="o">&gt;</span> <span class="n">reduce</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">return</span> <span class="nc">Flow</span><span class="o">.&lt;</span><span class="nc">In</span><span class="o">&gt;</span> <span class="n">create</span><span class="o">()</span>
    <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="n">maximumGroupSize</span><span class="o">,</span> <span class="n">groupKey</span><span class="o">)</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">groupKey</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">map</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">((</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">left</span><span class="o">.</span><span class="n">first</span><span class="o">(),</span> <span class="n">reduce</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="n">second</span><span class="o">(),</span> <span class="n">right</span><span class="o">.</span><span class="n">second</span><span class="o">())))</span>
    <span class="o">.</span><span class="n">mergeSubstreams</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="n">int</span> <span class="nc">MAXIMUM_DISTINCT_WORDS</span> <span class="k">=</span> <span class="mi">1000</span><span class="o">;</span>

<span class="nc">Source</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">words</span><span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="n">reduceByKey</span><span class="o">(</span>
  <span class="nc">MAXIMUM_DISTINCT_WORDS</span><span class="o">,</span>
  <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">word</span><span class="o">,</span>
  <span class="n">word</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please note that the reduce-by-key version we discussed above is sequential
in reading the overall input stream, in other words it is <strong>NOT</strong> a
parallelization pattern like MapReduce and similar frameworks.</p>
</div>
</div>
<div class="section" id="sorting-elements-to-multiple-groups-with-groupby">
<h3>Sorting elements to multiple groups with groupBy</h3>
<p><strong>Situation:</strong> The <tt class="docutils literal"><span class="pre">groupBy</span></tt> operation strictly partitions incoming elements, each element belongs to exactly one group.
Sometimes we want to map elements into multiple groups simultaneously.</p>
<p>To achieve the desired result, we attack the problem in two steps:</p>
<ul class="simple">
<li>first, using a function <tt class="docutils literal"><span class="pre">topicMapper</span></tt> that gives a list of topics (groups) a message belongs to, we transform our
stream of <tt class="docutils literal"><span class="pre">Message</span></tt> to a stream of <tt class="xref py py-class docutils literal"><span class="pre">Pair&lt;Message,</span> <span class="pre">Topic&gt;`</span></tt> where for each topic the message belongs to a separate pair
will be emitted. This is achieved by using <tt class="docutils literal"><span class="pre">mapConcat</span></tt></li>
<li>Then we take this new stream of message topic pairs (containing a separate pair for each topic a given message
belongs to) and feed it into groupBy, using the topic as the group key.</li>
</ul>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Topic</span><span class="o">&gt;&gt;</span> <span class="n">topicMapper</span> <span class="k">=</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">extractTopics</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>

<span class="k">final</span> <span class="nc">Source</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Topic</span><span class="o">&gt;,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">messageAndTopic</span> <span class="k">=</span> <span class="n">elems</span>
  <span class="o">.</span><span class="n">mapConcat</span><span class="o">((</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Topic</span><span class="o">&gt;</span> <span class="n">topicsForMessage</span> <span class="k">=</span> <span class="n">topicMapper</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="c1">// Create a (Msg, Topic) pair for each of the topics</span>

    <span class="c1">// the message belongs to</span>
    <span class="k">return</span> <span class="n">topicsForMessage</span>
      <span class="o">.</span><span class="n">stream</span><span class="o">()</span>
      <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">topic</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Topic</span><span class="o">&gt;(</span><span class="n">msg</span><span class="o">,</span> <span class="n">topic</span><span class="o">))</span>
      <span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
<span class="o">});</span>

<span class="nc">SubSource</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Topic</span><span class="o">&gt;,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">multiGroups</span> <span class="k">=</span> <span class="n">messageAndTopic</span>
  <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">pair</span> <span class="o">-&gt;</span> <span class="n">pair</span><span class="o">.</span><span class="n">second</span><span class="o">())</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">pair</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">Message</span> <span class="n">message</span> <span class="k">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">first</span><span class="o">();</span>
    <span class="nc">Topic</span> <span class="n">topic</span> <span class="k">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">second</span><span class="o">();</span>

    <span class="c1">// do what needs to be done</span>
  <span class="o">});</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="working-with-graphs">
<h2>Working with Graphs</h2>
<p>In this collection we show recipes that use stream graph elements to achieve various goals.</p>
<div class="section" id="triggering-the-flow-of-elements-programmatically">
<h3>Triggering the flow of elements programmatically</h3>
<p><strong>Situation:</strong> Given a stream of elements we want to control the emission of those elements according to a trigger signal.
In other words, even if the stream would be able to flow (not being backpressured) we want to hold back elements until a
trigger signal arrives.</p>
<p>This recipe solves the problem by simply zipping the stream of <tt class="docutils literal"><span class="pre">Message</span></tt> elements with the stream of <tt class="docutils literal"><span class="pre">Trigger</span></tt>
signals. Since <tt class="docutils literal"><span class="pre">Zip</span></tt> produces pairs, we simply map the output stream selecting the first element of the pair.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">RunnableGraph</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">TestPublisher</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Trigger</span><span class="o">&gt;,</span> <span class="nc">TestSubscriber</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="k">=</span>
  <span class="nc">RunnableGraph</span><span class="o">.&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">TestPublisher</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Trigger</span><span class="o">&gt;,</span> <span class="nc">TestSubscriber</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;&gt;&gt;</span><span class="n">fromGraph</span><span class="o">(</span>
    <span class="nc">GraphDSL</span><span class="o">.</span><span class="n">create</span><span class="o">(</span>
      <span class="n">triggerSource</span><span class="o">,</span>
      <span class="n">messageSink</span><span class="o">,</span>
      <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">),</span>
      <span class="o">(</span><span class="n">builder</span><span class="o">,</span> <span class="n">source</span><span class="o">,</span> <span class="n">sink</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">SourceShape</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;</span> <span class="n">elements</span> <span class="k">=</span>
          <span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Source</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;4&quot;</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Message</span><span class="o">(</span><span class="n">t</span><span class="o">)));</span>
        <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Trigger</span><span class="o">&gt;,</span> <span class="nc">Message</span><span class="o">&gt;</span> <span class="n">takeMessage</span> <span class="k">=</span>
          <span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Flow</span><span class="o">.&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Trigger</span><span class="o">&gt;&gt;</span><span class="n">create</span><span class="o">().</span><span class="n">map</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">first</span><span class="o">()));</span>
        <span class="k">final</span> <span class="nc">FanInShape2</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Trigger</span><span class="o">,</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Trigger</span><span class="o">&gt;&gt;</span> <span class="n">zip</span> <span class="k">=</span>
          <span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Zip</span><span class="o">.</span><span class="n">create</span><span class="o">());</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">elements</span><span class="o">).</span><span class="n">toInlet</span><span class="o">(</span><span class="n">zip</span><span class="o">.</span><span class="n">in0</span><span class="o">());</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">source</span><span class="o">).</span><span class="n">toInlet</span><span class="o">(</span><span class="n">zip</span><span class="o">.</span><span class="n">in1</span><span class="o">());</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">zip</span><span class="o">.</span><span class="n">out</span><span class="o">()).</span><span class="n">via</span><span class="o">(</span><span class="n">takeMessage</span><span class="o">).</span><span class="n">to</span><span class="o">(</span><span class="n">sink</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">ClosedShape</span><span class="o">.</span><span class="n">getInstance</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">)</span>
  <span class="o">);</span>
</pre></div>
</div>
<p>Alternatively, instead of using a <tt class="docutils literal"><span class="pre">Zip</span></tt>, and then using <tt class="docutils literal"><span class="pre">map</span></tt> to get the first element of the pairs, we can avoid
creating the pairs in the first place by using <tt class="docutils literal"><span class="pre">ZipWith</span></tt> which takes a two argument function to produce the output
element. If this function would return a pair of the two argument it would be exactly the behavior of <tt class="docutils literal"><span class="pre">Zip</span></tt> so
<tt class="docutils literal"><span class="pre">ZipWith</span></tt> is a generalization of zipping.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">RunnableGraph</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">TestPublisher</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Trigger</span><span class="o">&gt;,</span> <span class="nc">TestSubscriber</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="k">=</span>
  <span class="nc">RunnableGraph</span><span class="o">.&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">TestPublisher</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Trigger</span><span class="o">&gt;,</span> <span class="nc">TestSubscriber</span><span class="o">.</span><span class="nc">Probe</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;&gt;&gt;</span><span class="n">fromGraph</span><span class="o">(</span>
    <span class="nc">GraphDSL</span><span class="o">.</span><span class="n">create</span><span class="o">(</span>
      <span class="n">triggerSource</span><span class="o">,</span>
      <span class="n">messageSink</span><span class="o">,</span>
      <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">),</span>
      <span class="o">(</span><span class="n">builder</span><span class="o">,</span> <span class="n">source</span><span class="o">,</span> <span class="n">sink</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">final</span> <span class="nc">SourceShape</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;</span> <span class="n">elements</span> <span class="k">=</span>
          <span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Source</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;4&quot;</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Message</span><span class="o">(</span><span class="n">t</span><span class="o">)));</span>
        <span class="k">final</span> <span class="nc">FanInShape2</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Trigger</span><span class="o">,</span> <span class="nc">Message</span><span class="o">&gt;</span> <span class="n">zipWith</span> <span class="k">=</span>
          <span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">ZipWith</span><span class="o">.</span><span class="n">create</span><span class="o">((</span><span class="n">msg</span><span class="o">,</span> <span class="n">trigger</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">msg</span><span class="o">));</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">elements</span><span class="o">).</span><span class="n">toInlet</span><span class="o">(</span><span class="n">zipWith</span><span class="o">.</span><span class="n">in0</span><span class="o">());</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">source</span><span class="o">).</span><span class="n">toInlet</span><span class="o">(</span><span class="n">zipWith</span><span class="o">.</span><span class="n">in1</span><span class="o">());</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">zipWith</span><span class="o">.</span><span class="n">out</span><span class="o">()).</span><span class="n">to</span><span class="o">(</span><span class="n">sink</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">ClosedShape</span><span class="o">.</span><span class="n">getInstance</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">)</span>
  <span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="balancing-jobs-to-a-fixed-pool-of-workers">
<h3>Balancing jobs to a fixed pool of workers</h3>
<p><strong>Situation:</strong> Given a stream of jobs and a worker process expressed as a <tt class="xref py py-class docutils literal"><span class="pre">Flow</span></tt> create a pool of workers
that automatically balances incoming jobs to available workers, then merges the results.</p>
<p>We will express our solution as a function that takes a worker flow and the number of workers to be allocated and gives
a flow that internally contains a pool of these workers. To achieve the desired result we will create a <tt class="xref py py-class docutils literal"><span class="pre">Flow</span></tt>
from a graph.</p>
<p>The graph consists of a <tt class="docutils literal"><span class="pre">Balance</span></tt> node which is a special fan-out operation that tries to route elements to available
downstream consumers. In a <tt class="docutils literal"><span class="pre">for</span></tt> loop we wire all of our desired workers as outputs of this balancer element, then
we wire the outputs of these workers to a <tt class="docutils literal"><span class="pre">Merge</span></tt> element that will collect the results from the workers.</p>
<p>To make the worker stages run in parallel we mark them as asynchronous with <cite>async()</cite>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="n">static</span> <span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="nc">Out</span><span class="o">&gt;</span> <span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="nc">Out</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">balancer</span><span class="o">(</span>
    <span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="nc">Out</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">worker</span><span class="o">,</span> <span class="n">int</span> <span class="n">workerCount</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nc">Flow</span><span class="o">.</span><span class="n">fromGraph</span><span class="o">(</span><span class="nc">GraphDSL</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="n">boolean</span> <span class="n">waitForAllDownstreams</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">final</span> <span class="nc">UniformFanOutShape</span><span class="o">&lt;</span><span class="nc">In</span><span class="o">,</span> <span class="nc">In</span><span class="o">&gt;</span> <span class="n">balance</span> <span class="k">=</span>
              <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Balance</span><span class="o">.&lt;</span><span class="nc">In</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="n">workerCount</span><span class="o">,</span> <span class="n">waitForAllDownstreams</span><span class="o">));</span>
      <span class="k">final</span> <span class="nc">UniformFanInShape</span><span class="o">&lt;</span><span class="nc">Out</span><span class="o">,</span> <span class="nc">Out</span><span class="o">&gt;</span> <span class="n">merge</span> <span class="k">=</span>
              <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Merge</span><span class="o">.&lt;</span><span class="nc">Out</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="n">workerCount</span><span class="o">));</span>

      <span class="k">for</span> <span class="o">(</span><span class="n">int</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workerCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
          <span class="n">b</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">balance</span><span class="o">.</span><span class="n">out</span><span class="o">(</span><span class="n">i</span><span class="o">)).</span><span class="n">via</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">worker</span><span class="o">.</span><span class="n">async</span><span class="o">())).</span><span class="n">toInlet</span><span class="o">(</span><span class="n">merge</span><span class="o">.</span><span class="n">in</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
      <span class="o">}</span>

      <span class="k">return</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">balance</span><span class="o">.</span><span class="n">in</span><span class="o">(),</span> <span class="n">merge</span><span class="o">.</span><span class="n">out</span><span class="o">());</span>
  <span class="o">}));</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Message</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">balancer</span> <span class="k">=</span> <span class="n">balancer</span><span class="o">(</span><span class="n">worker</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="nc">Source</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">processedJobs</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="n">balancer</span><span class="o">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="working-with-rate">
<h2>Working with rate</h2>
<p>This collection of recipes demonstrate various patterns where rate differences between upstream and downstream
needs to be handled by other strategies than simple backpressure.</p>
<div class="section" id="dropping-elements">
<h3>Dropping elements</h3>
<p><strong>Situation:</strong> Given a fast producer and a slow consumer, we want to drop elements if necessary to not slow down
the producer too much.</p>
<p>This can be solved by using a versatile rate-transforming operation, <tt class="docutils literal"><span class="pre">conflate</span></tt>. Conflate can be thought as
a special <tt class="docutils literal"><span class="pre">reduce</span></tt> operation that collapses multiple upstream elements into one aggregate element if needed to keep
the speed of the upstream unaffected by the downstream.</p>
<p>When the upstream is faster, the reducing process of the <tt class="docutils literal"><span class="pre">conflate</span></tt> starts. Our reducer function simply takes
the freshest element. This in a simple dropping operation.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">,</span> <span class="nc">Message</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">droppyStream</span> <span class="k">=</span>
  <span class="nc">Flow</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="n">class</span><span class="o">).</span><span class="n">conflate</span><span class="o">((</span><span class="n">lastMessage</span><span class="o">,</span> <span class="n">newMessage</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">newMessage</span><span class="o">);</span>
</pre></div>
</div>
<p>There is a version of <tt class="docutils literal"><span class="pre">conflate</span></tt> named <tt class="docutils literal"><span class="pre">conflateWithSeed</span></tt> that allows to express more complex aggregations, more
similar to a <tt class="docutils literal"><span class="pre">fold</span></tt>.</p>
</div>
<div class="section" id="dropping-broadcast">
<h3>Dropping broadcast</h3>
<p><strong>Situation:</strong> The default <tt class="docutils literal"><span class="pre">Broadcast</span></tt> graph element is properly backpressured, but that means that a slow downstream
consumer can hold back the other downstream consumers resulting in lowered throughput. In other words the rate of
<tt class="docutils literal"><span class="pre">Broadcast</span></tt> is the rate of its slowest downstream consumer. In certain cases it is desirable to allow faster consumers
to progress independently of their slower siblings by dropping elements if necessary.</p>
<p>One solution to this problem is to append a <tt class="docutils literal"><span class="pre">buffer</span></tt> element in front of all of the downstream consumers
defining a dropping strategy instead of the default <tt class="docutils literal"><span class="pre">Backpressure</span></tt>. This allows small temporary rate differences
between the different consumers (the buffer smooths out small rate variances), but also allows faster consumers to
progress by dropping from the buffer of the slow consumers if necessary.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// Makes a sink drop elements if too slow</span>
<span class="n">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nc">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Done</span><span class="o">&gt;&gt;</span> <span class="n">droppySink</span><span class="o">(</span><span class="nc">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Done</span><span class="o">&gt;&gt;</span> <span class="n">sink</span><span class="o">,</span> <span class="n">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nc">Flow</span><span class="o">.&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">create</span><span class="o">()</span>
    <span class="o">.</span><span class="n">buffer</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="nc">OverflowStrategy</span><span class="o">.</span><span class="n">dropHead</span><span class="o">())</span>
    <span class="o">.</span><span class="n">toMat</span><span class="o">(</span><span class="n">sink</span><span class="o">,</span> <span class="nc">Keep</span><span class="o">.</span><span class="n">right</span><span class="o">());</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">RunnableGraph</span><span class="o">.</span><span class="n">fromGraph</span><span class="o">(</span><span class="nc">GraphDSL</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="o">{</span>
  <span class="k">final</span> <span class="n">int</span> <span class="n">outputCount</span> <span class="k">=</span> <span class="mi">3</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">UniformFanOutShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">bcast</span> <span class="k">=</span>
    <span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Broadcast</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">outputCount</span><span class="o">));</span>
  <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">myData</span><span class="o">)).</span><span class="n">toFanOut</span><span class="o">(</span><span class="n">bcast</span><span class="o">);</span>
  <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">bcast</span><span class="o">).</span><span class="n">to</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">droppySink</span><span class="o">(</span><span class="n">mySink1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)));</span>
  <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">bcast</span><span class="o">).</span><span class="n">to</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">droppySink</span><span class="o">(</span><span class="n">mySink2</span><span class="o">,</span> <span class="mi">10</span><span class="o">)));</span>
  <span class="n">builder</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">bcast</span><span class="o">).</span><span class="n">to</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">droppySink</span><span class="o">(</span><span class="n">mySink3</span><span class="o">,</span> <span class="mi">10</span><span class="o">)));</span>
  <span class="k">return</span> <span class="nc">ClosedShape</span><span class="o">.</span><span class="n">getInstance</span><span class="o">();</span>
<span class="o">}));</span>
</pre></div>
</div>
</div>
<div class="section" id="collecting-missed-ticks">
<h3>Collecting missed ticks</h3>
<p><strong>Situation:</strong> Given a regular (stream) source of ticks, instead of trying to backpressure the producer of the ticks
we want to keep a counter of the missed ticks instead and pass it down when possible.</p>
<p>We will use <tt class="docutils literal"><span class="pre">conflateWithSeed</span></tt> to solve the problem. Conflate takes two functions:</p>
<ul class="simple">
<li>A seed function that produces the zero element for the folding process that happens when the upstream is faster than
the downstream. In our case the seed function is a constant function that returns 0 since there were no missed ticks
at that point.</li>
<li>A fold function that is invoked when multiple upstream messages needs to be collapsed to an aggregate value due
to the insufficient processing rate of the downstream. Our folding function simply increments the currently stored
count of the missed ticks so far.</li>
</ul>
<p>As a result, we have a flow of <tt class="docutils literal"><span class="pre">Int</span></tt> where the number represents the missed ticks. A number 0 means that we were
able to consume the tick fast enough (i.e. zero means: 1 non-missed tick + 0 missed ticks)</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">Tick</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">missedTicks</span> <span class="k">=</span>
  <span class="nc">Flow</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Tick</span><span class="o">.</span><span class="n">class</span><span class="o">).</span><span class="n">conflateWithSeed</span><span class="o">(</span><span class="n">tick</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">missed</span><span class="o">,</span> <span class="n">tick</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">missed</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="create-a-stream-processor-that-repeats-the-last-element-seen">
<h3>Create a stream processor that repeats the last element seen</h3>
<p><strong>Situation:</strong> Given a producer and consumer, where the rate of neither is known in advance, we want to ensure that none
of them is slowing down the other by dropping earlier unconsumed elements from the upstream if necessary, and repeating
the last value for the downstream if necessary.</p>
<p>We have two options to implement this feature. In both cases we will use <tt class="xref py py-class docutils literal"><span class="pre">GraphStage</span></tt> to build our custom
element. In the first version we will use a provided initial value <tt class="docutils literal"><span class="pre">initial</span></tt> that will be used
to feed the downstream if no upstream element is ready yet. In the <tt class="docutils literal"><span class="pre">onPush()</span></tt> handler we just overwrite the
<tt class="docutils literal"><span class="pre">currentValue</span></tt> variable and immediately relieve the upstream by calling <tt class="docutils literal"><span class="pre">pull()</span></tt>. The downstream <tt class="docutils literal"><span class="pre">onPull</span></tt> handler
is very similar, we immediately relieve the downstream by emitting <tt class="docutils literal"><span class="pre">currentValue</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HoldWithInitial</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="n">public</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;HoldWithInitial.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;HoldWithInitial.out&quot;</span><span class="o">);</span>
  <span class="k">private</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="n">T</span> <span class="n">initial</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">HoldWithInitial</span><span class="o">(</span><span class="n">T</span> <span class="n">initial</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">initial</span> <span class="k">=</span> <span class="n">initial</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">private</span> <span class="n">T</span> <span class="n">currentValue</span> <span class="k">=</span> <span class="n">initial</span><span class="o">;</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">currentValue</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">currentValue</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>While it is relatively simple, the drawback of the first version is that it needs an arbitrary initial element which is not
always possible to provide. Hence, we create a second version where the downstream might need to wait in one single
case: if the very first element is not yet available.</p>
<p>We introduce a boolean variable <tt class="docutils literal"><span class="pre">waitingFirstValue</span></tt> to denote whether the first element has been provided or not
(alternatively an <tt class="xref py py-class docutils literal"><span class="pre">Optional</span></tt> can be used for <tt class="docutils literal"><span class="pre">currentValue</span></tt> or if the element type is a subclass of Object
a null can be used with the same purpose). In the downstream <tt class="docutils literal"><span class="pre">onPull()</span></tt> handler the difference from the previous
version is that we check if we have received the first value and only emit if we have. This leads to that when the
first element comes in we must check if there possibly already was demand from downstream so that we in that case can
push the element directly.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HoldWithWait</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
  <span class="n">public</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;HoldWithInitial.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;HoldWithInitial.out&quot;</span><span class="o">);</span>
  <span class="k">private</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">private</span> <span class="n">T</span> <span class="n">currentValue</span> <span class="k">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="k">private</span> <span class="n">boolean</span> <span class="n">waitingFirstValue</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">currentValue</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">waitingFirstValue</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">waitingFirstValue</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">isAvailable</span><span class="o">(</span><span class="n">out</span><span class="o">))</span> <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">currentValue</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">waitingFirstValue</span><span class="o">)</span> <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">currentValue</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
      <span class="o">}</span>

    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="globally-limiting-the-rate-of-a-set-of-streams">
<h3>Globally limiting the rate of a set of streams</h3>
<p><strong>Situation:</strong> Given a set of independent streams that we cannot merge, we want to globally limit the aggregate
throughput of the set of streams.</p>
<p>One possible solution uses a shared actor as the global limiter combined with mapAsync to create a reusable
<tt class="xref py py-class docutils literal"><span class="pre">Flow</span></tt> that can be plugged into a stream to limit its rate.</p>
<p>As the first step we define an actor that will do the accounting for the global rate limit. The actor maintains
a timer, a counter for pending permit tokens and a queue for possibly waiting participants. The actor has
an <tt class="docutils literal"><span class="pre">open</span></tt> and <tt class="docutils literal"><span class="pre">closed</span></tt> state. The actor is in the <tt class="docutils literal"><span class="pre">open</span></tt> state while it has still pending permits. Whenever a
request for permit arrives as a <tt class="docutils literal"><span class="pre">WantToPass</span></tt> message to the actor the number of available permits is decremented
and we notify the sender that it can pass by answering with a <tt class="docutils literal"><span class="pre">MayPass</span></tt> message. If the amount of permits reaches
zero, the actor transitions to the <tt class="docutils literal"><span class="pre">closed</span></tt> state. In this state requests are not immediately answered, instead the reference
of the sender is added to a queue. Once the timer for replenishing the pending permits fires by sending a <tt class="docutils literal"><span class="pre">ReplenishTokens</span></tt>
message, we increment the pending permits counter and send a reply to each of the waiting senders. If there are more
waiting senders than permits available we will stay in the <tt class="docutils literal"><span class="pre">closed</span></tt> state.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">Limiter</span> <span class="k">extends</span> <span class="nc">AbstractActor</span> <span class="o">{</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">class</span> <span class="nc">WantToPass</span> <span class="o">{}</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="nc">WantToPass</span> <span class="nc">WANT_TO_PASS</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">WantToPass</span><span class="o">();</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">class</span> <span class="nc">MayPass</span> <span class="o">{}</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="nc">MayPass</span> <span class="nc">MAY_PASS</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MayPass</span><span class="o">();</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">class</span> <span class="nc">ReplenishTokens</span> <span class="o">{}</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="nc">ReplenishTokens</span> <span class="nc">REPLENISH_TOKENS</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ReplenishTokens</span><span class="o">();</span>

  <span class="k">private</span> <span class="k">final</span> <span class="n">int</span> <span class="n">maxAvailableTokens</span><span class="o">;</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">FiniteDuration</span> <span class="n">tokenRefreshPeriod</span><span class="o">;</span>
  <span class="k">private</span> <span class="k">final</span> <span class="n">int</span> <span class="n">tokenRefreshAmount</span><span class="o">;</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ActorRef</span><span class="o">&gt;</span> <span class="n">waitQueue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">Cancellable</span> <span class="n">replenishTimer</span><span class="o">;</span>

  <span class="k">private</span> <span class="n">int</span> <span class="n">permitTokens</span><span class="o">;</span>

  <span class="n">public</span> <span class="n">static</span> <span class="nc">Props</span> <span class="n">props</span><span class="o">(</span><span class="n">int</span> <span class="n">maxAvailableTokens</span><span class="o">,</span> <span class="nc">FiniteDuration</span> <span class="n">tokenRefreshPeriod</span><span class="o">,</span>
      <span class="n">int</span> <span class="n">tokenRefreshAmount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">Limiter</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">maxAvailableTokens</span><span class="o">,</span> <span class="n">tokenRefreshPeriod</span><span class="o">,</span>
      <span class="n">tokenRefreshAmount</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="nc">Limiter</span><span class="o">(</span><span class="n">int</span> <span class="n">maxAvailableTokens</span><span class="o">,</span> <span class="nc">FiniteDuration</span> <span class="n">tokenRefreshPeriod</span><span class="o">,</span>
      <span class="n">int</span> <span class="n">tokenRefreshAmount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">maxAvailableTokens</span> <span class="k">=</span> <span class="n">maxAvailableTokens</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">tokenRefreshPeriod</span> <span class="k">=</span> <span class="n">tokenRefreshPeriod</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">tokenRefreshAmount</span> <span class="k">=</span> <span class="n">tokenRefreshAmount</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">permitTokens</span> <span class="k">=</span> <span class="n">maxAvailableTokens</span><span class="o">;</span>

    <span class="k">this</span><span class="o">.</span><span class="n">replenishTimer</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">scheduler</span><span class="o">().</span><span class="n">schedule</span><span class="o">(</span>
      <span class="k">this</span><span class="o">.</span><span class="n">tokenRefreshPeriod</span><span class="o">,</span>
      <span class="k">this</span><span class="o">.</span><span class="n">tokenRefreshPeriod</span><span class="o">,</span>
      <span class="n">self</span><span class="o">(),</span>
      <span class="nc">REPLENISH_TOKENS</span><span class="o">,</span>
      <span class="n">context</span><span class="o">().</span><span class="n">system</span><span class="o">().</span><span class="n">dispatcher</span><span class="o">(),</span>
      <span class="n">self</span><span class="o">());</span>

    <span class="n">receive</span><span class="o">(</span><span class="n">open</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="nc">PartialFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">BoxedUnit</span><span class="o">&gt;</span> <span class="n">open</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">ReceiveBuilder</span>
      <span class="o">.</span><span class="k">match</span><span class="o">(</span><span class="nc">ReplenishTokens</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">rt</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">permitTokens</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="n">permitTokens</span> <span class="o">+</span> <span class="n">tokenRefreshAmount</span><span class="o">,</span> <span class="n">maxAvailableTokens</span><span class="o">);</span>
      <span class="o">})</span>
      <span class="o">.</span><span class="k">match</span><span class="o">(</span><span class="nc">WantToPass</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">wtp</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">permitTokens</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">sender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="nc">MAY_PASS</span><span class="o">,</span> <span class="n">self</span><span class="o">());</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">permitTokens</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">closed</span><span class="o">());</span>
        <span class="o">}</span>
      <span class="o">}).</span><span class="n">build</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nc">PartialFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">BoxedUnit</span><span class="o">&gt;</span> <span class="n">closed</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">ReceiveBuilder</span>
      <span class="o">.</span><span class="k">match</span><span class="o">(</span><span class="nc">ReplenishTokens</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">rt</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">permitTokens</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="n">permitTokens</span> <span class="o">+</span> <span class="n">tokenRefreshAmount</span><span class="o">,</span> <span class="n">maxAvailableTokens</span><span class="o">);</span>
        <span class="n">releaseWaiting</span><span class="o">();</span>
      <span class="o">})</span>
      <span class="o">.</span><span class="k">match</span><span class="o">(</span><span class="nc">WantToPass</span><span class="o">.</span><span class="n">class</span><span class="o">,</span> <span class="n">wtp</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">waitQueue</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">sender</span><span class="o">());</span>
      <span class="o">})</span>
      <span class="o">.</span><span class="n">build</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="n">void</span> <span class="n">releaseWaiting</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ActorRef</span><span class="o">&gt;</span> <span class="n">toBeReleased</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">permitTokens</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">int</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">permitTokens</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">waitQueue</span><span class="o">.</span><span class="n">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">toBeReleased</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">waitQueue</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="n">permitTokens</span> <span class="o">-=</span> <span class="n">toBeReleased</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>
    <span class="n">toBeReleased</span><span class="o">.</span><span class="n">stream</span><span class="o">().</span><span class="n">forEach</span><span class="o">(</span><span class="n">ref</span> <span class="o">-&gt;</span> <span class="n">ref</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">MAY_PASS</span><span class="o">,</span> <span class="n">self</span><span class="o">()));</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">permitTokens</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">context</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">open</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">postStop</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">replenishTimer</span><span class="o">.</span><span class="n">cancel</span><span class="o">();</span>
    <span class="n">waitQueue</span><span class="o">.</span><span class="n">stream</span><span class="o">().</span><span class="n">forEach</span><span class="o">(</span><span class="n">ref</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="n">ref</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="k">new</span> <span class="nc">Status</span><span class="o">.</span><span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">&quot;limiter stopped&quot;</span><span class="o">)),</span> <span class="n">self</span><span class="o">());</span>
    <span class="o">});</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To create a Flow that uses this global limiter actor we use the <tt class="docutils literal"><span class="pre">mapAsync</span></tt> function with the combination of the <tt class="docutils literal"><span class="pre">ask</span></tt>
pattern. We also define a timeout, so if a reply is not received during the configured maximum wait period the returned
future from <tt class="docutils literal"><span class="pre">ask</span></tt> will fail, which will fail the corresponding stream as well.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nc">Flow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">limitGlobal</span><span class="o">(</span><span class="nc">ActorRef</span> <span class="n">limiter</span><span class="o">,</span> <span class="nc">FiniteDuration</span> <span class="n">maxAllowedWait</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">final</span> <span class="n">int</span> <span class="n">parallelism</span> <span class="k">=</span> <span class="mi">4</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">Flow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">f</span> <span class="k">=</span> <span class="nc">Flow</span><span class="o">.</span><span class="n">create</span><span class="o">();</span>

  <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">mapAsync</span><span class="o">(</span><span class="n">parallelism</span><span class="o">,</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">final</span> <span class="nc">Timeout</span> <span class="n">triggerTimeout</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Timeout</span><span class="o">(</span><span class="n">maxAllowedWait</span><span class="o">);</span>
    <span class="k">final</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">limiterTriggerFuture</span> <span class="k">=</span>
      <span class="nc">PatternsCS</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="n">limiter</span><span class="o">,</span> <span class="nc">Limiter</span><span class="o">.</span><span class="nc">WANT_TO_PASS</span><span class="o">,</span> <span class="n">triggerTimeout</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">limiterTriggerFuture</span><span class="o">.</span><span class="n">thenApplyAsync</span><span class="o">(</span><span class="n">response</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">,</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">());</span>
  <span class="o">});</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The global actor used for limiting introduces a global bottleneck. You might want to assign a dedicated dispatcher
for this actor.</p>
</div>
</div>
</div>
<div class="section" id="working-with-io">
<h2>Working with IO</h2>
<div class="section" id="chunking-up-a-stream-of-bytestrings-into-limited-size-bytestrings">
<h3>Chunking up a stream of ByteStrings into limited size ByteStrings</h3>
<p><strong>Situation:</strong> Given a stream of ByteStrings we want to produce a stream of ByteStrings containing the same bytes in
the same sequence, but capping the size of ByteStrings. In other words we want to slice up ByteStrings into smaller
chunks if they exceed a size threshold.</p>
<p>This can be achieved with a single <tt class="xref py py-class docutils literal"><span class="pre">GraphStage</span></tt>. The main logic of our stage is in <tt class="docutils literal"><span class="pre">emitChunk()</span></tt>
which implements the following logic:</p>
<ul class="simple">
<li>if the buffer is empty, and upstream is not closed we pull for more bytes, if it is closed we complete</li>
<li>if the buffer is nonEmpty, we split it according to the <tt class="docutils literal"><span class="pre">chunkSize</span></tt>. This will give a next chunk that we will emit,
and an empty or nonempty remaining buffer.</li>
</ul>
<p>Both <tt class="docutils literal"><span class="pre">onPush()</span></tt> and <tt class="docutils literal"><span class="pre">onPull()</span></tt> calls <tt class="docutils literal"><span class="pre">emitChunk()</span></tt> the only difference is that the push handler also stores
the incoming chunk by appending to the end of the buffer.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Chunker</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">final</span> <span class="n">int</span> <span class="n">chunkSize</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Chunker.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Chunker.out&quot;</span><span class="o">);</span>
  <span class="k">private</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="n">public</span> <span class="nc">Chunker</span><span class="o">(</span><span class="n">int</span> <span class="n">chunkSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">chunkSize</span> <span class="k">=</span> <span class="n">chunkSize</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">private</span> <span class="nc">ByteString</span> <span class="n">buffer</span> <span class="k">=</span> <span class="nc">ByteString</span><span class="o">.</span><span class="n">empty</span><span class="o">();</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">(){</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isClosed</span><span class="o">(</span><span class="n">in</span><span class="o">))</span> <span class="n">emitChunk</span><span class="o">();</span>
            <span class="k">else</span> <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>

        <span class="o">});</span>

        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>

          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="nc">ByteString</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="n">buffer</span> <span class="k">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
            <span class="n">emitChunk</span><span class="o">();</span>
          <span class="o">}</span>

          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onUpstreamFinish</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span> <span class="n">completeStage</span><span class="o">();</span>
            <span class="k">else</span> <span class="o">{</span>
              <span class="c1">// There are elements left in buffer, so</span>
              <span class="c1">// we keep accepting downstream pulls and push from buffer until emptied.</span>
              <span class="c1">//</span>
              <span class="c1">// It might be though, that the upstream finished while it was pulled, in which</span>
              <span class="c1">// case we will not get an onPull from the downstream, because we already had one.</span>
              <span class="c1">// In that case we need to emit from the buffer.</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">isAvailable</span><span class="o">(</span><span class="n">out</span><span class="o">))</span> <span class="n">emitChunk</span><span class="o">();</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>

      <span class="k">private</span> <span class="n">void</span> <span class="n">emitChunk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">isClosed</span><span class="o">(</span><span class="n">in</span><span class="o">))</span> <span class="n">completeStage</span><span class="o">();</span>
          <span class="k">else</span> <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="nc">Tuple2</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">split</span> <span class="k">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">splitAt</span><span class="o">(</span><span class="n">chunkSize</span><span class="o">);</span>
          <span class="nc">ByteString</span> <span class="n">chunk</span> <span class="k">=</span> <span class="n">split</span><span class="o">.</span><span class="n">_1</span><span class="o">();</span>
          <span class="n">buffer</span> <span class="k">=</span> <span class="n">split</span><span class="o">.</span><span class="n">_2</span><span class="o">();</span>
          <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">chunk</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Source</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">chunksStream</span> <span class="k">=</span>
  <span class="n">rawBytes</span><span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="k">new</span> <span class="nc">Chunker</span><span class="o">(</span><span class="nc">CHUNK_LIMIT</span><span class="o">));</span>
</pre></div>
</div>
</div>
<div class="section" id="limit-the-number-of-bytes-passing-through-a-stream-of-bytestrings">
<h3>Limit the number of bytes passing through a stream of ByteStrings</h3>
<p><strong>Situation:</strong> Given a stream of ByteStrings we want to fail the stream if more than a given maximum of bytes has been
consumed.</p>
<p>This recipe uses a <tt class="xref py py-class docutils literal"><span class="pre">GraphStage</span></tt> to implement the desired feature. In the only handler we override,
<tt class="docutils literal"><span class="pre">onPush()</span></tt> we just update a counter and see if it gets larger than <tt class="docutils literal"><span class="pre">maximumBytes</span></tt>. If a violation happens
we signal failure, otherwise we forward the chunk we have received.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ByteLimiter</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="k">final</span> <span class="n">long</span> <span class="n">maximumBytes</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;ByteLimiter.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.&lt;</span><span class="nc">ByteString</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;ByteLimiter.out&quot;</span><span class="o">);</span>
  <span class="k">private</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="n">public</span> <span class="nc">ByteLimiter</span><span class="o">(</span><span class="n">long</span> <span class="n">maximumBytes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">maximumBytes</span> <span class="k">=</span> <span class="n">maximumBytes</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">private</span> <span class="n">int</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="nc">ByteString</span> <span class="n">chunk</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">maximumBytes</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">failStage</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">&quot;Too much bytes&quot;</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">chunk</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>

    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">limiter</span> <span class="k">=</span>
  <span class="nc">Flow</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">ByteString</span><span class="o">.</span><span class="n">class</span><span class="o">).</span><span class="n">via</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteLimiter</span><span class="o">(</span><span class="nc">SIZE_LIMIT</span><span class="o">));</span>
</pre></div>
</div>
</div>
<div class="section" id="compact-bytestrings-in-a-stream-of-bytestrings">
<h3>Compact ByteStrings in a stream of ByteStrings</h3>
<p><strong>Situation:</strong> After a long stream of transformations, due to their immutable, structural sharing nature ByteStrings may
refer to multiple original ByteString instances unnecessarily retaining memory. As the final step of a transformation
chain we want to have clean copies that are no longer referencing the original ByteStrings.</p>
<p>The recipe is a simple use of map, calling the <tt class="docutils literal"><span class="pre">compact()</span></tt> method of the <tt class="xref py py-class docutils literal"><span class="pre">ByteString</span></tt> elements. This does
copying of the underlying arrays, so this should be the last element of a long chain if used.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Source</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">compacted</span> <span class="k">=</span> <span class="n">rawBytes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">ByteString</span><span class="o">::</span><span class="n">compact</span><span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="injecting-keep-alive-messages-into-a-stream-of-bytestrings">
<h3>Injecting keep-alive messages into a stream of ByteStrings</h3>
<p><strong>Situation:</strong> Given a communication channel expressed as a stream of ByteStrings we want to inject keep-alive messages
but only if this does not interfere with normal traffic.</p>
<p>There is a built-in operation that allows to do this directly:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Flow</span><span class="o">&lt;</span><span class="nc">ByteString</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">keepAliveInject</span> <span class="k">=</span>
  <span class="nc">Flow</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">ByteString</span><span class="o">.</span><span class="n">class</span><span class="o">).</span><span class="n">keepAlive</span><span class="o">(</span>
      <span class="n">scala</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="nc">SECONDS</span><span class="o">),</span>
      <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">keepAliveMessage</span><span class="o">);</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>