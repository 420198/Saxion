


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Persistence &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Actors" href="index-actors.html" />
    <link rel="next" title="Persistence - Schema Evolution" href="persistence-schema-evolution.html" />
    <link rel="prev" title="FSM" href="fsm.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Persistence</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="persistence-schema-evolution.html">Persistence - Schema Evolution</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="fsm.html">FSM</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="persistence">
<span id="persistence-scala"></span><h1>Persistence</h1>
<p>Akka persistence enables stateful actors to persist their internal state so that it can be recovered when an actor
is started, restarted after a JVM crash or by a supervisor, or migrated in a cluster. The key concept behind Akka
persistence is that only changes to an actor's internal state are persisted but never its current state directly
(except for optional snapshots). These changes are only ever appended to storage, nothing is ever mutated, which
allows for very high transaction rates and efficient replication. Stateful actors are recovered by replaying stored
changes to these actors from which they can rebuild internal state. This can be either the full history of changes
or starting from a snapshot which can dramatically reduce recovery times. Akka persistence also provides point-to-point
communication with at-least-once message delivery semantics.</p>
<p>Akka persistence is inspired by and the official replacement of the <a class="reference external" href="https://github.com/eligosource/eventsourced">eventsourced</a> library. It follows the same
concepts and architecture of <a class="reference external" href="https://github.com/eligosource/eventsourced">eventsourced</a> but significantly differs on API and implementation level. See also
<a class="reference internal" href="../project/migration-guide-eventsourced-2.3.x.html#migration-eventsourced-2-3"><em>Migration Guide Eventsourced to Akka Persistence 2.3.x</em></a></p>
<div class="section" id="dependencies">
<h2>Dependencies</h2>
<p>Akka persistence is a separate jar file. Make sure that you have the following dependency in your project:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-persistence&quot;</span> <span class="o">%</span> <span class="s">&quot;2.4.11&quot;</span>
</pre></div>
</div>
<p>The Akka persistence extension comes with few built-in persistence plugins, including
in-memory heap based journal, local file-system based snapshot-store and LevelDB based journal.</p>
<p>LevelDB based plugins will require the following additional dependency declaration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;org.iq80.leveldb&quot;</span>            <span class="o">%</span> <span class="s">&quot;leveldb&quot;</span>          <span class="o">%</span> <span class="s">&quot;0.7&quot;</span>
<span class="s">&quot;org.fusesource.leveldbjni&quot;</span>   <span class="o">%</span> <span class="s">&quot;leveldbjni-all&quot;</span>   <span class="o">%</span> <span class="s">&quot;1.8&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="architecture">
<h2>Architecture</h2>
<ul class="simple">
<li><em>PersistentActor</em>: Is a persistent, stateful actor. It is able to persist events to a journal and can react to
them in a thread-safe manner. It can be used to implement both <em>command</em> as well as <em>event sourced</em> actors.
When a persistent actor is started or restarted, journaled messages are replayed to that actor so that it can
recover internal state from these messages.</li>
<li><em>PersistentView</em>: A view is a persistent, stateful actor that receives journaled messages that have been written by another
persistent actor. A view itself does not journal new messages, instead, it updates internal state only from a persistent actor's
replicated message stream.</li>
<li><em>AtLeastOnceDelivery</em>: To send messages with at-least-once delivery semantics to destinations, also in
case of sender and receiver JVM crashes.</li>
<li><em>AsyncWriteJournal</em>: A journal stores the sequence of messages sent to a persistent actor. An application can control which messages
are journaled and which are received by the persistent actor without being journaled. Journal maintains <em>highestSequenceNr</em> that is increased on each message.
The storage backend of a journal is pluggable. The persistence extension comes with a &quot;leveldb&quot; journal plugin, which writes to the local filesystem.
Replicated journals are available as <a class="reference external" href="http://akka.io/community/">Community plugins</a>.</li>
<li><em>Snapshot store</em>: A snapshot store persists snapshots of a persistent actor's or a view's internal state. Snapshots are
used for optimizing recovery times. The storage backend of a snapshot store is pluggable.
The persistence extension comes with a &quot;local&quot; snapshot storage plugin, which writes to the local filesystem.
Replicated snapshot stores are available as <a class="reference external" href="http://akka.io/community/">Community plugins</a>.</li>
</ul>
</div>
<div class="section" id="event-sourcing">
<span id="event-sourcing-scala"></span><h2>Event sourcing</h2>
<p>The basic idea behind <a class="reference external" href="http://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a> is quite simple. A persistent actor receives a (non-persistent) command
which is first validated if it can be applied to the current state. Here validation can mean anything, from simple
inspection of a command message's fields up to a conversation with several external services, for example.
If validation succeeds, events are generated from the command, representing the effect of the command. These events
are then persisted and, after successful persistence, used to change the actor's state. When the persistent actor
needs to be recovered, only the persisted events are replayed of which we know that they can be successfully applied.
In other words, events cannot fail when being replayed to a persistent actor, in contrast to commands. Event sourced
actors may of course also process commands that do not change application state such as query commands for example.</p>
<p>Akka persistence supports event sourcing with the <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> trait. An actor that extends this trait uses the
<tt class="docutils literal"><span class="pre">persist</span></tt> method to persist and handle events. The behavior of a <tt class="docutils literal"><span class="pre">PersistentActor</span></tt>
is defined by implementing <tt class="docutils literal"><span class="pre">receiveRecover</span></tt> and <tt class="docutils literal"><span class="pre">receiveCommand</span></tt>. This is demonstrated in the following example.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">akka.persistence._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Cmd</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Evt</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleState</span><span class="o">(</span><span class="n">events</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">updated</span><span class="o">(</span><span class="n">evt</span><span class="k">:</span> <span class="kt">Evt</span><span class="o">)</span><span class="k">:</span> <span class="kt">ExampleState</span> <span class="o">=</span> <span class="n">copy</span><span class="o">(</span><span class="n">evt</span><span class="o">.</span><span class="n">data</span> <span class="o">::</span> <span class="n">events</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">size</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">length</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">ExamplePersistentActor</span> <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span> <span class="k">=</span> <span class="s">&quot;sample-id-1&quot;</span>

  <span class="k">var</span> <span class="n">state</span> <span class="k">=</span> <span class="nc">ExampleState</span><span class="o">()</span>

  <span class="k">def</span> <span class="n">updateState</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Evt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">state</span> <span class="k">=</span> <span class="n">state</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">numEvents</span> <span class="k">=</span>
    <span class="n">state</span><span class="o">.</span><span class="n">size</span>

  <span class="k">val</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">evt</span><span class="k">:</span> <span class="kt">Evt</span>                                 <span class="o">=&gt;</span> <span class="n">updateState</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">SnapshotOffer</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">snapshot</span><span class="k">:</span> <span class="kt">ExampleState</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">state</span> <span class="k">=</span> <span class="n">snapshot</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Cmd</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">persist</span><span class="o">(</span><span class="nc">Evt</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;${data}-${numEvents}&quot;</span><span class="o">))(</span><span class="n">updateState</span><span class="o">)</span>
      <span class="n">persist</span><span class="o">(</span><span class="nc">Evt</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;${data}-${numEvents + 1}&quot;</span><span class="o">))</span> <span class="o">{</span> <span class="n">event</span> <span class="k">=&gt;</span>
        <span class="n">updateState</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">eventStream</span><span class="o">.</span><span class="n">publish</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="s">&quot;snap&quot;</span>  <span class="k">=&gt;</span> <span class="n">saveSnapshot</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
    <span class="k">case</span> <span class="s">&quot;print&quot;</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>The example defines two data types, <tt class="docutils literal"><span class="pre">Cmd</span></tt> and <tt class="docutils literal"><span class="pre">Evt</span></tt> to represent commands and events, respectively. The
<tt class="docutils literal"><span class="pre">state</span></tt> of the <tt class="docutils literal"><span class="pre">ExamplePersistentActor</span></tt> is a list of persisted event data contained in <tt class="docutils literal"><span class="pre">ExampleState</span></tt>.</p>
<p>The persistent actor's <tt class="docutils literal"><span class="pre">receiveRecover</span></tt> method defines how <tt class="docutils literal"><span class="pre">state</span></tt> is updated during recovery by handling <tt class="docutils literal"><span class="pre">Evt</span></tt>
and <tt class="docutils literal"><span class="pre">SnapshotOffer</span></tt> messages. The persistent actor's <tt class="docutils literal"><span class="pre">receiveCommand</span></tt> method is a command handler. In this example,
a command is handled by generating two events which are then persisted and handled. Events are persisted by calling
<tt class="docutils literal"><span class="pre">persist</span></tt> with an event (or a sequence of events) as first argument and an event handler as second argument.</p>
<p>The <tt class="docutils literal"><span class="pre">persist</span></tt> method persists events asynchronously and the event handler is executed for successfully persisted
events. Successfully persisted events are internally sent back to the persistent actor as individual messages that trigger
event handler executions. An event handler may close over persistent actor state and mutate it. The sender of a persisted
event is the sender of the corresponding command. This allows event handlers to reply to the sender of a command
(not shown).</p>
<p>The main responsibility of an event handler is changing persistent actor state using event data and notifying others
about successful state changes by publishing events.</p>
<p>When persisting events with <tt class="docutils literal"><span class="pre">persist</span></tt> it is guaranteed that the persistent actor will not receive further commands between
the <tt class="docutils literal"><span class="pre">persist</span></tt> call and the execution(s) of the associated event handler. This also holds for multiple <tt class="docutils literal"><span class="pre">persist</span></tt>
calls in context of a single command. Incoming messages are <a class="reference internal" href="#internal-stash-scala"><em>stashed</em></a> until the <tt class="docutils literal"><span class="pre">persist</span></tt>
is completed.</p>
<p>If persistence of an event fails, <tt class="docutils literal"><span class="pre">onPersistFailure</span></tt> will be invoked (logging the error by default),
and the actor will unconditionally be stopped. If persistence of an event is rejected before it is
stored, e.g. due to serialization error, <tt class="docutils literal"><span class="pre">onPersistRejected</span></tt> will be invoked (logging a warning
by default) and the actor continues with the next message.</p>
<p>The easiest way to run this example yourself is to download <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a>
and open the tutorial named <a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-persistence-scala">Akka Persistence Samples with Scala</a>.
It contains instructions on how to run the <tt class="docutils literal"><span class="pre">PersistentActorExample</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It's also possible to switch between different command handlers during normal processing and recovery
with <tt class="docutils literal"><span class="pre">context.become()</span></tt> and <tt class="docutils literal"><span class="pre">context.unbecome()</span></tt>. To get the actor into the same state after
recovery you need to take special care to perform the same state transitions with <tt class="docutils literal"><span class="pre">become</span></tt> and
<tt class="docutils literal"><span class="pre">unbecome</span></tt> in the <tt class="docutils literal"><span class="pre">receiveRecover</span></tt> method as you would have done in the command handler.
Note that when using <tt class="docutils literal"><span class="pre">become</span></tt> from <tt class="docutils literal"><span class="pre">receiveRecover</span></tt> it will still only use the <tt class="docutils literal"><span class="pre">receiveRecover</span></tt>
behavior when replaying the events. When replay is completed it will use the new behavior.</p>
</div>
<div class="section" id="persistence-id-scala">
<span id="identifiers"></span><h3>Identifiers</h3>
<p>A persistent actor must have an identifier that doesn't change across different actor incarnations.
The identifier must be defined with the <tt class="docutils literal"><span class="pre">persistenceId</span></tt> method.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span> <span class="k">=</span> <span class="s">&quot;my-stable-persistence-id&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">persistenceId</span></tt> must be unique to a given entity in the journal (database table/keyspace).
When replaying messages persisted to the journal, you query messages with a <tt class="docutils literal"><span class="pre">persistenceId</span></tt>.
So, if two different entities share the same <tt class="docutils literal"><span class="pre">persistenceId</span></tt>, message-replaying
behavior is corrupted.</p>
</div>
</div>
<div class="section" id="recovery">
<span id="recovery-scala"></span><h3>Recovery</h3>
<p>By default, a persistent actor is automatically recovered on start and on restart by replaying journaled messages.
New messages sent to a persistent actor during recovery do not interfere with replayed messages.
They are cached and received by a persistent actor after recovery phase completes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Accessing the <tt class="docutils literal"><span class="pre">sender()</span></tt> for replayed messages will always result in a <tt class="docutils literal"><span class="pre">deadLetters</span></tt> reference,
as the original sender is presumed to be long gone. If you indeed have to notify an actor during
recovery in the future, store its <tt class="docutils literal"><span class="pre">ActorPath</span></tt> explicitly in your persisted events.</p>
</div>
<div class="section" id="recovery-customization">
<h4>Recovery customization</h4>
<p>Applications may also customise how recovery is performed by returning a customised <tt class="docutils literal"><span class="pre">Recovery</span></tt> object
in the <tt class="docutils literal"><span class="pre">recovery</span></tt> method of a <tt class="docutils literal"><span class="pre">PersistentActor</span></tt>, for example setting an upper bound to the replay
which allows the actor to be replayed to a certain point &quot;in the past&quot; instead to its most up to date state:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">recovery</span> <span class="k">=</span> <span class="nc">Recovery</span><span class="o">(</span><span class="n">toSequenceNr</span> <span class="k">=</span> <span class="mi">457L</span><span class="o">)</span>
</pre></div>
</div>
<p>Recovery can be disabled by returning <tt class="docutils literal"><span class="pre">Recovery.none()</span></tt> in the <tt class="docutils literal"><span class="pre">recovery</span></tt> method of a <tt class="docutils literal"><span class="pre">PersistentActor</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">recovery</span> <span class="k">=</span> <span class="nc">Recovery</span><span class="o">.</span><span class="n">none</span>
</pre></div>
</div>
</div>
<div class="section" id="recovery-status">
<h4>Recovery status</h4>
<p>A persistent actor can query its own recovery status via the methods</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">recoveryRunning</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">recoveryFinished</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div>
</div>
<p>Sometimes there is a need for performing additional initialization when the
recovery has completed before processing any other message sent to the persistent actor.
The persistent actor will receive a special <tt class="xref py py-class docutils literal"><span class="pre">RecoveryCompleted</span></tt> message right after recovery
and before any other received messages.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">RecoveryCompleted</span> <span class="k">=&gt;</span>
  <span class="c1">// perform init after recovery, before any other messages</span>
  <span class="c1">//...</span>
  <span class="k">case</span> <span class="n">evt</span>               <span class="k">=&gt;</span> <span class="c1">//...</span>
<span class="o">}</span>

<span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="c1">//...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If there is a problem with recovering the state of the actor from the journal, <tt class="docutils literal"><span class="pre">onRecoveryFailure</span></tt>
is called (logging the error by default) and the actor will be stopped.</p>
</div>
</div>
<div class="section" id="internal-stash">
<span id="internal-stash-scala"></span><h3>Internal stash</h3>
<p>The persistent actor has a private <a class="reference internal" href="actors.html#stash-scala"><em>stash</em></a> for internally caching incoming messages during
<a class="reference internal" href="#recovery-scala"><em>recovery</em></a> or the <tt class="docutils literal"><span class="pre">persist\persistAll</span></tt> method persisting events. You can still use/inherit from the
<tt class="docutils literal"><span class="pre">Stash</span></tt> interface. The internal stash cooperates with the normal stash by hooking into <tt class="docutils literal"><span class="pre">unstashAll</span></tt> method and
making sure messages are unstashed properly to the internal stash to maintain ordering guarantees.</p>
<p>You should be careful to not send more messages to a persistent actor than it can keep up with, otherwise the number
of stashed messages will grow without bounds. It can be wise to protect against <tt class="docutils literal"><span class="pre">OutOfMemoryError</span></tt> by defining a
maximum stash capacity in the mailbox configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">default</span><span class="o">-</span><span class="n">mailbox</span><span class="o">.</span><span class="n">stash</span><span class="o">-</span><span class="n">capacity</span><span class="k">=</span><span class="mi">10000</span>
</pre></div>
</div>
<p>Note that the stash capacity is per actor. If you have many persistent actors, e.g. when using cluster sharding,
you may need to define a small stash capacity to ensure that the total number of stashed messages in the system
don't consume too much memory. Additionally, The persistent actor defines three strategies to handle failure when the
internal stash capacity is exceeded. The default overflow strategy is the <tt class="docutils literal"><span class="pre">ThrowOverflowExceptionStrategy</span></tt>, which
discards the current received message and throws a <tt class="docutils literal"><span class="pre">StashOverflowException</span></tt>, causing actor restart if default
supervision strategy is used. you can override the <tt class="docutils literal"><span class="pre">internalStashOverflowStrategy</span></tt> method to return
<tt class="docutils literal"><span class="pre">DiscardToDeadLetterStrategy</span></tt> or <tt class="docutils literal"><span class="pre">ReplyToStrategy</span></tt> for any &quot;individual&quot; persistent actor, or define the &quot;default&quot;
for all persistent actors by providing FQCN, which must be a subclass of <tt class="docutils literal"><span class="pre">StashOverflowStrategyConfigurator</span></tt>, in the
persistence configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">internal</span><span class="o">-</span><span class="n">stash</span><span class="o">-</span><span class="n">overflow</span><span class="o">-</span><span class="n">strategy</span><span class="k">=</span>
  <span class="s">&quot;akka.persistence.ThrowExceptionConfigurator&quot;</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">DiscardToDeadLetterStrategy</span></tt> strategy also has a pre-packaged companion configurator
<tt class="docutils literal"><span class="pre">akka.persistence.DiscardConfigurator</span></tt>.</p>
<p>You can also query default strategy via the Akka persistence extension singleton:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Persistence</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">defaultInternalStashOverflowStrategy</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The bounded mailbox should be avoided in the persistent actor, by which the messages come from storage backends may
be discarded. You can use bounded stash instead of it.</p>
</div>
</div>
<div class="section" id="relaxed-local-consistency-requirements-and-high-throughput-use-cases">
<span id="persist-async-scala"></span><h3>Relaxed local consistency requirements and high throughput use-cases</h3>
<p>If faced with relaxed local consistency requirements and high throughput demands sometimes <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> and its
<tt class="docutils literal"><span class="pre">persist</span></tt> may not be enough in terms of consuming incoming Commands at a high rate, because it has to wait until all
Events related to a given Command are processed in order to start processing the next Command. While this abstraction is
very useful for most cases, sometimes you may be faced with relaxed requirements about consistency – for example you may
want to process commands as fast as you can, assuming that the Event will eventually be persisted and handled properly in
the background, retroactively reacting to persistence failures if needed.</p>
<p>The <tt class="docutils literal"><span class="pre">persistAsync</span></tt> method provides a tool for implementing high-throughput persistent actors. It will <em>not</em>
stash incoming Commands while the Journal is still working on persisting and/or user code is executing event callbacks.</p>
<p>In the below example, the event callbacks may be called &quot;at any time&quot;, even after the next Command has been processed.
The ordering between events is still guaranteed (&quot;evt-b-1&quot; will be sent after &quot;evt-a-2&quot;, which will be sent after &quot;evt-a-1&quot; etc.).</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyPersistentActor</span> <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span> <span class="k">=</span> <span class="s">&quot;my-stable-persistence-id&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// handle recovery here</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">c</span>
      <span class="n">persistAsync</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;evt-$c-1&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">e</span> <span class="o">}</span>
      <span class="n">persistAsync</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;evt-$c-2&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">e</span> <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// usage</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;a&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;b&quot;</span>

<span class="c1">// possible order of received messages:</span>
<span class="c1">// a</span>
<span class="c1">// b</span>
<span class="c1">// evt-a-1</span>
<span class="c1">// evt-a-2</span>
<span class="c1">// evt-b-1</span>
<span class="c1">// evt-b-2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to implement the pattern known as &quot;<em>command sourcing</em>&quot; simply call <tt class="docutils literal"><span class="pre">persistAsync(cmd)(...)</span></tt> right away on all incoming
messages and handle them in the callback.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callback will not be invoked if the actor is restarted (or stopped) in between the call to
<tt class="docutils literal"><span class="pre">persistAsync</span></tt> and the journal has confirmed the write.</p>
</div>
</div>
<div class="section" id="deferring-actions-until-preceding-persist-handlers-have-executed">
<span id="defer-scala"></span><h3>Deferring actions until preceding persist handlers have executed</h3>
<p>Sometimes when working with <tt class="docutils literal"><span class="pre">persistAsync</span></tt> you may find that it would be nice to define some actions in terms of
''happens-after the previous <tt class="docutils literal"><span class="pre">persistAsync</span></tt> handlers have been invoked''. <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> provides an utility method
called <tt class="docutils literal"><span class="pre">deferAsync</span></tt>, which works similarly to <tt class="docutils literal"><span class="pre">persistAsync</span></tt> yet does not persist the passed in event. It is recommended to
use it for <em>read</em> operations, and actions which do not have corresponding events in your domain model.</p>
<p>Using this method is very similar to the persist family of methods, yet it does <strong>not</strong> persist the passed in event.
It will be kept in memory and used when invoking the handler.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyPersistentActor</span> <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span> <span class="k">=</span> <span class="s">&quot;my-stable-persistence-id&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// handle recovery here</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">c</span>
      <span class="n">persistAsync</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;evt-$c-1&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">e</span> <span class="o">}</span>
      <span class="n">persistAsync</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;evt-$c-2&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">e</span> <span class="o">}</span>
      <span class="n">deferAsync</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;evt-$c-3&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">e</span> <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Notice that the <tt class="docutils literal"><span class="pre">sender()</span></tt> is <strong>safe</strong> to access in the handler callback, and will be pointing to the original sender
of the command for which this <tt class="docutils literal"><span class="pre">deferAsync</span></tt> handler was called.</p>
<p>The calling side will get the responses in this (guaranteed) order:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;a&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;b&quot;</span>

<span class="c1">// order of received messages:</span>
<span class="c1">// a</span>
<span class="c1">// b</span>
<span class="c1">// evt-a-1</span>
<span class="c1">// evt-a-2</span>
<span class="c1">// evt-a-3</span>
<span class="c1">// evt-b-1</span>
<span class="c1">// evt-b-2</span>
<span class="c1">// evt-b-3</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callback will not be invoked if the actor is restarted (or stopped) in between the call to
<tt class="docutils literal"><span class="pre">deferAsync</span></tt> and the journal has processed and confirmed all preceding writes.</p>
</div>
</div>
<div class="section" id="nested-persist-calls">
<span id="nested-persist-calls-scala"></span><h3>Nested persist calls</h3>
<p>It is possible to call <tt class="docutils literal"><span class="pre">persist</span></tt> and <tt class="docutils literal"><span class="pre">persistAsync</span></tt> inside their respective callback blocks and they will properly
retain both the thread safety (including the right value of <tt class="docutils literal"><span class="pre">sender()</span></tt>) as well as stashing guarantees.</p>
<p>In general it is encouraged to create command handlers which do not need to resort to nested event persisting,
however there are situations where it may be useful. It is important to understand the ordering of callback execution in
those situations, as well as their implication on the stashing behaviour (that <tt class="docutils literal"><span class="pre">persist()</span></tt> enforces). In the following
example two persist calls are issued, and each of them issues another persist inside its callback:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
    <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">c</span>

    <span class="n">persist</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;$c-1-outer&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">outer1</span> <span class="k">=&gt;</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">outer1</span>
      <span class="n">persist</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;$c-1-inner&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">inner1</span> <span class="k">=&gt;</span>
        <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">inner1</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">persist</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;$c-2-outer&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">outer2</span> <span class="k">=&gt;</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">outer2</span>
      <span class="n">persist</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;$c-2-inner&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">inner2</span> <span class="k">=&gt;</span>
        <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">inner2</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>When sending two commands to this <tt class="docutils literal"><span class="pre">PersistentActor</span></tt>, the persist handlers will be executed in the following order:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;a&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;b&quot;</span>

<span class="c1">// order of received messages:</span>
<span class="c1">// a</span>
<span class="c1">// a-outer-1</span>
<span class="c1">// a-outer-2</span>
<span class="c1">// a-inner-1</span>
<span class="c1">// a-inner-2</span>
<span class="c1">// and only then process &quot;b&quot;</span>
<span class="c1">// b</span>
<span class="c1">// b-outer-1</span>
<span class="c1">// b-outer-2</span>
<span class="c1">// b-inner-1</span>
<span class="c1">// b-inner-2</span>
</pre></div>
</div>
<p>First the &quot;outer layer&quot; of persist calls is issued and their callbacks are applied. After these have successfully completed,
the inner callbacks will be invoked (once the events they are persisting have been confirmed to be persisted by the journal).
Only after all these handlers have been successfully invoked will the next command be delivered to the persistent Actor.
In other words, the stashing of incoming commands that is guaranteed by initially calling <tt class="docutils literal"><span class="pre">persist()</span></tt> on the outer layer
is extended until all nested <tt class="docutils literal"><span class="pre">persist</span></tt> callbacks have been handled.</p>
<p>It is also possible to nest <tt class="docutils literal"><span class="pre">persistAsync</span></tt> calls, using the same pattern:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
    <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">c</span>
    <span class="n">persistAsync</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="s">&quot;-outer-1&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">outer</span> <span class="k">=&gt;</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">outer</span>
      <span class="n">persistAsync</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="s">&quot;-inner-1&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">inner</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">inner</span> <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">persistAsync</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="s">&quot;-outer-2&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">outer</span> <span class="k">=&gt;</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">outer</span>
      <span class="n">persistAsync</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="s">&quot;-inner-2&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">inner</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">inner</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In this case no stashing is happening, yet events are still persisted and callbacks are executed in the expected order:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;a&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;b&quot;</span>

<span class="c1">// order of received messages:</span>
<span class="c1">// a</span>
<span class="c1">// b</span>
<span class="c1">// a-outer-1</span>
<span class="c1">// a-outer-2</span>
<span class="c1">// b-outer-1</span>
<span class="c1">// b-outer-2</span>
<span class="c1">// a-inner-1</span>
<span class="c1">// a-inner-2</span>
<span class="c1">// b-inner-1</span>
<span class="c1">// b-inner-2</span>

<span class="c1">// which can be seen as the following causal relationship:</span>
<span class="c1">// a -&gt; a-outer-1 -&gt; a-outer-2 -&gt; a-inner-1 -&gt; a-inner-2</span>
<span class="c1">// b -&gt; b-outer-1 -&gt; b-outer-2 -&gt; b-inner-1 -&gt; b-inner-2</span>
</pre></div>
</div>
<p>While it is possible to nest mixed <tt class="docutils literal"><span class="pre">persist</span></tt> and <tt class="docutils literal"><span class="pre">persistAsync</span></tt> with keeping their respective semantics
it is not a recommended practice, as it may lead to overly complex nesting.</p>
</div>
<div class="section" id="failures">
<span id="failures-scala"></span><h3>Failures</h3>
<p>If persistence of an event fails, <tt class="docutils literal"><span class="pre">onPersistFailure</span></tt> will be invoked (logging the error by default),
and the actor will unconditionally be stopped.</p>
<p>The reason that it cannot resume when persist fails is that it is unknown if the event was actually
persisted or not, and therefore it is in an inconsistent state. Restarting on persistent failures
will most likely fail anyway since the journal is probably unavailable. It is better to stop the
actor and after a back-off timeout start it again. The <tt class="docutils literal"><span class="pre">akka.pattern.BackoffSupervisor</span></tt> actor
is provided to support such restarts.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">childProps</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">MyPersistentActor</span><span class="o">]</span>
<span class="k">val</span> <span class="n">props</span> <span class="k">=</span> <span class="nc">BackoffSupervisor</span><span class="o">.</span><span class="n">props</span><span class="o">(</span>
  <span class="nc">Backoff</span><span class="o">.</span><span class="n">onStop</span><span class="o">(</span>
    <span class="n">childProps</span><span class="o">,</span>
    <span class="n">childName</span> <span class="k">=</span> <span class="s">&quot;myActor&quot;</span><span class="o">,</span>
    <span class="n">minBackoff</span> <span class="k">=</span> <span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
    <span class="n">maxBackoff</span> <span class="k">=</span> <span class="mf">30.</span><span class="n">seconds</span><span class="o">,</span>
    <span class="n">randomFactor</span> <span class="k">=</span> <span class="mf">0.2</span><span class="o">))</span>
<span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;mySupervisor&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>If persistence of an event is rejected before it is stored, e.g. due to serialization error,
<tt class="docutils literal"><span class="pre">onPersistRejected</span></tt> will be invoked (logging a warning by default), and the actor continues with
next message.</p>
<p>If there is a problem with recovering the state of the actor from the journal when the actor is
started, <tt class="docutils literal"><span class="pre">onRecoveryFailure</span></tt> is called (logging the error by default), and the actor will be stopped.</p>
</div>
<div class="section" id="atomic-writes">
<h3>Atomic writes</h3>
<p>Each event is of course stored atomically, but it is also possible to store several events atomically by
using the <tt class="docutils literal"><span class="pre">persistAll</span></tt> or <tt class="docutils literal"><span class="pre">persistAllAsync</span></tt> method. That means that all events passed to that method
are stored or none of them are stored if there is an error.</p>
<p>The recovery of a persistent actor will therefore never be done partially with only a subset of events persisted by
<cite>persistAll</cite>.</p>
<p>Some journals may not support atomic writes of several events and they will then reject the <tt class="docutils literal"><span class="pre">persistAll</span></tt>
command, i.e. <tt class="docutils literal"><span class="pre">onPersistRejected</span></tt> is called with an exception (typically <tt class="docutils literal"><span class="pre">UnsupportedOperationException</span></tt>).</p>
</div>
<div class="section" id="batch-writes">
<span id="id2"></span><h3>Batch writes</h3>
<p>In order to optimize throughput when using <tt class="docutils literal"><span class="pre">persistAsync</span></tt>, a persistent actor
internally batches events to be stored under high load before writing them to
the journal (as a single batch). The batch size is dynamically determined by
how many events are emitted during the time of a journal round-trip: after
sending a batch to the journal no further batch can be sent before confirmation
has been received that the previous batch has been written. Batch writes are never
timer-based which keeps latencies at a minimum.</p>
</div>
<div class="section" id="message-deletion">
<h3>Message deletion</h3>
<p>It is possible to delete all messages (journaled by a single persistent actor) up to a specified sequence number;
Persistent actors may call the <tt class="docutils literal"><span class="pre">deleteMessages</span></tt> method to this end.</p>
<p>Deleting messages in event sourcing based applications is typically either not used at all, or used in conjunction with
<a class="reference internal" href="#snapshots"><em>snapshotting</em></a>, i.e. after a snapshot has been successfully stored, a <tt class="docutils literal"><span class="pre">deleteMessages(toSequenceNr)</span></tt>
up until the sequence number of the data held by that snapshot can be issued to safely delete the previous events
while still having access to the accumulated state during replays - by loading the snapshot.</p>
<p>The result of the <tt class="docutils literal"><span class="pre">deleteMessages</span></tt> request is signaled to the persistent actor with a <tt class="docutils literal"><span class="pre">DeleteMessagesSuccess</span></tt>
message if the delete was successful or a <tt class="docutils literal"><span class="pre">DeleteMessagesFailure</span></tt> message if it failed.</p>
<p>Message deletion doesn't affect the highest sequence number of the journal, even if all messages were deleted from it after <tt class="docutils literal"><span class="pre">deleteMessages</span></tt> invocation.</p>
</div>
<div class="section" id="persistence-status-handling">
<h3>Persistence status handling</h3>
<p>Persisting, deleting, and replaying messages can either succeed or fail.</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="23%" />
<col width="24%" />
<col width="27%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method</strong></td>
<td><strong>Success</strong></td>
<td><strong>Failure / Rejection</strong></td>
<td><strong>After failure handler invoked</strong></td>
</tr>
<tr class="row-even"><td rowspan="2"><tt class="docutils literal"><span class="pre">persist</span></tt> / <tt class="docutils literal"><span class="pre">persistAsync</span></tt></td>
<td rowspan="2">persist handler invoked</td>
<td><tt class="docutils literal"><span class="pre">onPersistFailure</span></tt></td>
<td>Actor is stopped.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">onPersistRejected</span></tt></td>
<td>No automatic actions.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">recovery</span></tt></td>
<td><tt class="docutils literal"><span class="pre">RecoveryCompleted</span></tt></td>
<td><tt class="docutils literal"><span class="pre">onRecoveryFailure</span></tt></td>
<td>Actor is stopped.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">deleteMessages</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DeleteMessagesSuccess</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DeleteMessagesFailure</span></tt></td>
<td>No automatic actions.</td>
</tr>
</tbody>
</table>
<p>The most important operations (<tt class="docutils literal"><span class="pre">persist</span></tt> and <tt class="docutils literal"><span class="pre">recovery</span></tt>) have failure handlers modelled as explicit callbacks which
the user can override in the <tt class="docutils literal"><span class="pre">PersistentActor</span></tt>. The default implementations of these handlers emit a log message
(<tt class="docutils literal"><span class="pre">error</span></tt> for persist/recovery failures, and <tt class="docutils literal"><span class="pre">warning</span></tt> for others), logging the failure cause and information about
which message caused the failure.</p>
<p>For critical failures, such as recovery or persisting events failing, the persistent actor will be stopped after the failure
handler is invoked. This is because if the underlying journal implementation is signalling persistence failures it is most
likely either failing completely or overloaded and restarting right-away and trying to persist the event again will most
likely not help the journal recover – as it would likely cause a <a class="reference external" href="https://en.wikipedia.org/wiki/Thundering_herd_problem">Thundering herd problem</a>, as many persistent actors
would restart and try to persist their events again. Instead, using a <tt class="docutils literal"><span class="pre">BackoffSupervisor</span></tt> (as described in <a class="reference internal" href="#failures-scala"><em>Failures</em></a>) which
implements an exponential-backoff strategy which allows for more breathing room for the journal to recover between
restarts of the persistent actor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Journal implementations may choose to implement a retry mechanism, e.g. such that only after a write fails N number
of times a persistence failure is signalled back to the user. In other words, once a journal returns a failure,
it is considered <em>fatal</em> by Akka Persistence, and the persistent actor which caused the failure will be stopped.</p>
<p class="last">Check the documentation of the journal implementation you are using for details if/how it is using this technique.</p>
</div>
</div>
<div class="section" id="safely-shutting-down-persistent-actors">
<span id="safe-shutdown-scala"></span><h3>Safely shutting down persistent actors</h3>
<p>Special care should be given when shutting down persistent actors from the outside.
With normal Actors it is often acceptable to use the special <a class="reference internal" href="actors.html#poison-pill-scala"><em>PoisonPill</em></a> message
to signal to an Actor that it should stop itself once it receives this message – in fact this message is handled
automatically by Akka, leaving the target actor no way to refuse stopping itself when given a poison pill.</p>
<p>This can be dangerous when used with <tt class="xref py py-class docutils literal"><span class="pre">PersistentActor</span></tt> due to the fact that incoming commands are <em>stashed</em> while
the persistent actor is awaiting confirmation from the Journal that events have been written when <tt class="docutils literal"><span class="pre">persist()</span></tt> was used.
Since the incoming commands will be drained from the Actor's mailbox and put into its internal stash while awaiting the
confirmation (thus, before calling the persist handlers) the Actor <strong>may receive and (auto)handle the PoisonPill
before it processes the other messages which have been put into its stash</strong>, causing a pre-mature shutdown of the Actor.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Consider using explicit shut-down messages instead of <tt class="xref py py-class docutils literal"><span class="pre">PoisonPill</span></tt> when working with persistent actors.</p>
</div>
<p>The example below highlights how messages arrive in the Actor's mailbox and how they interact with its internal stashing
mechanism when <tt class="docutils literal"><span class="pre">persist()</span></tt> is used. Notice the early stop behaviour that occurs when <tt class="docutils literal"><span class="pre">PoisonPill</span></tt> is used:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/** Explicit shutdown message */</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Shutdown</span>

<span class="k">class</span> <span class="nc">SafePersistentActor</span> <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span> <span class="k">=</span> <span class="s">&quot;safe-actor&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
      <span class="n">persist</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;handle-$c&quot;</span><span class="o">)</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">}</span>
    <span class="k">case</span> <span class="nc">Shutdown</span> <span class="k">=&gt;</span>
      <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// handle recovery here</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// UN-SAFE, due to PersistentActor&#39;s command stashing:</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;a&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;b&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="nc">PoisonPill</span>
<span class="c1">// order of received messages:</span>
<span class="c1">// a</span>
<span class="c1">//   # b arrives at mailbox, stashing;        internal-stash = [b]</span>
<span class="c1">// PoisonPill is an AutoReceivedMessage, is handled automatically</span>
<span class="c1">// !! stop !!</span>
<span class="c1">// Actor is stopped without handling `b` nor the `a` handler!</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// SAFE:</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;a&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="s">&quot;b&quot;</span>
<span class="n">persistentActor</span> <span class="o">!</span> <span class="nc">Shutdown</span>
<span class="c1">// order of received messages:</span>
<span class="c1">// a</span>
<span class="c1">//   # b arrives at mailbox, stashing;        internal-stash = [b]</span>
<span class="c1">//   # Shutdown arrives at mailbox, stashing; internal-stash = [b, Shutdown]</span>
<span class="c1">// handle-a</span>
<span class="c1">//   # unstashing;                            internal-stash = [Shutdown]</span>
<span class="c1">// b</span>
<span class="c1">// handle-b</span>
<span class="c1">//   # unstashing;                            internal-stash = []</span>
<span class="c1">// Shutdown</span>
<span class="c1">// -- stop --</span>
</pre></div>
</div>
</div>
<div class="section" id="replay-filter">
<span id="replay-filter-scala"></span><h3>Replay Filter</h3>
<p>There could be cases where event streams are corrupted and multiple writers (i.e. multiple persistent actor instances)
journaled different messages with the same sequence number.
In such a case, you can configure how you filter replayed messages from multiple writers, upon recovery.</p>
<p>In your configuration, under the <tt class="docutils literal"><span class="pre">akka.persistence.journal.xxx.replay-filter</span></tt> section (where <tt class="docutils literal"><span class="pre">xxx</span></tt> is your journal plugin id),
you can select the replay filter <tt class="docutils literal"><span class="pre">mode</span></tt> from one of the following values:</p>
<ul class="simple">
<li>repair-by-discard-old</li>
<li>fail</li>
<li>warn</li>
<li>off</li>
</ul>
<p>For example, if you configure the replay filter for leveldb plugin, it looks like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">The</span> <span class="n">replay</span> <span class="n">filter</span> <span class="n">can</span> <span class="n">detect</span> <span class="n">a</span> <span class="n">corrupt</span> <span class="n">event</span> <span class="n">stream</span> <span class="n">by</span> <span class="n">inspecting</span>
<span class="k">#</span> <span class="n">sequence</span> <span class="n">numbers</span> <span class="n">and</span> <span class="n">writerUuid</span> <span class="n">when</span> <span class="n">replaying</span> <span class="n">events</span><span class="o">.</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">leveldb</span><span class="o">.</span><span class="n">replay</span><span class="o">-</span><span class="n">filter</span> <span class="o">{</span>
  <span class="k">#</span> <span class="nc">What</span> <span class="n">the</span> <span class="n">filter</span> <span class="n">should</span> <span class="k">do</span> <span class="n">when</span> <span class="n">detecting</span> <span class="n">invalid</span> <span class="n">events</span><span class="o">.</span>
  <span class="k">#</span> <span class="nc">Supported</span> <span class="n">values</span><span class="k">:</span>
  <span class="k">#</span> <span class="kt">`repair-by-discard-old`</span> <span class="kt">:</span> <span class="kt">discard</span> <span class="kt">events</span> <span class="kt">from</span> <span class="kt">old</span> <span class="kt">writers</span><span class="o">,</span>
  <span class="k">#</span>                           <span class="n">warning</span> <span class="n">is</span> <span class="n">logged</span>
  <span class="k">#</span> <span class="n">`fail`</span> <span class="k">:</span> <span class="kt">fail</span> <span class="kt">the</span> <span class="kt">replay</span><span class="o">,</span> <span class="n">error</span> <span class="n">is</span> <span class="n">logged</span>
  <span class="k">#</span> <span class="n">`warn`</span> <span class="k">:</span> <span class="kt">log</span> <span class="kt">warning</span> <span class="kt">but</span> <span class="kt">emit</span> <span class="kt">events</span> <span class="kt">untouched</span>
  <span class="k">#</span> <span class="n">`off`</span> <span class="k">:</span> <span class="kt">disable</span> <span class="kt">this</span> <span class="kt">feature</span> <span class="kt">completely</span>
  <span class="n">mode</span> <span class="k">=</span> <span class="n">repair</span><span class="o">-</span><span class="n">by</span><span class="o">-</span><span class="n">discard</span><span class="o">-</span><span class="n">old</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="persistent-views">
<span id="id3"></span><h2>Persistent Views</h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><tt class="docutils literal"><span class="pre">PersistentView</span></tt> is deprecated. Use <a class="reference internal" href="persistence-query.html#persistence-query-scala"><em>Persistence Query</em></a> instead. The corresponding
query type is <tt class="docutils literal"><span class="pre">EventsByPersistenceId</span></tt>. There are several alternatives for connecting the <tt class="docutils literal"><span class="pre">Source</span></tt>
to an actor corresponding to a previous <tt class="docutils literal"><span class="pre">PersistentView</span></tt> actor:</p>
<ul class="simple">
<li><a class="reference external" href="http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/scala/stream-integrations.html#Sink_actorRef">Sink.actorRef</a> is simple, but has the disadvantage that there is no back-pressure signal from the
destination actor, i.e. if the actor is not consuming the messages fast enough the mailbox of the actor will grow</li>
<li><a class="reference external" href="http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/stages-overview.html#Asynchronous_processing_stages">mapAsync</a> combined with <a class="reference internal" href="../java/lambda-actors.html#actors-ask-lambda"><em>Ask: Send-And-Receive-Future</em></a> is almost as simple with the advantage of back-pressure
being propagated all the way</li>
<li><a class="reference external" href="http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/scala/stream-integrations.html#ActorSubscriber">ActorSubscriber</a> in case you need more fine grained control</li>
</ul>
<p class="last">The consuming actor may be a plain <tt class="docutils literal"><span class="pre">Actor</span></tt> or a <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> if it needs to store its
own state (e.g. fromSequenceNr offset).</p>
</div>
<p>Persistent views can be implemented by extending the <tt class="docutils literal"><span class="pre">PersistentView</span></tt> trait  and implementing the <tt class="docutils literal"><span class="pre">receive</span></tt> and the <tt class="docutils literal"><span class="pre">persistenceId</span></tt>
methods.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyView</span> <span class="k">extends</span> <span class="nc">PersistentView</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;some-persistence-id&quot;</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">viewId</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;some-persistence-id-view&quot;</span>

  <span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">payload</span> <span class="k">if</span> <span class="n">isPersistent</span> <span class="k">=&gt;</span>
    <span class="c1">// handle message from journal...</span>
    <span class="k">case</span> <span class="n">payload</span>                 <span class="k">=&gt;</span>
    <span class="c1">// handle message from user-land...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">persistenceId</span></tt> identifies the persistent actor from which the view receives journaled messages. It is not necessary that
the referenced persistent actor is actually running. Views read messages from a persistent actor's journal directly. When a
persistent actor is started later and begins to write new messages, by default the corresponding view is updated automatically.</p>
<p>It is possible to determine if a message was sent from the Journal or from another actor in user-land by calling the <tt class="docutils literal"><span class="pre">isPersistent</span></tt>
method. Having that said, very often you don't need this information at all and can simply apply the same logic to both cases
(skip the <tt class="docutils literal"><span class="pre">if</span> <span class="pre">isPersistent</span></tt> check).</p>
<div class="section" id="updates">
<h3>Updates</h3>
<p>The default update interval of all views of an actor system is configurable:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">auto</span><span class="o">-</span><span class="n">update</span><span class="o">-</span><span class="n">interval</span> <span class="k">=</span> <span class="mi">5</span><span class="n">s</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">PersistentView</span></tt> implementation classes may also override the <tt class="docutils literal"><span class="pre">autoUpdateInterval</span></tt> method to return a custom update
interval for a specific view class or view instance. Applications may also trigger additional updates at
any time by sending a view an <tt class="docutils literal"><span class="pre">Update</span></tt> message.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">view</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyView</span><span class="o">])</span>
<span class="n">view</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="n">await</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
<p>If the <tt class="docutils literal"><span class="pre">await</span></tt> parameter is set to <tt class="docutils literal"><span class="pre">true</span></tt>, messages that follow the <tt class="docutils literal"><span class="pre">Update</span></tt> request are processed when the
incremental message replay, triggered by that update request, completed. If set to <tt class="docutils literal"><span class="pre">false</span></tt> (default), messages
following the update request may interleave with the replayed message stream. Automated updates always run with
<tt class="docutils literal"><span class="pre">await</span> <span class="pre">=</span> <span class="pre">false</span></tt>.</p>
<p>Automated updates of all persistent views of an actor system can be turned off by configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">auto</span><span class="o">-</span><span class="n">update</span> <span class="k">=</span> <span class="n">off</span>
</pre></div>
</div>
<p>Implementation classes may override the configured default value by overriding the <tt class="docutils literal"><span class="pre">autoUpdate</span></tt> method. To
limit the number of replayed messages per update request, applications can configure a custom
<tt class="docutils literal"><span class="pre">akka.persistence.view.auto-update-replay-max</span></tt> value or override the <tt class="docutils literal"><span class="pre">autoUpdateReplayMax</span></tt> method. The number
of replayed messages for manual updates can be limited with the <tt class="docutils literal"><span class="pre">replayMax</span></tt> parameter of the <tt class="docutils literal"><span class="pre">Update</span></tt> message.</p>
</div>
<div class="section" id="id4">
<h3>Recovery</h3>
<p>Initial recovery of persistent views works the very same way as for persistent actors (i.e. by sending a <tt class="docutils literal"><span class="pre">Recover</span></tt> message
to self). The maximum number of replayed messages during initial recovery is determined by <tt class="docutils literal"><span class="pre">autoUpdateReplayMax</span></tt>.
Further possibilities to customize initial recovery are explained in section <a class="reference internal" href="#recovery-scala"><em>Recovery</em></a>.</p>
</div>
<div class="section" id="persistence-identifiers">
<span id="id5"></span><h3>Identifiers</h3>
<p>A persistent view must have an identifier that doesn't change across different actor incarnations.
The identifier must be defined with the <tt class="docutils literal"><span class="pre">viewId</span></tt> method.</p>
<p>The <tt class="docutils literal"><span class="pre">viewId</span></tt> must differ from the referenced <tt class="docutils literal"><span class="pre">persistenceId</span></tt>, unless <a class="reference internal" href="#snapshots"><em>Snapshots</em></a> of a view and its
persistent actor should be shared (which is what applications usually do not want).</p>
</div>
</div>
<div class="section" id="snapshots">
<span id="id6"></span><h2>Snapshots</h2>
<p>Snapshots can dramatically reduce recovery times of persistent actors and views. The following discusses snapshots
in context of persistent actors but this is also applicable to persistent views.</p>
<p>Persistent actors can save snapshots of internal state by calling the  <tt class="docutils literal"><span class="pre">saveSnapshot</span></tt> method. If saving of a snapshot
succeeds, the persistent actor receives a <tt class="docutils literal"><span class="pre">SaveSnapshotSuccess</span></tt> message, otherwise a <tt class="docutils literal"><span class="pre">SaveSnapshotFailure</span></tt> message</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">var</span> <span class="n">state</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">_</span>

<span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;snap&quot;</span>                                <span class="k">=&gt;</span> <span class="n">saveSnapshot</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">SaveSnapshotSuccess</span><span class="o">(</span><span class="n">metadata</span><span class="o">)</span>         <span class="k">=&gt;</span> <span class="c1">// ...</span>
  <span class="k">case</span> <span class="nc">SaveSnapshotFailure</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="n">reason</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">metadata</span></tt> is of type <tt class="docutils literal"><span class="pre">SnapshotMetadata</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SnapshotMetadata</span><span class="o">(</span><span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">sequenceNr</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">timestamp</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">0L</span><span class="o">)</span>
</pre></div>
</div>
<p>During recovery, the persistent actor is offered a previously saved snapshot via a <tt class="docutils literal"><span class="pre">SnapshotOffer</span></tt> message from
which it can initialize internal state.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">var</span> <span class="n">state</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">_</span>

<span class="k">override</span> <span class="k">def</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">SnapshotOffer</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="n">offeredSnapshot</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">state</span> <span class="k">=</span> <span class="n">offeredSnapshot</span>
  <span class="k">case</span> <span class="nc">RecoveryCompleted</span>                        <span class="k">=&gt;</span>
  <span class="k">case</span> <span class="n">event</span>                                    <span class="k">=&gt;</span> <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The replayed messages that follow the <tt class="docutils literal"><span class="pre">SnapshotOffer</span></tt> message, if any, are younger than the offered snapshot.
They finally recover the persistent actor to its current (i.e. latest) state.</p>
<p>In general, a persistent actor is only offered a snapshot if that persistent actor has previously saved one or more snapshots
and at least one of these snapshots matches the <tt class="docutils literal"><span class="pre">SnapshotSelectionCriteria</span></tt> that can be specified for recovery.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">recovery</span> <span class="k">=</span> <span class="nc">Recovery</span><span class="o">(</span><span class="n">fromSnapshot</span> <span class="k">=</span> <span class="nc">SnapshotSelectionCriteria</span><span class="o">(</span>
  <span class="n">maxSequenceNr</span> <span class="k">=</span> <span class="mi">457L</span><span class="o">,</span>
  <span class="n">maxTimestamp</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">))</span>
</pre></div>
</div>
<p>If not specified, they default to <tt class="docutils literal"><span class="pre">SnapshotSelectionCriteria.Latest</span></tt> which selects the latest (= youngest) snapshot.
To disable snapshot-based recovery, applications should use <tt class="docutils literal"><span class="pre">SnapshotSelectionCriteria.None</span></tt>. A recovery where no
saved snapshot matches the specified <tt class="docutils literal"><span class="pre">SnapshotSelectionCriteria</span></tt> will replay all journaled messages.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In order to use snapshots, a default snapshot-store (<tt class="docutils literal"><span class="pre">akka.persistence.snapshot-store.plugin</span></tt>) must be configured,
or the <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> can pick a snapshot store explicitly by overriding <tt class="docutils literal"><span class="pre">def</span> <span class="pre">snapshotPluginId:</span> <span class="pre">String</span></tt>.</p>
<p>Since it is acceptable for some applications to not use any snapshotting, it is legal to not configure a snapshot store.
However, Akka will log a warning message when this situation is detected and then continue to operate until
an actor tries to store a snapshot, at which point the operation will fail (by replying with an <tt class="docutils literal"><span class="pre">SaveSnapshotFailure</span></tt> for example).</p>
<p class="last">Note that <a class="reference internal" href="cluster-sharding.html#cluster-sharding-scala"><em>Cluster Sharding</em></a> is using snapshots, so if you use Cluster Sharding you need to define a snapshot store plugin.</p>
</div>
<div class="section" id="snapshot-deletion">
<h3>Snapshot deletion</h3>
<p>A persistent actor can delete individual snapshots by calling the <tt class="docutils literal"><span class="pre">deleteSnapshot</span></tt> method with the sequence number of
when the snapshot was taken.</p>
<p>To bulk-delete a range of snapshots matching <tt class="docutils literal"><span class="pre">SnapshotSelectionCriteria</span></tt>,
persistent actors should use the <tt class="docutils literal"><span class="pre">deleteSnapshots</span></tt> method.</p>
</div>
<div class="section" id="snapshot-status-handling">
<h3>Snapshot status handling</h3>
<p>Saving or deleting snapshots can either succeed or fail – this information is reported back to the persistent actor via
status messages as illustrated in the following table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="25%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Method</strong></th>
<th class="head"><strong>Success</strong></th>
<th class="head"><strong>Failure message</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">saveSnapshot(Any)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">SaveSnapshotSuccess</span></tt></td>
<td><tt class="docutils literal"><span class="pre">SaveSnapshotFailure</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">deleteSnapshot(Long)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DeleteSnapshotSuccess</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DeleteSnapshotFailure</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">deleteSnapshots(SnapshotSelectionCriteria)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DeleteSnapshotsSuccess</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DeleteSnapshotsFailure</span></tt></td>
</tr>
</tbody>
</table>
<p>If failure messages are left unhandled by the actor, a default warning log message will be logged for each incoming failure message.
No default action is performed on the success messages, however you're free to handle them e.g. in order to delete
an in memory representation of the snapshot, or in the case of failure to attempt save the snapshot again.</p>
</div>
</div>
<div class="section" id="at-least-once-delivery">
<span id="at-least-once-delivery-scala"></span><h2>At-Least-Once Delivery</h2>
<p>To send messages with at-least-once delivery semantics to destinations you can mix-in <tt class="docutils literal"><span class="pre">AtLeastOnceDelivery</span></tt>
trait to your <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> on the sending side.  It takes care of re-sending messages when they
have not been confirmed within a configurable timeout.</p>
<p>The state of the sending actor, including which messages have been sent that have not been
confirmed by the recipient must be persistent so that it can survive a crash of the sending actor
or JVM. The <tt class="docutils literal"><span class="pre">AtLeastOnceDelivery</span></tt> trait does not persist anything by itself. It is your
responsibility to persist the intent that a message is sent and that a confirmation has been
received.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>At-least-once delivery implies that original message sending order is not always preserved,
and the destination may receive duplicate messages.
Semantics do not match those of a normal <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> send operation:</p>
<ul class="simple">
<li>it is not at-most-once delivery</li>
<li>message order for the same sender–receiver pair is not preserved due to
possible resends</li>
<li>after a crash and restart of the destination messages are still
delivered to the new actor incarnation</li>
</ul>
<p class="last">These semantics are similar to what an <tt class="xref py py-class docutils literal"><span class="pre">ActorPath</span></tt> represents (see
<a class="reference internal" href="actors.html#actor-lifecycle-scala"><em>Actor Lifecycle</em></a>), therefore you need to supply a path and not a
reference when delivering messages. The messages are sent to the path with
an actor selection.</p>
</div>
<p>Use the <tt class="docutils literal"><span class="pre">deliver</span></tt> method to send a message to a destination. Call the <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> method
when the destination has replied with a confirmation message.</p>
<div class="section" id="relationship-between-deliver-and-confirmdelivery">
<h3>Relationship between deliver and confirmDelivery</h3>
<p>To send messages to the destination path, use the <tt class="docutils literal"><span class="pre">deliver</span></tt> method after you have persisted the intent
to send the message.</p>
<p>The destination actor must send back a confirmation message. When the sending actor receives this
confirmation message you should persist the fact that the message was delivered successfully and then call
the <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> method.</p>
<p>If the persistent actor is not currently recovering, the <tt class="docutils literal"><span class="pre">deliver</span></tt> method will send the message to
the destination actor. When recovering, messages will be buffered until they have been confirmed using <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt>.
Once recovery has completed, if there are outstanding messages that have not been confirmed (during the message replay),
the persistent actor will resend these before sending any other messages.</p>
<p>Deliver requires a <tt class="docutils literal"><span class="pre">deliveryIdToMessage</span></tt> function to pass the provided <tt class="docutils literal"><span class="pre">deliveryId</span></tt> into the message so that the correlation
between <tt class="docutils literal"><span class="pre">deliver</span></tt> and <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> is possible. The <tt class="docutils literal"><span class="pre">deliveryId</span></tt> must do the round trip. Upon receipt
of the message, the destination actor will send the same``deliveryId`` wrapped in a confirmation message back to the sender.
The sender will then use it to call <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> method to complete the delivery routine.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Actor</span><span class="o">,</span> <span class="nc">ActorSelection</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.persistence.AtLeastOnceDelivery</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Msg</span><span class="o">(</span><span class="n">deliveryId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Confirm</span><span class="o">(</span><span class="n">deliveryId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Evt</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MsgSent</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Evt</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MsgConfirmed</span><span class="o">(</span><span class="n">deliveryId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Evt</span>

<span class="k">class</span> <span class="nc">MyPersistentActor</span><span class="o">(</span><span class="n">destination</span><span class="k">:</span> <span class="kt">ActorSelection</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="k">with</span> <span class="nc">AtLeastOnceDelivery</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;persistence-id&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span>           <span class="o">=&gt;</span> <span class="n">persist</span><span class="o">(</span><span class="nc">MsgSent</span><span class="o">(</span><span class="n">s</span><span class="o">))(</span><span class="n">updateState</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Confirm</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">persist</span><span class="o">(</span><span class="nc">MsgConfirmed</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">))(</span><span class="n">updateState</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">evt</span><span class="k">:</span> <span class="kt">Evt</span> <span class="o">=&gt;</span> <span class="n">updateState</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">updateState</span><span class="o">(</span><span class="n">evt</span><span class="k">:</span> <span class="kt">Evt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">evt</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">MsgSent</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">deliver</span><span class="o">(</span><span class="n">destination</span><span class="o">)(</span><span class="n">deliveryId</span> <span class="k">=&gt;</span> <span class="nc">Msg</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span>

    <span class="k">case</span> <span class="nc">MsgConfirmed</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">confirmDelivery</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">MyDestination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Msg</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="c1">// ...</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">Confirm</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">deliveryId</span></tt> generated by the persistence module is a strictly monotonically increasing sequence number
without gaps. The same sequence is used for all destinations of the actor, i.e. when sending to multiple
destinations the destinations will see gaps in the sequence. It is not possible to use custom <tt class="docutils literal"><span class="pre">deliveryId</span></tt>.
However, you can send a custom correlation identifier in the message to the destination. You must then retain
a mapping between the internal <tt class="docutils literal"><span class="pre">deliveryId</span></tt> (passed into the <tt class="docutils literal"><span class="pre">deliveryIdToMessage</span></tt> function) and your custom
correlation id (passed into the message). You can do this by storing such mapping in a <tt class="docutils literal"><span class="pre">Map(correlationId</span> <span class="pre">-&gt;</span> <span class="pre">deliveryId)</span></tt>
from which you can retrieve the <tt class="docutils literal"><span class="pre">deliveryId</span></tt> to be passed into the <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> method once the receiver
of your message has replied with your custom correlation id.</p>
<p>The <tt class="docutils literal"><span class="pre">AtLeastOnceDelivery</span></tt> trait has a state consisting of unconfirmed messages and a
sequence number. It does not store this state itself. You must persist events corresponding to the
<tt class="docutils literal"><span class="pre">deliver</span></tt> and <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> invocations from your <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> so that the state can
be restored by calling the same methods during the recovery phase of the <tt class="docutils literal"><span class="pre">PersistentActor</span></tt>. Sometimes
these events can be derived from other business level events, and sometimes you must create separate events.
During recovery, calls to <tt class="docutils literal"><span class="pre">deliver</span></tt> will not send out messages, those will be sent later
if no matching <tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> will have been performed.</p>
<p>Support for snapshots is provided by <tt class="docutils literal"><span class="pre">getDeliverySnapshot</span></tt> and <tt class="docutils literal"><span class="pre">setDeliverySnapshot</span></tt>.
The <tt class="docutils literal"><span class="pre">AtLeastOnceDeliverySnapshot</span></tt> contains the full delivery state, including unconfirmed messages.
If you need a custom snapshot for other parts of the actor state you must also include the
<tt class="docutils literal"><span class="pre">AtLeastOnceDeliverySnapshot</span></tt>. It is serialized using protobuf with the ordinary Akka
serialization mechanism. It is easiest to include the bytes of the <tt class="docutils literal"><span class="pre">AtLeastOnceDeliverySnapshot</span></tt>
as a blob in your custom snapshot.</p>
<p>The interval between redelivery attempts is defined by the <tt class="docutils literal"><span class="pre">redeliverInterval</span></tt> method.
The default value can be configured with the <tt class="docutils literal"><span class="pre">akka.persistence.at-least-once-delivery.redeliver-interval</span></tt>
configuration key. The method can be overridden by implementation classes to return non-default values.</p>
<p>The maximum number of messages that will be sent at each redelivery burst is defined by the
<tt class="docutils literal"><span class="pre">redeliveryBurstLimit</span></tt> method (burst frequency is half of the redelivery interval). If there's a lot of
unconfirmed messages (e.g. if the destination is not available for a long time), this helps to prevent an overwhelming
amount of messages to be sent at once. The default value can be configured with the
<tt class="docutils literal"><span class="pre">akka.persistence.at-least-once-delivery.redelivery-burst-limit</span></tt> configuration key. The method can be overridden
by implementation classes to return non-default values.</p>
<p>After a number of delivery attempts a <tt class="docutils literal"><span class="pre">AtLeastOnceDelivery.UnconfirmedWarning</span></tt> message
will be sent to <tt class="docutils literal"><span class="pre">self</span></tt>. The re-sending will still continue, but you can choose to call
<tt class="docutils literal"><span class="pre">confirmDelivery</span></tt> to cancel the re-sending. The number of delivery attempts before emitting the
warning is defined by the <tt class="docutils literal"><span class="pre">warnAfterNumberOfUnconfirmedAttempts</span></tt> method. The default value can be
configured with the <tt class="docutils literal"><span class="pre">akka.persistence.at-least-once-delivery.warn-after-number-of-unconfirmed-attempts</span></tt>
configuration key. The method can be overridden by implementation classes to return non-default values.</p>
<p>The <tt class="docutils literal"><span class="pre">AtLeastOnceDelivery</span></tt> trait holds messages in memory until their successful delivery has been confirmed.
The maximum number of unconfirmed messages that the actor is allowed to hold in memory
is defined by the <tt class="docutils literal"><span class="pre">maxUnconfirmedMessages</span></tt> method. If this limit is exceed the <tt class="docutils literal"><span class="pre">deliver</span></tt> method will
not accept more messages and it will throw <tt class="docutils literal"><span class="pre">AtLeastOnceDelivery.MaxUnconfirmedMessagesExceededException</span></tt>.
The default value can be configured with the <tt class="docutils literal"><span class="pre">akka.persistence.at-least-once-delivery.max-unconfirmed-messages</span></tt>
configuration key. The method can be overridden by implementation classes to return non-default values.</p>
</div>
</div>
<div class="section" id="event-adapters">
<span id="event-adapters-scala"></span><h2>Event Adapters</h2>
<p>In long running projects using event sourcing sometimes the need arises to detach the data model from the domain model
completely.</p>
<p>Event Adapters help in situations where:</p>
<ul class="simple">
<li><strong>Version Migrations</strong> – existing events stored in <em>Version 1</em> should be &quot;upcasted&quot; to a new <em>Version 2</em> representation,
and the process of doing so involves actual code, not just changes on the serialization layer. For these scenarios
the <tt class="docutils literal"><span class="pre">toJournal</span></tt> function is usually an identity function, however the <tt class="docutils literal"><span class="pre">fromJournal</span></tt> is implemented as
<tt class="docutils literal"><span class="pre">v1.Event=&gt;v2.Event</span></tt>, performing the neccessary mapping inside the fromJournal method.
This technique is sometimes refered to as &quot;upcasting&quot; in other CQRS libraries.</li>
<li><strong>Separating Domain and Data models</strong> – thanks to EventAdapters it is possible to completely separate the domain model
from the model used to persist data in the Journals. For example one may want to use case classes in the
domain model, however persist their protocol-buffer (or any other binary serialization format) counter-parts to the Journal.
A simple <tt class="docutils literal"><span class="pre">toJournal:MyModel=&gt;MyDataModel</span></tt> and <tt class="docutils literal"><span class="pre">fromJournal:MyDataModel=&gt;MyModel</span></tt> adapter can be used to implement this feature.</li>
<li><strong>Journal Specialized Data Types</strong> – exposing data types understood by the underlying Journal, for example for data stores which
understand JSON it is possible to write an EventAdapter <tt class="docutils literal"><span class="pre">toJournal:Any=&gt;JSON</span></tt> such that the Journal can <em>directly</em> store the
json instead of serializing the object to its binary representation.</li>
</ul>
<p>Implementing an EventAdapter is rather stright forward:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyEventAdapter</span><span class="o">(</span><span class="n">system</span><span class="k">:</span> <span class="kt">ExtendedActorSystem</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventAdapter</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="s">&quot;&quot;</span> <span class="c1">// when no manifest needed, return &quot;&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span>
    <span class="n">event</span> <span class="c1">// identity</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">EventSeq</span> <span class="o">=</span>
    <span class="nc">EventSeq</span><span class="o">.</span><span class="n">single</span><span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="c1">// identity</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Then in order for it to be used on events coming to and from the journal you must bind it using the below configuration syntax:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span> <span class="o">{</span>
  <span class="n">inmem</span> <span class="o">{</span>
    <span class="n">event</span><span class="o">-</span><span class="n">adapters</span> <span class="o">{</span>
      <span class="n">tagging</span>        <span class="k">=</span> <span class="s">&quot;docs.persistence.MyTaggingEventAdapter&quot;</span>
      <span class="n">user</span><span class="o">-</span><span class="n">upcasting</span> <span class="k">=</span> <span class="s">&quot;docs.persistence.UserUpcastingEventAdapter&quot;</span>
      <span class="n">item</span><span class="o">-</span><span class="n">upcasting</span> <span class="k">=</span> <span class="s">&quot;docs.persistence.ItemUpcastingEventAdapter&quot;</span>
    <span class="o">}</span>

    <span class="n">event</span><span class="o">-</span><span class="n">adapter</span><span class="o">-</span><span class="n">bindings</span> <span class="o">{</span>
      <span class="s">&quot;docs.persistence.Item&quot;</span>        <span class="k">=</span> <span class="n">tagging</span>
      <span class="s">&quot;docs.persistence.TaggedEvent&quot;</span> <span class="k">=</span> <span class="n">tagging</span>
      <span class="s">&quot;docs.persistence.v1.Event&quot;</span>    <span class="k">=</span> <span class="o">[</span><span class="kt">user-upcasting</span>, <span class="kt">item-upcasting</span><span class="o">]</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It is possible to bind multiple adapters to one class <em>for recovery</em>, in which case the <tt class="docutils literal"><span class="pre">fromJournal</span></tt> methods of all
bound adapters will be applied to a given matching event (in order of definition in the configuration). Since each adapter may
return from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">n</span></tt> adapted events (called as <tt class="docutils literal"><span class="pre">EventSeq</span></tt>), each adapter can investigate the event and if it should
indeed adapt it return the adapted event(s) for it. Other adapters which do not have anything to contribute during this
adaptation simply return <tt class="docutils literal"><span class="pre">EventSeq.empty</span></tt>. The adapted events are then delivered in-order to the <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> during replay.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For more advanced schema evolution techniques refer to the <a class="reference internal" href="persistence-schema-evolution.html#persistence-schema-evolution-scala"><em>Persistence - Schema Evolution</em></a> documentation.</p>
</div>
</div>
<div class="section" id="persistent-fsm">
<span id="id7"></span><h2>Persistent FSM</h2>
<p><tt class="docutils literal"><span class="pre">PersistentFSM</span></tt> handles the incoming messages in an FSM like fashion.
Its internal state is persisted as a sequence of changes, later referred to as domain events.
Relationship between incoming messages, FSM's states and transitions, persistence of domain events is defined by a DSL.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><tt class="docutils literal"><span class="pre">PersistentFSM</span></tt> is marked as <strong>“experimental”</strong> as of its introduction in Akka 2.4.0. We will continue to
improve this API based on our users’ feedback, which implies that while we try to keep incompatible
changes to a minimum the binary compatibility guarantee for maintenance releases does not apply to the
contents of the <cite>classes related to ``PersistentFSM`</cite>.</p>
</div>
<div class="section" id="a-simple-example">
<h3>A Simple Example</h3>
<p>To demonstrate the features of the <tt class="docutils literal"><span class="pre">PersistentFSM</span></tt> trait, consider an actor which represents a Web store customer.
The contract of our &quot;WebStoreCustomerFSMActor&quot; is that it accepts the following commands:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Command</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">AddItem</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Command</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Buy</span> <span class="k">extends</span> <span class="nc">Command</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Leave</span> <span class="k">extends</span> <span class="nc">Command</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">GetCurrentCart</span> <span class="k">extends</span> <span class="nc">Command</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">AddItem</span></tt> sent when the customer adds an item to a shopping cart
<tt class="docutils literal"><span class="pre">Buy</span></tt> - when the customer finishes the purchase
<tt class="docutils literal"><span class="pre">Leave</span></tt> - when the customer leaves the store without purchasing anything
<tt class="docutils literal"><span class="pre">GetCurrentCart</span></tt> allows to query the current state of customer's shopping cart</p>
<p>The customer can be in one of the following states:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserState</span> <span class="k">extends</span> <span class="nc">FSMState</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">LookingAround</span> <span class="k">extends</span> <span class="nc">UserState</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;Looking Around&quot;</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Shopping</span> <span class="k">extends</span> <span class="nc">UserState</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;Shopping&quot;</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Inactive</span> <span class="k">extends</span> <span class="nc">UserState</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;Inactive&quot;</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Paid</span> <span class="k">extends</span> <span class="nc">UserState</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;Paid&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">LookingAround</span></tt> customer is browsing the site, but hasn't added anything to the shopping cart
<tt class="docutils literal"><span class="pre">Shopping</span></tt> customer has recently added items to the shopping cart
<tt class="docutils literal"><span class="pre">Inactive</span></tt> customer has items in the shopping cart, but hasn't added anything recently
<tt class="docutils literal"><span class="pre">Paid</span></tt> customer has purchased the items</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">PersistentFSM</span></tt> states must inherit from trait <tt class="docutils literal"><span class="pre">PersistentFSM.FSMState</span></tt> and implement the
<tt class="docutils literal"><span class="pre">def</span> <span class="pre">identifier:</span> <span class="pre">String</span></tt> method. This is required in order to simplify the serialization of FSM states.
String identifiers should be unique!</p>
</div>
<p>Customer's actions are &quot;recorded&quot; as a sequence of &quot;domain events&quot; which are persisted. Those events are replayed on an actor's
start in order to restore the latest customer's state:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DomainEvent</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ItemAdded</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">DomainEvent</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">OrderExecuted</span> <span class="k">extends</span> <span class="nc">DomainEvent</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">OrderDiscarded</span> <span class="k">extends</span> <span class="nc">DomainEvent</span>
</pre></div>
</div>
<p>Customer state data represents the items in a customer's shopping cart:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Item</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">price</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ShoppingCart</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">addItem</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">ShoppingCart</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">()</span><span class="k">:</span> <span class="kt">ShoppingCart</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">EmptyShoppingCart</span> <span class="k">extends</span> <span class="nc">ShoppingCart</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">addItem</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span> <span class="k">=</span> <span class="nc">NonEmptyShoppingCart</span><span class="o">(</span><span class="n">item</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">()</span> <span class="k">=</span> <span class="k">this</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">NonEmptyShoppingCart</span><span class="o">(</span><span class="n">items</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Item</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ShoppingCart</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">addItem</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span> <span class="k">=</span> <span class="nc">NonEmptyShoppingCart</span><span class="o">(</span><span class="n">items</span> <span class="o">:+</span> <span class="n">item</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">()</span> <span class="k">=</span> <span class="nc">EmptyShoppingCart</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here is how everything is wired together:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">startWith</span><span class="o">(</span><span class="nc">LookingAround</span><span class="o">,</span> <span class="nc">EmptyShoppingCart</span><span class="o">)</span>

<span class="n">when</span><span class="o">(</span><span class="nc">LookingAround</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">AddItem</span><span class="o">(</span><span class="n">item</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Shopping</span><span class="o">)</span> <span class="n">applying</span> <span class="nc">ItemAdded</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="n">forMax</span> <span class="o">(</span><span class="mi">1</span> <span class="n">seconds</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">GetCurrentCart</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">stay</span> <span class="n">replying</span> <span class="n">data</span>
<span class="o">}</span>

<span class="n">when</span><span class="o">(</span><span class="nc">Shopping</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">AddItem</span><span class="o">(</span><span class="n">item</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">stay</span> <span class="n">applying</span> <span class="nc">ItemAdded</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="n">forMax</span> <span class="o">(</span><span class="mi">1</span> <span class="n">seconds</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">Buy</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Paid</span><span class="o">)</span> <span class="n">applying</span> <span class="nc">OrderExecuted</span> <span class="n">andThen</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">NonEmptyShoppingCart</span><span class="o">(</span><span class="n">items</span><span class="o">)</span> <span class="k">⇒</span>
        <span class="n">reportActor</span> <span class="o">!</span> <span class="nc">PurchaseWasMade</span><span class="o">(</span><span class="n">items</span><span class="o">)</span>
        <span class="n">saveStateSnapshot</span><span class="o">()</span>
      <span class="k">case</span> <span class="nc">EmptyShoppingCart</span> <span class="k">⇒</span> <span class="n">saveStateSnapshot</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">Leave</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">stop</span> <span class="n">applying</span> <span class="nc">OrderDiscarded</span> <span class="n">andThen</span> <span class="o">{</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">⇒</span>
        <span class="n">reportActor</span> <span class="o">!</span> <span class="nc">ShoppingCardDiscarded</span>
        <span class="n">saveStateSnapshot</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">GetCurrentCart</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">stay</span> <span class="n">replying</span> <span class="n">data</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">StateTimeout</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Inactive</span><span class="o">)</span> <span class="n">forMax</span> <span class="o">(</span><span class="mi">2</span> <span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">when</span><span class="o">(</span><span class="nc">Inactive</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">AddItem</span><span class="o">(</span><span class="n">item</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Shopping</span><span class="o">)</span> <span class="n">applying</span> <span class="nc">ItemAdded</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="n">forMax</span> <span class="o">(</span><span class="mi">1</span> <span class="n">seconds</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">StateTimeout</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">stop</span> <span class="n">applying</span> <span class="nc">OrderDiscarded</span> <span class="n">andThen</span> <span class="o">{</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">⇒</span> <span class="n">reportActor</span> <span class="o">!</span> <span class="nc">ShoppingCardDiscarded</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">when</span><span class="o">(</span><span class="nc">Paid</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">Leave</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span> <span class="n">stop</span><span class="o">()</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">GetCurrentCart</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">stay</span> <span class="n">replying</span> <span class="n">data</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">State data can only be modified directly on initialization. Later it's modified only as a result of applying domain events.
Override the <tt class="docutils literal"><span class="pre">applyEvent</span></tt> method to define how state data is affected by domain events, see the example below</p>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">applyEvent</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">DomainEvent</span><span class="o">,</span> <span class="n">cartBeforeEvent</span><span class="k">:</span> <span class="kt">ShoppingCart</span><span class="o">)</span><span class="k">:</span> <span class="kt">ShoppingCart</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ItemAdded</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="k">⇒</span> <span class="n">cartBeforeEvent</span><span class="o">.</span><span class="n">addItem</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">OrderExecuted</span>   <span class="k">⇒</span> <span class="n">cartBeforeEvent</span>
    <span class="k">case</span> <span class="nc">OrderDiscarded</span>  <span class="k">⇒</span> <span class="n">cartBeforeEvent</span><span class="o">.</span><span class="n">empty</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">andThen</span></tt> can be used to define actions which will be executed following event's persistence - convenient for &quot;side effects&quot; like sending a message or logging.
Notice that actions defined in <tt class="docutils literal"><span class="pre">andThen</span></tt> block are not executed on recovery:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">goto</span><span class="o">(</span><span class="nc">Paid</span><span class="o">)</span> <span class="n">applying</span> <span class="nc">OrderExecuted</span> <span class="n">andThen</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">NonEmptyShoppingCart</span><span class="o">(</span><span class="n">items</span><span class="o">)</span> <span class="k">⇒</span>
    <span class="n">reportActor</span> <span class="o">!</span> <span class="nc">PurchaseWasMade</span><span class="o">(</span><span class="n">items</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>A snapshot of state data can be persisted by calling the <tt class="docutils literal"><span class="pre">saveStateSnapshot()</span></tt> method:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">stop</span> <span class="n">applying</span> <span class="nc">OrderDiscarded</span> <span class="n">andThen</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">⇒</span>
    <span class="n">reportActor</span> <span class="o">!</span> <span class="nc">ShoppingCardDiscarded</span>
    <span class="n">saveStateSnapshot</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
<p>On recovery state data is initialized according to the latest available snapshot, then the remaining domain events are replayed, triggering the
<tt class="docutils literal"><span class="pre">applyEvent</span></tt> method.</p>
</div>
</div>
<div class="section" id="storage-plugins">
<span id="id8"></span><h2>Storage plugins</h2>
<p>Storage backends for journals and snapshot stores are pluggable in the Akka persistence extension.</p>
<p>A directory of persistence journal and snapshot store plugins is available at the Akka Community Projects page, see <a class="reference external" href="http://akka.io/community/">Community plugins</a></p>
<p>Plugins can be selected either by &quot;default&quot; for all persistent actors and views,
or &quot;individually&quot;, when a persistent actor or view defines its own set of plugins.</p>
<p>When a persistent actor or view does NOT override the <tt class="docutils literal"><span class="pre">journalPluginId</span></tt> and <tt class="docutils literal"><span class="pre">snapshotPluginId</span></tt> methods,
the persistence extension will use the &quot;default&quot; journal and snapshot-store plugins configured in <tt class="docutils literal"><span class="pre">reference.conf</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">snapshot</span><span class="o">-</span><span class="n">store</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
</pre></div>
</div>
<p>However, these entries are provided as empty &quot;&quot;, and require explicit user configuration via override in the user <tt class="docutils literal"><span class="pre">application.conf</span></tt>.
For an example of a journal plugin which writes messages to LevelDB see <a class="reference internal" href="#local-leveldb-journal"><em>Local LevelDB journal</em></a>.
For an example of a snapshot store plugin which writes snapshots as individual files to the local filesystem see <a class="reference internal" href="#local-snapshot-store"><em>Local snapshot store</em></a>.</p>
<p>Applications can provide their own plugins by implementing a plugin API and activating them by configuration.
Plugin development requires the following imports:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.persistence._</span>
<span class="k">import</span> <span class="nn">akka.persistence.journal._</span>
<span class="k">import</span> <span class="nn">akka.persistence.snapshot._</span>
</pre></div>
</div>
<div class="section" id="eager-initialization-of-persistence-plugin">
<h3>Eager initialization of persistence plugin</h3>
<p>By default, persistence plugins are started on-demand, as they are used. In some case, however, it might be beneficial
to start a certain plugin eagerly. In order to do that, you should first add the <tt class="docutils literal"><span class="pre">akka.persistence.Persistence</span></tt>
under the <tt class="docutils literal"><span class="pre">akka.extensions</span></tt> key. Then, specify the IDs of plugins you wish to start automatically under
<tt class="docutils literal"><span class="pre">akka.persistence.journal.auto-start-journals</span></tt> and <tt class="docutils literal"><span class="pre">akka.persistence.snapshot-store.auto-start-snapshot-stores</span></tt>.</p>
</div>
<div class="section" id="journal-plugin-api">
<span id="id9"></span><h3>Journal plugin API</h3>
<p>A journal plugin extends <tt class="docutils literal"><span class="pre">AsyncWriteJournal</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">AsyncWriteJournal</span></tt> is an actor and the methods to be implemented are:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Plugin API: asynchronously writes a batch (`Seq`) of persistent messages to the</span>
<span class="cm"> * journal.</span>
<span class="cm"> *</span>
<span class="cm"> * The batch is only for performance reasons, i.e. all messages don&#39;t have to be written</span>
<span class="cm"> * atomically. Higher throughput can typically be achieved by using batch inserts of many</span>
<span class="cm"> * records compared to inserting records one-by-one, but this aspect depends on the</span>
<span class="cm"> * underlying data store and a journal implementation can implement it as efficient as</span>
<span class="cm"> * possible. Journals should aim to persist events in-order for a given `persistenceId`</span>
<span class="cm"> * as otherwise in case of a failure, the persistent state may be end up being inconsistent.</span>
<span class="cm"> *</span>
<span class="cm"> * Each `AtomicWrite` message contains the single `PersistentRepr` that corresponds to</span>
<span class="cm"> * the event that was passed to the `persist` method of the `PersistentActor`, or it</span>
<span class="cm"> * contains several `PersistentRepr` that corresponds to the events that were passed</span>
<span class="cm"> * to the `persistAll` method of the `PersistentActor`. All `PersistentRepr` of the</span>
<span class="cm"> * `AtomicWrite` must be written to the data store atomically, i.e. all or none must</span>
<span class="cm"> * be stored. If the journal (data store) cannot support atomic writes of multiple</span>
<span class="cm"> * events it should reject such writes with a `Try` `Failure` with an</span>
<span class="cm"> * `UnsupportedOperationException` describing the issue. This limitation should</span>
<span class="cm"> * also be documented by the journal plugin.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are failures when storing any of the messages in the batch the returned</span>
<span class="cm"> * `Future` must be completed with failure. The `Future` must only be completed with</span>
<span class="cm"> * success when all messages in the batch have been confirmed to be stored successfully,</span>
<span class="cm"> * i.e. they will be readable, and visible, in a subsequent replay. If there is</span>
<span class="cm"> * uncertainty about if the messages were stored or not the `Future` must be completed</span>
<span class="cm"> * with failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Data store connection problems must be signaled by completing the `Future` with</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> * The journal can also signal that it rejects individual messages (`AtomicWrite`) by</span>
<span class="cm"> * the returned `immutable.Seq[Try[Unit]]`. It is possible but not mandatory to reduce</span>
<span class="cm"> * number of allocations by returning `Future.successful(Nil)` for the happy path,</span>
<span class="cm"> * i.e. when no messages are rejected. Otherwise the returned `Seq` must have as many elements</span>
<span class="cm"> * as the input `messages` `Seq`. Each `Try` element signals if the corresponding</span>
<span class="cm"> * `AtomicWrite` is rejected or not, with an exception describing the problem. Rejecting</span>
<span class="cm"> * a message means it was not stored, i.e. it must not be included in a later replay.</span>
<span class="cm"> * Rejecting a message is typically done before attempting to store it, e.g. because of</span>
<span class="cm"> * serialization error.</span>
<span class="cm"> *</span>
<span class="cm"> * Data store connection problems must not be signaled as rejections.</span>
<span class="cm"> *</span>
<span class="cm"> * It is possible but not mandatory to reduce number of allocations by returning</span>
<span class="cm"> * `Future.successful(Nil)` for the happy path, i.e. when no messages are rejected.</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to this method are serialized by the enclosing journal actor. If you spawn</span>
<span class="cm"> * work in asynchronous tasks it is alright that they complete the futures in any order,</span>
<span class="cm"> * but the actual writes for a specific persistenceId should be serialized to avoid</span>
<span class="cm"> * issues such as events of a later write are visible to consumers (query side, or replay)</span>
<span class="cm"> * before the events of an earlier write are visible.</span>
<span class="cm"> * A PersistentActor will not send a new WriteMessages request before the previous one</span>
<span class="cm"> * has been completed.</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that the `sender` field of the contained PersistentRepr objects has been</span>
<span class="cm"> * nulled out (i.e. set to `ActorRef.noSender`) in order to not use space in the journal</span>
<span class="cm"> * for a sender reference that will likely be obsolete during replay.</span>
<span class="cm"> *</span>
<span class="cm"> * Please also note that requests for the highest sequence number may be made concurrently</span>
<span class="cm"> * to this call executing for the same `persistenceId`, in particular it is possible that</span>
<span class="cm"> * a restarting actor tries to recover before its outstanding writes have completed. In</span>
<span class="cm"> * the latter case it is highly desirable to defer reading the highest sequence number</span>
<span class="cm"> * until all outstanding writes have completed, otherwise the PersistentActor may reuse</span>
<span class="cm"> * sequence numbers.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is protected with a circuit-breaker.</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">asyncWriteMessages</span><span class="o">(</span><span class="n">messages</span><span class="k">:</span> <span class="kt">immutable.Seq</span><span class="o">[</span><span class="kt">AtomicWrite</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">immutable.Seq</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]]</span>

<span class="cm">/**</span>
<span class="cm"> * Plugin API: asynchronously deletes all persistent messages up to `toSequenceNr`</span>
<span class="cm"> * (inclusive).</span>
<span class="cm"> *</span>
<span class="cm"> * This call is protected with a circuit-breaker.</span>
<span class="cm"> * Message deletion doesn&#39;t affect the highest sequence number of messages, journal must maintain the highest sequence number and never decrease it.</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">asyncDeleteMessagesTo</span><span class="o">(</span><span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">toSequenceNr</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="cm">/**</span>
<span class="cm"> * Plugin API</span>
<span class="cm"> *</span>
<span class="cm"> * Allows plugin implementers to use `f pipeTo self` and</span>
<span class="cm"> * handle additional messages for implementing advanced features</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">receivePluginInternal</span><span class="k">:</span> <span class="kt">Actor.Receive</span> <span class="o">=</span> <span class="nc">Actor</span><span class="o">.</span><span class="n">emptyBehavior</span>
</pre></div>
</div>
<p>If the storage backend API only supports synchronous, blocking writes, the methods should be implemented as:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">asyncWriteMessages</span><span class="o">(</span><span class="n">messages</span><span class="k">:</span> <span class="kt">immutable.Seq</span><span class="o">[</span><span class="kt">AtomicWrite</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">immutable.Seq</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]]</span> <span class="k">=</span>
  <span class="nc">Future</span><span class="o">.</span><span class="n">fromTry</span><span class="o">(</span><span class="nc">Try</span> <span class="o">{</span>
    <span class="c1">// blocking call here</span>
    <span class="o">???</span>
  <span class="o">})</span>
</pre></div>
</div>
<p>A journal plugin must also implement the methods defined in <tt class="docutils literal"><span class="pre">AsyncRecovery</span></tt> for replays and sequence number recovery:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Plugin API: asynchronously replays persistent messages. Implementations replay</span>
<span class="cm"> * a message by calling `replayCallback`. The returned future must be completed</span>
<span class="cm"> * when all messages (matching the sequence number bounds) have been replayed.</span>
<span class="cm"> * The future must be completed with a failure if any of the persistent messages</span>
<span class="cm"> * could not be replayed.</span>
<span class="cm"> *</span>
<span class="cm"> * The `replayCallback` must also be called with messages that have been marked</span>
<span class="cm"> * as deleted. In this case a replayed message&#39;s `deleted` method must return</span>
<span class="cm"> * `true`.</span>
<span class="cm"> *</span>
<span class="cm"> * The `toSequenceNr` is the lowest of what was returned by [[#asyncReadHighestSequenceNr]]</span>
<span class="cm"> * and what the user specified as recovery [[akka.persistence.Recovery]] parameter.</span>
<span class="cm"> * This does imply that this call is always preceded by reading the highest sequence</span>
<span class="cm"> * number for the given `persistenceId`.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is NOT protected with a circuit-breaker because it may take long time</span>
<span class="cm"> * to replay all events. The plugin implementation itself must protect against</span>
<span class="cm"> * an unresponsive backend store and make sure that the returned Future is</span>
<span class="cm"> * completed with success or failure within reasonable time. It is not allowed</span>
<span class="cm"> * to ignore completing the future.</span>
<span class="cm"> *</span>
<span class="cm"> * @param persistenceId persistent actor id.</span>
<span class="cm"> * @param fromSequenceNr sequence number where replay should start (inclusive).</span>
<span class="cm"> * @param toSequenceNr sequence number where replay should end (inclusive).</span>
<span class="cm"> * @param max maximum number of messages to be replayed.</span>
<span class="cm"> * @param recoveryCallback called to replay a single message. Can be called from any</span>
<span class="cm"> *                       thread.</span>
<span class="cm"> *</span>
<span class="cm"> * @see [[AsyncWriteJournal]]</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">asyncReplayMessages</span><span class="o">(</span><span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">fromSequenceNr</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">toSequenceNr</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span>
                        <span class="n">max</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)(</span><span class="n">recoveryCallback</span><span class="k">:</span> <span class="kt">PersistentRepr</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="cm">/**</span>
<span class="cm"> * Plugin API: asynchronously reads the highest stored sequence number for the</span>
<span class="cm"> * given `persistenceId`. The persistent actor will use the highest sequence</span>
<span class="cm"> * number after recovery as the starting point when persisting new events.</span>
<span class="cm"> * This sequence number is also used as `toSequenceNr` in subsequent call</span>
<span class="cm"> * to [[#asyncReplayMessages]] unless the user has specified a lower `toSequenceNr`.</span>
<span class="cm"> * Journal must maintain the highest sequence number and never decrease it.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is protected with a circuit-breaker.</span>
<span class="cm"> *</span>
<span class="cm"> * Please also note that requests for the highest sequence number may be made concurrently</span>
<span class="cm"> * to writes executing for the same `persistenceId`, in particular it is possible that</span>
<span class="cm"> * a restarting actor tries to recover before its outstanding writes have completed.</span>
<span class="cm"> *</span>
<span class="cm"> * @param persistenceId persistent actor id.</span>
<span class="cm"> * @param fromSequenceNr hint where to start searching for the highest sequence</span>
<span class="cm"> *                       number. When a persistent actor is recovering this</span>
<span class="cm"> *                       `fromSequenceNr` will be the sequence number of the used</span>
<span class="cm"> *                       snapshot or `0L` if no snapshot is used.</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">asyncReadHighestSequenceNr</span><span class="o">(</span><span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">fromSequenceNr</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</pre></div>
</div>
<p>A journal plugin can be activated with the following minimal configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">Path</span> <span class="n">to</span> <span class="n">the</span> <span class="n">journal</span> <span class="n">plugin</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;my-journal&quot;</span>

<span class="k">#</span> <span class="nc">My</span> <span class="n">custom</span> <span class="n">journal</span> <span class="n">plugin</span>
<span class="n">my</span><span class="o">-</span><span class="n">journal</span> <span class="o">{</span>
  <span class="k">#</span> <span class="nc">Class</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">plugin</span><span class="o">.</span>
  <span class="k">class</span> <span class="nc">=</span> <span class="s">&quot;docs.persistence.MyJournal&quot;</span>
  <span class="k">#</span> <span class="nc">Dispatcher</span> <span class="k">for</span> <span class="n">the</span> <span class="n">plugin</span> <span class="n">actor</span><span class="o">.</span>
  <span class="n">plugin</span><span class="o">-</span><span class="n">dispatcher</span> <span class="k">=</span> <span class="s">&quot;akka.actor.default-dispatcher&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The specified plugin <tt class="docutils literal"><span class="pre">class</span></tt> must have a no-arg constructor. The <tt class="docutils literal"><span class="pre">plugin-dispatcher</span></tt> is the dispatcher
used for the plugin actor. If not specified, it defaults to <tt class="docutils literal"><span class="pre">akka.persistence.dispatchers.default-plugin-dispatcher</span></tt>.</p>
<p>The journal plugin instance is an actor so the methods corresponding to requests from persistent actors
are executed sequentially. It may delegate to asynchronous libraries, spawn futures, or delegate to other
actors to achive parallelism.</p>
<p>The journal plugin class must have a constructor without parameters or a constructor with one <tt class="docutils literal"><span class="pre">com.typesafe.config.Config</span></tt>
parameter. The plugin section of the actor system's config will be passed in the config constructor parameter.</p>
<p>Don't run journal tasks/futures on the system default dispatcher, since that might starve other tasks.</p>
</div>
<div class="section" id="snapshot-store-plugin-api">
<h3>Snapshot store plugin API</h3>
<p>A snapshot store plugin must extend the <tt class="docutils literal"><span class="pre">SnapshotStore</span></tt> actor and implement the following methods:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Plugin API: asynchronously loads a snapshot.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is protected with a circuit-breaker.</span>
<span class="cm"> *</span>
<span class="cm"> * @param persistenceId id of the persistent actor.</span>
<span class="cm"> * @param criteria selection criteria for loading.</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">loadAsync</span><span class="o">(</span><span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">criteria</span><span class="k">:</span> <span class="kt">SnapshotSelectionCriteria</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">SelectedSnapshot</span><span class="o">]]</span>

<span class="cm">/**</span>
<span class="cm"> * Plugin API: asynchronously saves a snapshot.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is protected with a circuit-breaker.</span>
<span class="cm"> *</span>
<span class="cm"> * @param metadata snapshot metadata.</span>
<span class="cm"> * @param snapshot snapshot.</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">saveAsync</span><span class="o">(</span><span class="n">metadata</span><span class="k">:</span> <span class="kt">SnapshotMetadata</span><span class="o">,</span> <span class="n">snapshot</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="cm">/**</span>
<span class="cm"> * Plugin API: deletes the snapshot identified by `metadata`.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is protected with a circuit-breaker.</span>
<span class="cm"> *</span>
<span class="cm"> * @param metadata snapshot metadata.</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">deleteAsync</span><span class="o">(</span><span class="n">metadata</span><span class="k">:</span> <span class="kt">SnapshotMetadata</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="cm">/**</span>
<span class="cm"> * Plugin API: deletes all snapshots matching `criteria`.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is protected with a circuit-breaker.</span>
<span class="cm"> *</span>
<span class="cm"> * @param persistenceId id of the persistent actor.</span>
<span class="cm"> * @param criteria selection criteria for deleting.</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">deleteAsync</span><span class="o">(</span><span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">criteria</span><span class="k">:</span> <span class="kt">SnapshotSelectionCriteria</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="cm">/**</span>
<span class="cm"> * Plugin API</span>
<span class="cm"> * Allows plugin implementers to use `f pipeTo self` and</span>
<span class="cm"> * handle additional messages for implementing advanced features</span>
<span class="cm"> */</span>
<span class="k">def</span> <span class="n">receivePluginInternal</span><span class="k">:</span> <span class="kt">Actor.Receive</span> <span class="o">=</span> <span class="nc">Actor</span><span class="o">.</span><span class="n">emptyBehavior</span>
</pre></div>
</div>
<p>A snapshot store plugin can be activated with the following minimal configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">Path</span> <span class="n">to</span> <span class="n">the</span> <span class="n">snapshot</span> <span class="n">store</span> <span class="n">plugin</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">snapshot</span><span class="o">-</span><span class="n">store</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;my-snapshot-store&quot;</span>

<span class="k">#</span> <span class="nc">My</span> <span class="n">custom</span> <span class="n">snapshot</span> <span class="n">store</span> <span class="n">plugin</span>
<span class="n">my</span><span class="o">-</span><span class="n">snapshot</span><span class="o">-</span><span class="n">store</span> <span class="o">{</span>
  <span class="k">#</span> <span class="nc">Class</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">plugin</span><span class="o">.</span>
  <span class="k">class</span> <span class="nc">=</span> <span class="s">&quot;docs.persistence.MySnapshotStore&quot;</span>
  <span class="k">#</span> <span class="nc">Dispatcher</span> <span class="k">for</span> <span class="n">the</span> <span class="n">plugin</span> <span class="n">actor</span><span class="o">.</span>
  <span class="n">plugin</span><span class="o">-</span><span class="n">dispatcher</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.dispatchers.default-plugin-dispatcher&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The specified plugin <tt class="docutils literal"><span class="pre">class</span></tt> must have a no-arg constructor. The <tt class="docutils literal"><span class="pre">plugin-dispatcher</span></tt> is the dispatcher
used for the plugin actor. If not specified, it defaults to <tt class="docutils literal"><span class="pre">akka.persistence.dispatchers.default-plugin-dispatcher</span></tt>.</p>
<p>The snapshot store instance is an actor so the methods corresponding to requests from persistent actors
are executed sequentially. It may delegate to asynchronous libraries, spawn futures, or delegate to other
actors to achive parallelism.</p>
<p>The snapshot store plugin class must have a constructor without parameters or a constructor with one <tt class="docutils literal"><span class="pre">com.typesafe.config.Config</span></tt>
parameter. The plugin section of the actor system's config will be passed in the config constructor parameter.</p>
<p>Don't run snapshot store tasks/futures on the system default dispatcher, since that might starve other tasks.</p>
</div>
<div class="section" id="plugin-tck">
<h3>Plugin TCK</h3>
<p>In order to help developers build correct and high quality storage plugins, we provide a Technology Compatibility Kit (<a class="reference external" href="http://en.wikipedia.org/wiki/Technology_Compatibility_Kit">TCK</a> for short).</p>
<p>The TCK is usable from Java as well as Scala projects. For Scala you need to include the akka-persistence-tck dependency:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-persistence-tck&quot;</span> <span class="o">%</span> <span class="s">&quot;2.4.11&quot;</span> <span class="o">%</span> <span class="s">&quot;test&quot;</span>
</pre></div>
</div>
<p>To include the Journal TCK tests in your test suite simply extend the provided <tt class="docutils literal"><span class="pre">JournalSpec</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyJournalSpec</span> <span class="k">extends</span> <span class="nc">JournalSpec</span><span class="o">(</span>
  <span class="n">config</span> <span class="k">=</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span>
    <span class="s">&quot;&quot;&quot;akka.persistence.journal.plugin = &quot;my.journal.plugin&quot;&quot;&quot;&quot;</span><span class="o">))</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">supportsRejectingNonSerializableObjects</span><span class="k">:</span> <span class="kt">CapabilityFlag</span> <span class="o">=</span>
    <span class="kc">false</span> <span class="c1">// or CapabilityFlag.off</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Please note that some of the tests are optional, and by overriding the <tt class="docutils literal"><span class="pre">supports...</span></tt> methods you give the
TCK the needed information about which tests to run. You can implement these methods using boolean falues or the
provided <tt class="docutils literal"><span class="pre">CapabilityFlag.on</span></tt> / <tt class="docutils literal"><span class="pre">CapabilityFlag.off</span></tt> values.</p>
<p>We also provide a simple benchmarking class <tt class="docutils literal"><span class="pre">JournalPerfSpec</span></tt> which includes all the tests that <tt class="docutils literal"><span class="pre">JournalSpec</span></tt>
has, and also performs some longer operations on the Journal while printing its performance stats. While it is NOT aimed
to provide a proper benchmarking environment it can be used to get a rough feel about your journal's performance in the most
typical scenarios.</p>
<p>In order to include the <tt class="docutils literal"><span class="pre">SnapshotStore</span></tt> TCK tests in your test suite simply extend the <tt class="docutils literal"><span class="pre">SnapshotStoreSpec</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MySnapshotStoreSpec</span> <span class="k">extends</span> <span class="nc">SnapshotStoreSpec</span><span class="o">(</span>
  <span class="n">config</span> <span class="k">=</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span>
    <span class="s">&quot;&quot;&quot;</span>
<span class="s">    akka.persistence.snapshot-store.plugin = &quot;my.snapshot-store.plugin&quot;</span>
<span class="s">    &quot;&quot;&quot;</span><span class="o">))</span>
</pre></div>
</div>
<p>In case your plugin requires some setting up (starting a mock database, removing temporary files etc.) you can override the
<tt class="docutils literal"><span class="pre">beforeAll</span></tt> and <tt class="docutils literal"><span class="pre">afterAll</span></tt> methods to hook into the tests lifecycle:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyJournalSpec</span> <span class="k">extends</span> <span class="nc">JournalSpec</span><span class="o">(</span>
  <span class="n">config</span> <span class="k">=</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span>
    <span class="s">&quot;&quot;&quot;</span>
<span class="s">    akka.persistence.journal.plugin = &quot;my.journal.plugin&quot;</span>
<span class="s">    &quot;&quot;&quot;</span><span class="o">))</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">supportsRejectingNonSerializableObjects</span><span class="k">:</span> <span class="kt">CapabilityFlag</span> <span class="o">=</span>
    <span class="kc">true</span> <span class="c1">// or CapabilityFlag.on</span>

  <span class="k">val</span> <span class="n">storageLocations</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
    <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">system</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getString</span><span class="o">(</span><span class="s">&quot;akka.persistence.journal.leveldb.dir&quot;</span><span class="o">)),</span>
    <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">getString</span><span class="o">(</span><span class="s">&quot;akka.persistence.snapshot-store.local.dir&quot;</span><span class="o">)))</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">beforeAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">super</span><span class="o">.</span><span class="n">beforeAll</span><span class="o">()</span>
    <span class="n">storageLocations</span> <span class="n">foreach</span> <span class="nc">FileUtils</span><span class="o">.</span><span class="n">deleteRecursively</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">afterAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">storageLocations</span> <span class="n">foreach</span> <span class="nc">FileUtils</span><span class="o">.</span><span class="n">deleteRecursively</span>
    <span class="k">super</span><span class="o">.</span><span class="n">afterAll</span><span class="o">()</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>We <em>highly recommend</em> including these specifications in your test suite, as they cover a broad range of cases you
might have otherwise forgotten to test for when writing a plugin from scratch.</p>
</div>
</div>
<div class="section" id="pre-packaged-plugins">
<span id="id10"></span><h2>Pre-packaged plugins</h2>
<div class="section" id="local-leveldb-journal">
<span id="id11"></span><h3>Local LevelDB journal</h3>
<p>The LevelDB journal plugin config entry is <tt class="docutils literal"><span class="pre">akka.persistence.journal.leveldb</span></tt>. It writes messages to a local LevelDB
instance. Enable this plugin by defining config property:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">Path</span> <span class="n">to</span> <span class="n">the</span> <span class="n">journal</span> <span class="n">plugin</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.journal.leveldb&quot;</span>
</pre></div>
</div>
<p>LevelDB based plugins will also require the following additional dependency declaration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;org.iq80.leveldb&quot;</span>            <span class="o">%</span> <span class="s">&quot;leveldb&quot;</span>          <span class="o">%</span> <span class="s">&quot;0.7&quot;</span>
<span class="s">&quot;org.fusesource.leveldbjni&quot;</span>   <span class="o">%</span> <span class="s">&quot;leveldbjni-all&quot;</span>   <span class="o">%</span> <span class="s">&quot;1.8&quot;</span>
</pre></div>
</div>
<p>The default location of LevelDB files is a directory named <tt class="docutils literal"><span class="pre">journal</span></tt> in the current working
directory. This location can be changed by configuration where the specified path can be relative or absolute:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">leveldb</span><span class="o">.</span><span class="n">dir</span> <span class="k">=</span> <span class="s">&quot;target/journal&quot;</span>
</pre></div>
</div>
<p>With this plugin, each actor system runs its own private LevelDB instance.</p>
</div>
<div class="section" id="shared-leveldb-journal">
<span id="id12"></span><h3>Shared LevelDB journal</h3>
<p>A LevelDB instance can also be shared by multiple actor systems (on the same or on different nodes). This, for
example, allows persistent actors to failover to a backup node and continue using the shared journal instance from the
backup node.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A shared LevelDB instance is a single point of failure and should therefore only be used for testing
purposes. Highly-available, replicated journals are available as <a class="reference external" href="http://akka.io/community/">Community plugins</a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This plugin has been supplanted by <a class="reference internal" href="#persistence-plugin-proxy"><em>Persistence Plugin Proxy</em></a>.</p>
</div>
<p>A shared LevelDB instance is started by instantiating the <tt class="docutils literal"><span class="pre">SharedLeveldbStore</span></tt> actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.persistence.journal.leveldb.SharedLeveldbStore</span>

<span class="k">val</span> <span class="n">store</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">SharedLeveldbStore</span><span class="o">],</span> <span class="s">&quot;store&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>By default, the shared instance writes journaled messages to a local directory named <tt class="docutils literal"><span class="pre">journal</span></tt> in the current
working directory. The storage location can be changed by configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">leveldb</span><span class="o">-</span><span class="n">shared</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">dir</span> <span class="k">=</span> <span class="s">&quot;target/shared&quot;</span>
</pre></div>
</div>
<p>Actor systems that use a shared LevelDB store must activate the <tt class="docutils literal"><span class="pre">akka.persistence.journal.leveldb-shared</span></tt>
plugin.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.journal.leveldb-shared&quot;</span>
</pre></div>
</div>
<p>This plugin must be initialized by injecting the (remote) <tt class="docutils literal"><span class="pre">SharedLeveldbStore</span></tt> actor reference. Injection is
done by calling the <tt class="docutils literal"><span class="pre">SharedLeveldbJournal.setStore</span></tt> method with the actor reference as argument.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">trait</span> <span class="nc">SharedStoreUsage</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;akka.tcp://example@127.0.0.1:2552/user/store&quot;</span><span class="o">)</span> <span class="o">!</span> <span class="nc">Identify</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ActorIdentity</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="nc">SharedLeveldbJournal</span><span class="o">.</span><span class="n">setStore</span><span class="o">(</span><span class="n">store</span><span class="o">,</span> <span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Internal journal commands (sent by persistent actors) are buffered until injection completes. Injection is idempotent
i.e. only the first injection is used.</p>
</div>
<div class="section" id="local-snapshot-store">
<span id="id13"></span><h3>Local snapshot store</h3>
<p>The local snapshot store plugin config entry is <tt class="docutils literal"><span class="pre">akka.persistence.snapshot-store.local</span></tt>. It writes snapshot files to
the local filesystem. Enable this plugin by defining config property:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">Path</span> <span class="n">to</span> <span class="n">the</span> <span class="n">snapshot</span> <span class="n">store</span> <span class="n">plugin</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">snapshot</span><span class="o">-</span><span class="n">store</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.snapshot-store.local&quot;</span>
</pre></div>
</div>
<p>The default storage location is a directory named <tt class="docutils literal"><span class="pre">snapshots</span></tt> in the current working
directory. This can be changed by configuration where the specified path can be relative or absolute:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">snapshot</span><span class="o">-</span><span class="n">store</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">dir</span> <span class="k">=</span> <span class="s">&quot;target/snapshots&quot;</span>
</pre></div>
</div>
<p>Note that it is not mandatory to specify a snapshot store plugin. If you don't use snapshots
you don't have to configure it.</p>
</div>
<div class="section" id="persistence-plugin-proxy">
<span id="id14"></span><h3>Persistence Plugin Proxy</h3>
<p>A persistence plugin proxy allows sharing of journals and snapshot stores across multiple actor systems (on the same or
on different nodes). This, for example, allows persistent actors to failover to a backup node and continue using the
shared journal instance from the backup node. The proxy works by forwarding all the journal/snapshot store messages to a
single, shared, persistence plugin instance, and therefor supports any use case supported by the proxied plugin.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A shared journal/snapshot store is a single point of failure and should therefore only be used for testing
purposes. Highly-available, replicated persistence plugins are available as <a class="reference external" href="http://akka.io/community/">Community plugins</a>.</p>
</div>
<p>The journal and snapshot store proxies are controlled via the <tt class="docutils literal"><span class="pre">akka.persistence.journal.proxy</span></tt> and
<tt class="docutils literal"><span class="pre">akka.persistence.snapshot-store.proxy</span></tt> configuration entries, respectively. Set the <tt class="docutils literal"><span class="pre">target-journal-plugin</span></tt> or
<tt class="docutils literal"><span class="pre">target-snapshot-store-plugin</span></tt> keys to the underlying plugin you wish to use (for example:
<tt class="docutils literal"><span class="pre">akka.persistence.journal.leveldb</span></tt>). The <tt class="docutils literal"><span class="pre">start-target-journal</span></tt> and <tt class="docutils literal"><span class="pre">start-target-snapshot-store</span></tt> keys should be
set to <tt class="docutils literal"><span class="pre">on</span></tt> in exactly one actor system - this is the system that will instantiate the shared persistence plugin.
Next, the proxy needs to be told how to find the shared plugin. This can be done by setting the <tt class="docutils literal"><span class="pre">target-journal-address</span></tt>
and <tt class="docutils literal"><span class="pre">target-snapshot-store-address</span></tt> configuration keys, or programmatically by calling the
<tt class="docutils literal"><span class="pre">PersistencePluginProxy.setTargetLocation</span></tt> method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Akka starts extensions lazily when they are required, and this includes the proxy. This means that in order for the
proxy to work, the persistence plugin on the target node must be instantiated. This can be done by instantiating the
<tt class="docutils literal"><span class="pre">PersistencePluginProxyExtension</span></tt> <a class="reference internal" href="extending-akka.html#extending-akka-scala"><em>extension</em></a>, or by calling the <tt class="docutils literal"><span class="pre">PersistencePluginProxy.start</span></tt> method.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The proxied persistence plugin can (and should) be configured using its original configuration keys.</p>
</div>
</div>
</div>
<div class="section" id="custom-serialization">
<span id="id15"></span><h2>Custom serialization</h2>
<p>Serialization of snapshots and payloads of <tt class="docutils literal"><span class="pre">Persistent</span></tt> messages is configurable with Akka's
<a class="reference internal" href="serialization.html#serialization-scala"><em>Serialization</em></a> infrastructure. For example, if an application wants to serialize</p>
<ul class="simple">
<li>payloads of type <tt class="docutils literal"><span class="pre">MyPayload</span></tt> with a custom <tt class="docutils literal"><span class="pre">MyPayloadSerializer</span></tt> and</li>
<li>snapshots of type <tt class="docutils literal"><span class="pre">MySnapshot</span></tt> with a custom <tt class="docutils literal"><span class="pre">MySnapshotSerializer</span></tt></li>
</ul>
<p>it must add</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span> <span class="o">{</span>
  <span class="n">serializers</span> <span class="o">{</span>
    <span class="n">my</span><span class="o">-</span><span class="n">payload</span> <span class="k">=</span> <span class="s">&quot;docs.persistence.MyPayloadSerializer&quot;</span>
    <span class="n">my</span><span class="o">-</span><span class="n">snapshot</span> <span class="k">=</span> <span class="s">&quot;docs.persistence.MySnapshotSerializer&quot;</span>
  <span class="o">}</span>
  <span class="n">serialization</span><span class="o">-</span><span class="n">bindings</span> <span class="o">{</span>
    <span class="s">&quot;docs.persistence.MyPayload&quot;</span> <span class="k">=</span> <span class="n">my</span><span class="o">-</span><span class="n">payload</span>
    <span class="s">&quot;docs.persistence.MySnapshot&quot;</span> <span class="k">=</span> <span class="n">my</span><span class="o">-</span><span class="n">snapshot</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>to the application configuration. If not specified, a default serializer is used.</p>
<p>For more advanced schema evolution techniques refer to the <a class="reference internal" href="persistence-schema-evolution.html#persistence-schema-evolution-scala"><em>Persistence - Schema Evolution</em></a> documentation.</p>
</div>
<div class="section" id="testing">
<h2>Testing</h2>
<p>When running tests with LevelDB default settings in <tt class="docutils literal"><span class="pre">sbt</span></tt>, make sure to set <tt class="docutils literal"><span class="pre">fork</span> <span class="pre">:=</span> <span class="pre">true</span></tt> in your sbt project. Otherwise, you'll see an <tt class="docutils literal"><span class="pre">UnsatisfiedLinkError</span></tt>. Alternatively, you can switch to a LevelDB Java port by setting</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">leveldb</span><span class="o">.</span><span class="n">native</span> <span class="k">=</span> <span class="n">off</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">leveldb</span><span class="o">-</span><span class="n">shared</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">native</span> <span class="k">=</span> <span class="n">off</span>
</pre></div>
</div>
<p>in your Akka configuration. The LevelDB Java port is for testing purposes only.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>It is not possible to test persistence provided classes (i.e. <a class="reference internal" href="#event-sourcing-scala"><em>PersistentActor</em></a>
and <a class="reference internal" href="#at-least-once-delivery-scala"><em>AtLeastOnceDelivery</em></a>) using <tt class="docutils literal"><span class="pre">TestActorRef</span></tt> due to its <em>synchronous</em> nature.
These traits need to be able to perform asynchronous tasks in the background in order to handle internal persistence
related events.</p>
<p class="last">When testing Persistence based projects always rely on <a class="reference internal" href="testing.html#async-integration-testing-scala"><em>asynchronous messaging using the TestKit</em></a>.</p>
</div>
</div>
<div class="section" id="configuration">
<h2>Configuration</h2>
<p>There are several configuration properties for the persistence module, please refer
to the <a class="reference internal" href="../general/configuration.html#config-akka-persistence"><em>reference configuration</em></a>.</p>
</div>
<div class="section" id="multiple-persistence-plugin-configurations">
<h2>Multiple persistence plugin configurations</h2>
<p>By default, a persistent actor or view will use the &quot;default&quot; journal and snapshot store plugins
configured in the following sections of the <tt class="docutils literal"><span class="pre">reference.conf</span></tt> configuration resource:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">Absolute</span> <span class="n">path</span> <span class="n">to</span> <span class="n">the</span> <span class="n">default</span> <span class="n">journal</span> <span class="n">plugin</span> <span class="n">configuration</span> <span class="n">entry</span><span class="o">.</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">journal</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.journal.inmem&quot;</span>
<span class="k">#</span> <span class="nc">Absolute</span> <span class="n">path</span> <span class="n">to</span> <span class="n">the</span> <span class="n">default</span> <span class="n">snapshot</span> <span class="n">store</span> <span class="n">plugin</span> <span class="n">configuration</span> <span class="n">entry</span><span class="o">.</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">snapshot</span><span class="o">-</span><span class="n">store</span><span class="o">.</span><span class="n">plugin</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.snapshot-store.local&quot;</span>
</pre></div>
</div>
<p>Note that in this case the actor or view overrides only the <tt class="docutils literal"><span class="pre">persistenceId</span></tt> method:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">trait</span> <span class="nc">ActorWithDefaultPlugins</span> <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span> <span class="k">=</span> <span class="s">&quot;123&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>When the persistent actor or view overrides the <tt class="docutils literal"><span class="pre">journalPluginId</span></tt> and <tt class="docutils literal"><span class="pre">snapshotPluginId</span></tt> methods,
the actor or view will be serviced by these specific persistence plugins instead of the defaults:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">trait</span> <span class="nc">ActorWithOverridePlugins</span> <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span> <span class="k">=</span> <span class="s">&quot;123&quot;</span>
  <span class="c1">// Absolute path to the journal plugin configuration entry in the `reference.conf`.</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">journalPluginId</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.chronicle.journal&quot;</span>
  <span class="c1">// Absolute path to the snapshot store plugin configuration entry in the `reference.conf`.</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">snapshotPluginId</span> <span class="k">=</span> <span class="s">&quot;akka.persistence.chronicle.snapshot-store&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">journalPluginId</span></tt> and <tt class="docutils literal"><span class="pre">snapshotPluginId</span></tt> must refer to properly configured <tt class="docutils literal"><span class="pre">reference.conf</span></tt>
plugin entries with a standard <tt class="docutils literal"><span class="pre">class</span></tt> property as well as settings which are specific for those plugins, i.e.:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">Configuration</span> <span class="n">entry</span> <span class="k">for</span> <span class="n">the</span> <span class="n">custom</span> <span class="n">journal</span> <span class="n">plugin</span><span class="o">,</span> <span class="n">see</span> <span class="n">`journalPluginId`</span><span class="o">.</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">chronicle</span><span class="o">.</span><span class="n">journal</span> <span class="o">{</span>
  <span class="k">#</span> <span class="nc">Standard</span> <span class="n">persistence</span> <span class="n">extension</span> <span class="n">property</span><span class="k">:</span> <span class="kt">provider</span> <span class="kt">FQCN.</span>
  <span class="kt">class</span> <span class="o">=</span> <span class="s">&quot;akka.persistence.chronicle.ChronicleSyncJournal&quot;</span>
  <span class="k">#</span> <span class="nc">Custom</span> <span class="n">setting</span> <span class="n">specific</span> <span class="k">for</span> <span class="n">the</span> <span class="n">journal</span> <span class="n">`ChronicleSyncJournal`</span><span class="o">.</span>
  <span class="n">folder</span> <span class="k">=</span> <span class="n">$$</span><span class="o">{</span><span class="n">user</span><span class="o">.</span><span class="n">dir</span><span class="o">}/</span><span class="n">store</span><span class="o">/</span><span class="n">journal</span>
<span class="o">}</span>
<span class="k">#</span> <span class="nc">Configuration</span> <span class="n">entry</span> <span class="k">for</span> <span class="n">the</span> <span class="n">custom</span> <span class="n">snapshot</span> <span class="n">store</span> <span class="n">plugin</span><span class="o">,</span> <span class="n">see</span> <span class="n">`snapshotPluginId`</span><span class="o">.</span>
<span class="n">akka</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="n">chronicle</span><span class="o">.</span><span class="n">snapshot</span><span class="o">-</span><span class="n">store</span> <span class="o">{</span>
  <span class="k">#</span> <span class="nc">Standard</span> <span class="n">persistence</span> <span class="n">extension</span> <span class="n">property</span><span class="k">:</span> <span class="kt">provider</span> <span class="kt">FQCN.</span>
  <span class="kt">class</span> <span class="o">=</span> <span class="s">&quot;akka.persistence.chronicle.ChronicleSnapshotStore&quot;</span>
  <span class="k">#</span> <span class="nc">Custom</span> <span class="n">setting</span> <span class="n">specific</span> <span class="k">for</span> <span class="n">the</span> <span class="n">snapshot</span> <span class="n">store</span> <span class="n">`ChronicleSnapshotStore`</span><span class="o">.</span>
  <span class="n">folder</span> <span class="k">=</span> <span class="n">$$</span><span class="o">{</span><span class="n">user</span><span class="o">.</span><span class="n">dir</span><span class="o">}/</span><span class="n">store</span><span class="o">/</span><span class="n">snapshot</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>