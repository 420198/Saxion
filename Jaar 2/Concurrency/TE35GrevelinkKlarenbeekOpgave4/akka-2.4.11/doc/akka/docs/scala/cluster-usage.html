


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cluster Usage &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Networking" href="index-network.html" />
    <link rel="next" title="Cluster Singleton" href="cluster-singleton.html" />
    <link rel="prev" title="Cluster Specification" href="../common/cluster.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Cluster Usage</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="cluster-singleton.html">Cluster Singleton</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="../common/cluster.html">Cluster Specification</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="cluster-usage">
<span id="cluster-usage-scala"></span><h1>Cluster Usage</h1>
<p>For introduction to the Akka Cluster concepts please see <a class="reference internal" href="../common/cluster.html#cluster"><em>Cluster Specification</em></a>.</p>
<div class="section" id="preparing-your-project-for-clustering">
<h2>Preparing Your Project for Clustering</h2>
<p>The Akka cluster is a separate jar file. Make sure that you have the following dependency in your project:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-cluster&quot;</span> <span class="o">%</span> <span class="s">&quot;2.4.11&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="a-simple-cluster-example">
<h2>A Simple Cluster Example</h2>
<p>The following configuration enables the <tt class="docutils literal"><span class="pre">Cluster</span></tt> extension to be used.
It joins the cluster and an actor subscribes to cluster membership events and logs them.</p>
<p>The <tt class="docutils literal"><span class="pre">application.conf</span></tt> configuration looks like this:</p>
<div class="highlight-scala"><pre>akka {
  actor {
    provider = cluster
  }
  remote {
    log-remote-lifecycle-events = off
    netty.tcp {
      hostname = "127.0.0.1"
      port = 0
    }
  }

  cluster {
    seed-nodes = [
      "akka.tcp://ClusterSystem@127.0.0.1:2551",
      "akka.tcp://ClusterSystem@127.0.0.1:2552"]

    # auto downing is NOT safe for production deployments.
    # you may want to use it during development, read more about it in the docs.
    #
    # auto-down-unreachable-after = 10s
  }
}

# Disable legacy metrics in akka-cluster.
akka.cluster.metrics.enabled=off

# Enable metrics extension in akka-cluster-metrics.
akka.extensions=["akka.cluster.metrics.ClusterMetricsExtension"]

# Sigar native library extract location during tests.
# Note: use per-jvm-instance folder when running multiple jvm on one host.
akka.cluster.metrics.native-library-extract-folder=${user.dir}/target/native
</pre>
</div>
<p>To enable cluster capabilities in your Akka project you should, at a minimum, add the <a class="reference internal" href="remoting.html#remoting-scala"><em>Remoting</em></a>
settings, but with <tt class="docutils literal"><span class="pre">cluster</span></tt>.
The <tt class="docutils literal"><span class="pre">akka.cluster.seed-nodes</span></tt> should normally also be added to your <tt class="docutils literal"><span class="pre">application.conf</span></tt> file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are running Akka in a Docker container or the nodes for some other reason have separate internal and
external ip addresses you must configure remoting according to <a class="reference internal" href="remoting.html#remote-configuration-nat"><em>Akka behind NAT or in a Docker container</em></a></p>
</div>
<p>The seed nodes are configured contact points for initial, automatic, join of the cluster.</p>
<p>Note that if you are going to start the nodes on different machines you need to specify the
ip-addresses or host names of the machines in <tt class="docutils literal"><span class="pre">application.conf</span></tt> instead of <tt class="docutils literal"><span class="pre">127.0.0.1</span></tt></p>
<p>An actor that uses the cluster extension may look like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">package</span> <span class="nn">sample.cluster.simple</span>

<span class="k">import</span> <span class="nn">akka.cluster.Cluster</span>
<span class="k">import</span> <span class="nn">akka.cluster.ClusterEvent._</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorLogging</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>

<span class="k">class</span> <span class="nc">SimpleClusterListener</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">cluster</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">)</span>

  <span class="c1">// subscribe to cluster changes, re-subscribe when restart </span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">//#subscribe</span>
    <span class="n">cluster</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">initialStateMode</span> <span class="k">=</span> <span class="nc">InitialStateAsEvents</span><span class="o">,</span>
      <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberEvent</span><span class="o">],</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">UnreachableMember</span><span class="o">])</span>
    <span class="c1">//#subscribe</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">unsubscribe</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Member is Up: {}&quot;</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="n">address</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">UnreachableMember</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Member detected as unreachable: {}&quot;</span><span class="o">,</span> <span class="n">member</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">MemberRemoved</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="n">previousStatus</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Member is Removed: {} after {}&quot;</span><span class="o">,</span>
        <span class="n">member</span><span class="o">.</span><span class="n">address</span><span class="o">,</span> <span class="n">previousStatus</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">MemberEvent</span> <span class="o">=&gt;</span> <span class="c1">// ignore</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The actor registers itself as subscriber of certain cluster events. It receives events corresponding to the current state
of the cluster when the subscription starts and then it receives events for changes that happen in the cluster.</p>
<p>The easiest way to run this example yourself is to download <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a>
and open the tutorial named <a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-cluster-scala">Akka Cluster Samples with Scala</a>.
It contains instructions of how to run the <tt class="docutils literal"><span class="pre">SimpleClusterApp</span></tt>.</p>
</div>
<div class="section" id="joining-to-seed-nodes">
<h2>Joining to Seed Nodes</h2>
<p>You may decide if joining to the cluster should be done manually or automatically
to configured initial contact points, so-called seed nodes. When a new node is started
it sends a message to all seed nodes and then sends join command to the one that
answers first. If no one of the seed nodes replied (might not be started yet)
it retries this procedure until successful or shutdown.</p>
<p>You define the seed nodes in the <a class="reference internal" href="#cluster-configuration-scala"><em>Configuration</em></a> file (application.conf):</p>
<div class="highlight-scala"><pre>akka.cluster.seed-nodes = [
  "akka.tcp://ClusterSystem@host1:2552",
  "akka.tcp://ClusterSystem@host2:2552"]</pre>
</div>
<p>This can also be defined as Java system properties when starting the JVM using the following syntax:</p>
<div class="highlight-scala"><pre>-Dakka.cluster.seed-nodes.0=akka.tcp://ClusterSystem@host1:2552
-Dakka.cluster.seed-nodes.1=akka.tcp://ClusterSystem@host2:2552</pre>
</div>
<p>The seed nodes can be started in any order and it is not necessary to have all
seed nodes running, but the node configured as the first element in the <tt class="docutils literal"><span class="pre">seed-nodes</span></tt>
configuration list must be started when initially starting a cluster, otherwise the
other seed-nodes will not become initialized and no other node can join the cluster.
The reason for the special first seed node is to avoid forming separated islands when
starting from an empty cluster.
It is quickest to start all configured seed nodes at the same time (order doesn't matter),
otherwise it can take up to the configured <tt class="docutils literal"><span class="pre">seed-node-timeout</span></tt> until the nodes
can join.</p>
<p>Once more than two seed nodes have been started it is no problem to shut down the first
seed node. If the first seed node is restarted, it will first try to join the other
seed nodes in the existing cluster.</p>
<p>If you don't configure seed nodes you need to join the cluster programmatically or manually.</p>
<p>Manual joining can be performed by using ref:<cite>cluster_jmx_scala</cite> or <a class="reference internal" href="#cluster-command-line-scala"><em>Command Line Management</em></a>.
Joining programmatically can be performed with <tt class="docutils literal"><span class="pre">Cluster(system).join</span></tt>. Unsuccessful join attempts are
automatically retried after the time period defined in configuration property <tt class="docutils literal"><span class="pre">retry-unsuccessful-join-after</span></tt>.
Retries can be disabled by setting the property to <tt class="docutils literal"><span class="pre">off</span></tt>.</p>
<p>You can join to any node in the cluster. It does not have to be configured as a seed node.
Note that you can only join to an existing cluster member, which means that for bootstrapping some
node must join itself,and then the following nodes could join them to make up a cluster.</p>
<p>You may also use <tt class="docutils literal"><span class="pre">Cluster(system).joinSeedNodes</span></tt> to join programmatically,
which is attractive when dynamically discovering other nodes at startup by using some external tool or API.
When using <tt class="docutils literal"><span class="pre">joinSeedNodes</span></tt> you should not include the node itself except for the node that is
supposed to be the first seed node, and that should be placed first in parameter to
<tt class="docutils literal"><span class="pre">joinSeedNodes</span></tt>.</p>
<p>Unsuccessful attempts to contact seed nodes are automatically retried after the time period defined in
configuration property <tt class="docutils literal"><span class="pre">seed-node-timeout</span></tt>. Unsuccessful attempt to join a specific seed node is
automatically retried after the configured <tt class="docutils literal"><span class="pre">retry-unsuccessful-join-after</span></tt>. Retrying means that it
tries to contact all seed nodes and then joins the node that answers first. The first node in the list
of seed nodes will join itself if it cannot contact any of the other seed nodes within the
configured <tt class="docutils literal"><span class="pre">seed-node-timeout</span></tt>.</p>
<p>An actor system can only join a cluster once. Additional attempts will be ignored.
When it has successfully joined it must be restarted to be able to join another
cluster or to join the same cluster again.It can use the same host name and port
after the restart, when it come up as new incarnation of existing member in the cluster,
trying to join in, then the existing one will be removed from the cluster and then it will
be allowed to join.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The name of the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> must be the same for all members of a cluster. The name is given
when you start the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt>.</p>
</div>
</div>
<div class="section" id="downing">
<span id="automatic-vs-manual-downing-scala"></span><h2>Downing</h2>
<p>When a member is considered by the failure detector to be unreachable the
leader is not allowed to perform its duties, such as changing status of
new joining members to 'Up'. The node must first become reachable again, or the
status of the unreachable member must be changed to 'Down'. Changing status to 'Down'
can be performed automatically or manually. By default it must be done manually, using
<a class="reference internal" href="#cluster-jmx-scala"><em>JMX</em></a> or <a class="reference internal" href="#cluster-command-line-scala"><em>Command Line Management</em></a>.</p>
<p>It can also be performed programmatically with <tt class="docutils literal"><span class="pre">Cluster(system).down(address)</span></tt>.</p>
<p>A pre-packaged solution for the downing problem is provided by
<a class="reference external" href="http://doc.akka.io/docs/akka/akka-commercial-addons-1.0/scala/split-brain-resolver.html">Split Brain Resolver</a>,
which is part of the <a class="reference external" href="http://www.lightbend.com/platform">Lightbend Reactive Platform</a>.
If you don’t use RP, you should anyway carefully read the <a class="reference external" href="http://doc.akka.io/docs/akka/akka-commercial-addons-1.0/scala/split-brain-resolver.html">documentation</a>
of the Split Brain Resolver and make sure that the solution you are using handles the concerns
described there.</p>
<div class="section" id="auto-downing-do-not-use">
<h3>Auto-downing (DO NOT USE)</h3>
<p>There is an atomatic downing feature that you should not use in production. For testing purpose you can enable it with configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">auto</span><span class="o">-</span><span class="n">down</span><span class="o">-</span><span class="n">unreachable</span><span class="o">-</span><span class="n">after</span> <span class="k">=</span> <span class="mi">120</span><span class="n">s</span>
</pre></div>
</div>
<p>This means that the cluster leader member will change the <tt class="docutils literal"><span class="pre">unreachable</span></tt> node
status to <tt class="docutils literal"><span class="pre">down</span></tt> automatically after the configured time of unreachability.</p>
<p>This is a naïve approach to remove unreachable nodes from the cluster membership. It
works great for crashes and short transient network partitions, but not for long network
partitions. Both sides of the network partition will see the other side as unreachable
and after a while remove it from its cluster membership. Since this happens on both
sides the result is that two separate disconnected clusters have been created. This
can also happen because of long GC pauses or system overload.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">We recommend against using the auto-down feature of Akka Cluster in production.
This is crucial for correct behavior if you use <a class="reference internal" href="cluster-singleton.html#cluster-singleton-scala"><em>Cluster Singleton</em></a> or
<a class="reference internal" href="cluster-sharding.html#cluster-sharding-scala"><em>Cluster Sharding</em></a>, especially together with Akka <a class="reference internal" href="persistence.html#persistence-scala"><em>Persistence</em></a>.
For Akka Persistence with Cluster Sharding it can result in corrupt data in case
of network partitions.</p>
</div>
</div>
</div>
<div class="section" id="leaving">
<h2>Leaving</h2>
<p>There are two ways to remove a member from the cluster.</p>
<p>You can just stop the actor system (or the JVM process). It will be detected
as unreachable and removed after the automatic or manual downing as described
above.</p>
<p>A more graceful exit can be performed if you tell the cluster that a node shall leave.
This can be performed using <a class="reference internal" href="#cluster-jmx-scala"><em>JMX</em></a> or <a class="reference internal" href="#cluster-command-line-scala"><em>Command Line Management</em></a>.
It can also be performed programmatically with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">cluster</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="n">cluster</span><span class="o">.</span><span class="n">leave</span><span class="o">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">selfAddress</span><span class="o">)</span>
</pre></div>
</div>
<p>Note that this command can be issued to any member in the cluster, not necessarily the
one that is leaving. The cluster extension, but not the actor system or JVM, of the
leaving member will be shutdown after the leader has changed status of the member to
<cite>Exiting</cite>. Thereafter the member will be removed from the cluster. Normally this is handled
automatically, but in case of network failures during this process it might still be necessary
to set the node’s status to <tt class="docutils literal"><span class="pre">Down</span></tt> in order to complete the removal.</p>
</div>
<div class="section" id="weaklyup-members">
<span id="weakly-up-scala"></span><h2>WeaklyUp Members</h2>
<p>If a node is <tt class="docutils literal"><span class="pre">unreachable</span></tt> then gossip convergence is not possible and therefore any
<tt class="docutils literal"><span class="pre">leader</span></tt> actions are also not possible. However, we still might want new nodes to join
the cluster in this scenario.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The WeaklyUp feature is marked as <strong>“experimental”</strong> as of its introduction in Akka 2.4.0. We will continue to
improve this feature based on our users’ feedback, which implies that while we try to keep incompatible
changes to a minimum the binary compatibility guarantee for maintenance releases does not apply this feature.</p>
</div>
<p>This feature is disabled by default. With a configuration option you can allow this behavior:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">allow</span><span class="o">-</span><span class="n">weakly</span><span class="o">-</span><span class="n">up</span><span class="o">-</span><span class="n">members</span> <span class="k">=</span> <span class="n">on</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">allow-weakly-up-members</span></tt> is enabled and there is no gossip convergence,
<tt class="docutils literal"><span class="pre">Joining</span></tt> members will be promoted to <tt class="docutils literal"><span class="pre">WeaklyUp</span></tt> and they will become part of the
cluster. Once gossip convergence is reached, the leader will move <tt class="docutils literal"><span class="pre">WeaklyUp</span></tt>
members to <tt class="docutils literal"><span class="pre">Up</span></tt>.</p>
<p>You can subscribe to the <tt class="docutils literal"><span class="pre">WeaklyUp</span></tt> membership event to make use of the members that are
in this state, but you should be aware of that members on the other side of a network partition
have no knowledge about the existence of the new members. You should for example not count
<tt class="docutils literal"><span class="pre">WeaklyUp</span></tt> members in quorum decisions.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This feature is only available from Akka 2.4.0 and cannot be used if some of your
cluster members are running an older version of Akka.</p>
</div>
</div>
<div class="section" id="subscribe-to-cluster-events">
<span id="cluster-subscriber-scala"></span><h2>Subscribe to Cluster Events</h2>
<p>You can subscribe to change notifications of the cluster membership by using
<tt class="docutils literal"><span class="pre">Cluster(system).subscribe</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">cluster</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberEvent</span><span class="o">],</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">UnreachableMember</span><span class="o">])</span>
</pre></div>
</div>
<p>A snapshot of the full state, <tt class="docutils literal"><span class="pre">akka.cluster.ClusterEvent.CurrentClusterState</span></tt>, is sent to the subscriber
as the first message, followed by events for incremental updates.</p>
<p>Note that you may receive an empty <tt class="docutils literal"><span class="pre">CurrentClusterState</span></tt>, containing no members,
if you start the subscription before the initial join procedure has completed.
This is expected behavior. When the node has been accepted in the cluster you will
receive <tt class="docutils literal"><span class="pre">MemberUp</span></tt> for that node, and other nodes.</p>
<p>If you find it inconvenient to handle the <tt class="docutils literal"><span class="pre">CurrentClusterState</span></tt> you can use
<tt class="docutils literal"><span class="pre">ClusterEvent.InitialStateAsEvents</span></tt> as parameter to <tt class="docutils literal"><span class="pre">subscribe</span></tt>.
That means that instead of receiving <tt class="docutils literal"><span class="pre">CurrentClusterState</span></tt> as the first message you will receive
the events corresponding to the current state to mimic what you would have seen if you were
listening to the events when they occurred in the past. Note that those initial events only correspond
to the current state and it is not the full history of all changes that actually has occurred in the cluster.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">cluster</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">initialStateMode</span> <span class="k">=</span> <span class="nc">InitialStateAsEvents</span><span class="o">,</span>
  <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberEvent</span><span class="o">],</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">UnreachableMember</span><span class="o">])</span>
</pre></div>
</div>
<p>The events to track the life-cycle of members are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ClusterEvent.MemberJoined</span></tt> - A new member has joined the cluster and its status has been changed to <tt class="docutils literal"><span class="pre">Joining</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.MemberUp</span></tt> - A new member has joined the cluster and its status has been changed to <tt class="docutils literal"><span class="pre">Up</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.MemberExited</span></tt> - A member is leaving the cluster and its status has been changed to <tt class="docutils literal"><span class="pre">Exiting</span></tt>
Note that the node might already have been shutdown when this event is published on another node.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.MemberRemoved</span></tt> - Member completely removed from the cluster.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.UnreachableMember</span></tt> - A member is considered as unreachable, detected by the failure detector
of at least one other node.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.ReachableMember</span></tt> - A member is considered as reachable again, after having been unreachable.
All nodes that previously detected it as unreachable has detected it as reachable again.</li>
</ul>
<p>There are more types of change events, consult the API documentation
of classes that extends <tt class="docutils literal"><span class="pre">akka.cluster.ClusterEvent.ClusterDomainEvent</span></tt>
for details about the events.</p>
<p>Instead of subscribing to cluster events it can sometimes be convenient to only get the full membership state with
<tt class="docutils literal"><span class="pre">Cluster(system).state</span></tt>. Note that this state is not necessarily in sync with the events published to a
cluster subscription.</p>
<div class="section" id="worker-dial-in-example">
<h3>Worker Dial-in Example</h3>
<p>Let's take a look at an example that illustrates how workers, here named <em>backend</em>,
can detect and register to new master nodes, here named <em>frontend</em>.</p>
<p>The example application provides a service to transform text. When some text
is sent to one of the frontend services, it will be delegated to one of the
backend workers, which performs the transformation job, and sends the result back to
the original client. New backend nodes, as well as new frontend nodes, can be
added or removed to the cluster dynamically.</p>
<p>Messages:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">TransformationJob</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">TransformationResult</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JobFailed</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">job</span><span class="k">:</span> <span class="kt">TransformationJob</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BackendRegistration</span>
</pre></div>
</div>
<p>The backend worker that performs the transformation job:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TransformationBackend</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">cluster</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">)</span>

  <span class="c1">// subscribe to cluster changes, MemberUp</span>
  <span class="c1">// re-subscribe when restart</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberUp</span><span class="o">])</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">unsubscribe</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">TransformationJob</span><span class="o">(</span><span class="n">text</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">TransformationResult</span><span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="n">toUpperCase</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">state</span><span class="k">:</span> <span class="kt">CurrentClusterState</span> <span class="o">=&gt;</span>
      <span class="n">state</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="nc">MemberStatus</span><span class="o">.</span><span class="nc">Up</span><span class="o">)</span> <span class="n">foreach</span> <span class="n">register</span>
    <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">register</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">register</span><span class="o">(</span><span class="n">member</span><span class="k">:</span> <span class="kt">Member</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="n">hasRole</span><span class="o">(</span><span class="s">&quot;frontend&quot;</span><span class="o">))</span>
      <span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="nc">RootActorPath</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="n">address</span><span class="o">)</span> <span class="o">/</span> <span class="s">&quot;user&quot;</span> <span class="o">/</span> <span class="s">&quot;frontend&quot;</span><span class="o">)</span> <span class="o">!</span>
        <span class="nc">BackendRegistration</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">TransformationBackend</span></tt> actor subscribes to cluster events to detect new,
potential, frontend nodes, and send them a registration message so that they know
that they can use the backend worker.</p>
<p>The frontend that receives user jobs and delegates to one of the registered backend workers:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TransformationFrontend</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">backends</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">]</span>
  <span class="k">var</span> <span class="n">jobCounter</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">job</span><span class="k">:</span> <span class="kt">TransformationJob</span> <span class="kt">if</span> <span class="kt">backends.isEmpty</span> <span class="o">=&gt;</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">JobFailed</span><span class="o">(</span><span class="s">&quot;Service unavailable, try again later&quot;</span><span class="o">,</span> <span class="n">job</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">job</span><span class="k">:</span> <span class="kt">TransformationJob</span> <span class="o">=&gt;</span>
      <span class="n">jobCounter</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">backends</span><span class="o">(</span><span class="n">jobCounter</span> <span class="o">%</span> <span class="n">backends</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="n">forward</span> <span class="n">job</span>

    <span class="k">case</span> <span class="nc">BackendRegistration</span> <span class="k">if</span> <span class="o">!</span><span class="n">backends</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">sender</span><span class="o">())</span> <span class="k">=&gt;</span>
      <span class="n">context</span> <span class="n">watch</span> <span class="n">sender</span><span class="o">()</span>
      <span class="n">backends</span> <span class="k">=</span> <span class="n">backends</span> <span class="o">:+</span> <span class="n">sender</span><span class="o">()</span>

    <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">backends</span> <span class="k">=</span> <span class="n">backends</span><span class="o">.</span><span class="n">filterNot</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">TransformationFrontend</span></tt> actor watch the registered backend
to be able to remove it from its list of available backend workers.
Death watch uses the cluster failure detector for nodes in the cluster, i.e. it detects
network failures and JVM crashes, in addition to graceful termination of watched
actor. Death watch generates the <tt class="docutils literal"><span class="pre">Terminated</span></tt> message to the watching actor when the
unreachable cluster node has been downed and removed.</p>
<p>The <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a> tutorial named
<a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-cluster-scala">Akka Cluster Samples with Scala</a>.
contains the full source code and instructions of how to run the <strong>Worker Dial-in Example</strong>.</p>
</div>
</div>
<div class="section" id="node-roles">
<h2>Node Roles</h2>
<p>Not all nodes of a cluster need to perform the same function: there might be one sub-set which runs the web front-end,
one which runs the data access layer and one for the number-crunching. Deployment of actors—for example by cluster-aware
routers—can take node roles into account to achieve this distribution of responsibilities.</p>
<p>The roles of a node is defined in the configuration property named <tt class="docutils literal"><span class="pre">akka.cluster.roles</span></tt>
and it is typically defined in the start script as a system property or environment variable.</p>
<p>The roles of the nodes is part of the membership information in <tt class="docutils literal"><span class="pre">MemberEvent</span></tt> that you can subscribe to.</p>
</div>
<div class="section" id="how-to-startup-when-cluster-size-reached">
<h2>How To Startup when Cluster Size Reached</h2>
<p>A common use case is to start actors after the cluster has been initialized,
members have joined, and the cluster has reached a certain size.</p>
<p>With a configuration option you can define required number of members
before the leader changes member status of 'Joining' members to 'Up'.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">min</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">members</span> <span class="k">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In a similar way you can define required number of members of a certain role
before the leader changes member status of 'Joining' members to 'Up'.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">role</span> <span class="o">{</span>
  <span class="n">frontend</span><span class="o">.</span><span class="n">min</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">members</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="n">backend</span><span class="o">.</span><span class="n">min</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">members</span> <span class="k">=</span> <span class="mi">2</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You can start the actors in a <tt class="docutils literal"><span class="pre">registerOnMemberUp</span></tt> callback, which will
be invoked when the current member status is changed to 'Up', i.e. the cluster
has at least the defined number of members.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span> <span class="n">registerOnMemberUp</span> <span class="o">{</span>
  <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">FactorialFrontend</span><span class="o">],</span> <span class="n">upToN</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span>
    <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;factorialFrontend&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This callback can be used for other things than starting actors.</p>
</div>
<div class="section" id="how-to-cleanup-when-member-is-removed">
<h2>How To Cleanup when Member is Removed</h2>
<p>You can do some clean up in a <tt class="docutils literal"><span class="pre">registerOnMemberRemoved</span></tt> callback, which will
be invoked when the current member status is changed to 'Removed' or the cluster have been shutdown.</p>
<p>For example, this is how to shut down the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> and thereafter exit the JVM:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">registerOnMemberRemoved</span> <span class="o">{</span>
  <span class="c1">// exit JVM when ActorSystem has been terminated</span>
  <span class="n">system</span><span class="o">.</span><span class="n">registerOnTermination</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="n">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
  <span class="c1">// shut down ActorSystem</span>
  <span class="n">system</span><span class="o">.</span><span class="n">terminate</span><span class="o">()</span>

  <span class="c1">// In case ActorSystem shutdown takes longer than 10 seconds,</span>
  <span class="c1">// exit the JVM forcefully anyway.</span>
  <span class="c1">// We must spawn a separate thread to not block current thread,</span>
  <span class="c1">// since that would have blocked the shutdown of the ActorSystem.</span>
  <span class="k">new</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="nc">Await</span><span class="o">.</span><span class="n">ready</span><span class="o">(</span><span class="n">system</span><span class="o">.</span><span class="n">whenTerminated</span><span class="o">,</span> <span class="mf">10.</span><span class="n">seconds</span><span class="o">)).</span><span class="n">isFailure</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="n">exit</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}.</span><span class="n">start</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Register a OnMemberRemoved callback on a cluster that have been shutdown, the callback will be invoked immediately on
the caller thread, otherwise it will be invoked later when the current member status changed to 'Removed'. You may
want to install some cleanup handling after the cluster was started up, but the cluster might already be shutting
down when you installing, and depending on the race is not healthy.</p>
</div>
</div>
<div class="section" id="cluster-singleton">
<h2>Cluster Singleton</h2>
<p>For some use cases it is convenient and sometimes also mandatory to ensure that
you have exactly one actor of a certain type running somewhere in the cluster.</p>
<p>This can be implemented by subscribing to member events, but there are several corner
cases to consider. Therefore, this specific use case is made easily accessible by the
<a class="reference internal" href="cluster-singleton.html#cluster-singleton-scala"><em>Cluster Singleton</em></a>.</p>
</div>
<div class="section" id="cluster-sharding">
<h2>Cluster Sharding</h2>
<p>Distributes actors across several nodes in the cluster and supports interaction
with the actors using their logical identifier, but without having to care about
their physical location in the cluster.</p>
<p>See <a class="reference internal" href="cluster-sharding.html#cluster-sharding-scala"><em>Cluster Sharding</em></a></p>
</div>
<div class="section" id="distributed-publish-subscribe">
<h2>Distributed Publish Subscribe</h2>
<p>Publish-subscribe messaging between actors in the cluster, and point-to-point messaging
using the logical path of the actors, i.e. the sender does not have to know on which
node the destination actor is running.</p>
<p>See <a class="reference internal" href="distributed-pub-sub.html#distributed-pub-sub-scala"><em>Distributed Publish Subscribe in Cluster</em></a>.</p>
</div>
<div class="section" id="cluster-client">
<h2>Cluster Client</h2>
<p>Communication from an actor system that is not part of the cluster to actors running
somewhere in the cluster. The client does not have to know on which node the destination
actor is running.</p>
<p>See <a class="reference internal" href="cluster-client.html#cluster-client-scala"><em>Cluster Client</em></a>.</p>
</div>
<div class="section" id="distributed-data">
<h2>Distributed Data</h2>
<p><em>Akka Distributed Data</em> is useful when you need to share data between nodes in an
Akka Cluster. The data is accessed with an actor providing a key-value store like API.</p>
<p>See <a class="reference internal" href="distributed-data.html#distributed-data-scala"><em>Distributed Data</em></a>.</p>
</div>
<div class="section" id="failure-detector">
<h2>Failure Detector</h2>
<p>In a cluster each node is monitored by a few (default maximum 5) other nodes, and when
any of these detects the node as <tt class="docutils literal"><span class="pre">unreachable</span></tt> that information will spread to
the rest of the cluster through the gossip. In other words, only one node needs to
mark a node <tt class="docutils literal"><span class="pre">unreachable</span></tt> to have the rest of the cluster mark that node <tt class="docutils literal"><span class="pre">unreachable</span></tt>.</p>
<p>The failure detector will also detect if the node becomes <tt class="docutils literal"><span class="pre">reachable</span></tt> again. When
all nodes that monitored the <tt class="docutils literal"><span class="pre">unreachable</span></tt> node detects it as <tt class="docutils literal"><span class="pre">reachable</span></tt> again
the cluster, after gossip dissemination, will consider it as <tt class="docutils literal"><span class="pre">reachable</span></tt>.</p>
<p>If system messages cannot be delivered to a node it will be quarantined and then it
cannot come back from <tt class="docutils literal"><span class="pre">unreachable</span></tt>. This can happen if the there are too many
unacknowledged system messages (e.g. watch, Terminated, remote actor deployment,
failures of actors supervised by remote parent). Then the node needs to be moved
to the <tt class="docutils literal"><span class="pre">down</span></tt> or <tt class="docutils literal"><span class="pre">removed</span></tt> states and the actor system of the quarantined node
must be restarted before it can join the cluster again.</p>
<p>The nodes in the cluster monitor each other by sending heartbeats to detect if a node is
unreachable from the rest of the cluster. The heartbeat arrival times is interpreted
by an implementation of
<a class="reference external" href="http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf">The Phi Accrual Failure Detector</a>.</p>
<p>The suspicion level of failure is given by a value called <em>phi</em>.
The basic idea of the phi failure detector is to express the value of <em>phi</em> on a scale that
is dynamically adjusted to reflect current network conditions.</p>
<p>The value of <em>phi</em> is calculated as:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">phi</span> <span class="k">=</span> <span class="o">-</span><span class="n">log10</span><span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="o">(</span><span class="n">timeSinceLastHeartbeat</span><span class="o">))</span>
</pre></div>
</div>
<p>where F is the cumulative distribution function of a normal distribution with mean
and standard deviation estimated from historical heartbeat inter-arrival times.</p>
<p>In the <a class="reference internal" href="#cluster-configuration-scala"><em>Configuration</em></a> you can adjust the <tt class="docutils literal"><span class="pre">akka.cluster.failure-detector.threshold</span></tt>
to define when a <em>phi</em> value is considered to be a failure.</p>
<p>A low <tt class="docutils literal"><span class="pre">threshold</span></tt> is prone to generate many false positives but ensures
a quick detection in the event of a real crash. Conversely, a high <tt class="docutils literal"><span class="pre">threshold</span></tt>
generates fewer mistakes but needs more time to detect actual crashes. The
default <tt class="docutils literal"><span class="pre">threshold</span></tt> is 8 and is appropriate for most situations. However in
cloud environments, such as Amazon EC2, the value could be increased to 12 in
order to account for network issues that sometimes occur on such platforms.</p>
<p>The following chart illustrates how <em>phi</em> increase with increasing time since the
previous heartbeat.</p>
<img alt="../_images/phi11.png" src="../_images/phi11.png" />
<p>Phi is calculated from the mean and standard deviation of historical
inter arrival times. The previous chart is an example for standard deviation
of 200 ms. If the heartbeats arrive with less deviation the curve becomes steeper,
i.e. it is possible to determine failure more quickly. The curve looks like this for
a standard deviation of 100 ms.</p>
<img alt="../_images/phi21.png" src="../_images/phi21.png" />
<p>To be able to survive sudden abnormalities, such as garbage collection pauses and
transient network failures the failure detector is configured with a margin,
<tt class="docutils literal"><span class="pre">akka.cluster.failure-detector.acceptable-heartbeat-pause</span></tt>. You may want to
adjust the <a class="reference internal" href="#cluster-configuration-scala"><em>Configuration</em></a> of this depending on you environment.
This is how the curve looks like for <tt class="docutils literal"><span class="pre">acceptable-heartbeat-pause</span></tt> configured to
3 seconds.</p>
<img alt="../_images/phi31.png" src="../_images/phi31.png" />
<p>Death watch uses the cluster failure detector for nodes in the cluster, i.e. it detects
network failures and JVM crashes, in addition to graceful termination of watched
actor. Death watch generates the <tt class="docutils literal"><span class="pre">Terminated</span></tt> message to the watching actor when the
unreachable cluster node has been downed and removed.</p>
<p>If you encounter suspicious false positives when the system is under load you should
define a separate dispatcher for the cluster actors as described in <a class="reference internal" href="#cluster-dispatcher-scala"><em>Cluster Dispatcher</em></a>.</p>
</div>
<div class="section" id="cluster-aware-routers">
<span id="cluster-aware-routers-scala"></span><h2>Cluster Aware Routers</h2>
<p>All <a class="reference internal" href="routing.html#routing-scala"><em>routers</em></a> can be made aware of member nodes in the cluster, i.e.
deploying new routees or looking up routees on nodes in the cluster.
When a node becomes unreachable or leaves the cluster the routees of that node are
automatically unregistered from the router. When new nodes join the cluster, additional
routees are added to the router, according to the configuration. Routees are also added
when a node becomes reachable again, after having been unreachable.</p>
<p>Cluster aware routers make use of members with status <a class="reference internal" href="#weakly-up-scala"><em>WeaklyUp</em></a> if that feature
is enabled.</p>
<p>There are two distinct types of routers.</p>
<ul class="simple">
<li><strong>Group - router that sends messages to the specified path using actor selection</strong>
The routees can be shared among routers running on different nodes in the cluster.
One example of a use case for this type of router is a service running on some backend
nodes in the cluster and used by routers running on front-end nodes in the cluster.</li>
<li><strong>Pool - router that creates routees as child actors and deploys them on remote nodes.</strong>
Each router will have its own routee instances. For example, if you start a router
on 3 nodes in a 10-node cluster, you will have 30 routees in total if the router is
configured to use one instance per node. The routees created by the different routers
will not be shared among the routers. One example of a use case for this type of router
is a single master that coordinates jobs and delegates the actual work to routees running
on other nodes in the cluster.</li>
</ul>
<div class="section" id="router-with-group-of-routees">
<h3>Router with Group of Routees</h3>
<p>When using a <tt class="docutils literal"><span class="pre">Group</span></tt> you must start the routee actors on the cluster member nodes.
That is not done by the router. The configuration for a group looks like this:</p>
<div class="highlight-scala"><pre>akka.actor.deployment {
  /statsService/workerRouter {
      router = consistent-hashing-group
      routees.paths = ["/user/statsWorker"]
      cluster {
        enabled = on
        allow-local-routees = on
        use-role = compute
      }
    }
}
</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The routee actors should be started as early as possible when starting the actor system, because
the router will try to use them as soon as the member status is changed to 'Up'.</p>
</div>
<p>The actor paths without address information that are defined in <tt class="docutils literal"><span class="pre">routees.paths</span></tt> are used for selecting the
actors to which the messages will be forwarded to by the router.
Messages will be forwarded to the routees using <a class="reference internal" href="actors.html#actorselection-scala"><em>ActorSelection</em></a>, so the same delivery semantics should be expected.
It is possible to limit the lookup of routees to member nodes tagged with a certain role by specifying <tt class="docutils literal"><span class="pre">use-role</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">max-total-nr-of-instances</span></tt> defines total number of routees in the cluster. By default <tt class="docutils literal"><span class="pre">max-total-nr-of-instances</span></tt>
is set to a high value (10000) that will result in new routees added to the router when nodes join the cluster.
Set it to a lower value if you want to limit total number of routees.</p>
<p>The same type of router could also have been defined in code:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterGroup</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterGroupSettings</span>
<span class="k">import</span> <span class="nn">akka.routing.ConsistentHashingGroup</span>

<span class="k">val</span> <span class="n">workerRouter</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span>
  <span class="nc">ClusterRouterGroup</span><span class="o">(</span><span class="nc">ConsistentHashingGroup</span><span class="o">(</span><span class="nc">Nil</span><span class="o">),</span> <span class="nc">ClusterRouterGroupSettings</span><span class="o">(</span>
    <span class="n">totalInstances</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">routeesPaths</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;/user/statsWorker&quot;</span><span class="o">),</span>
    <span class="n">allowLocalRoutees</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">useRole</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;compute&quot;</span><span class="o">))).</span><span class="n">props</span><span class="o">(),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;workerRouter2&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#cluster-configuration-scala"><em>Configuration</em></a> section for further descriptions of the settings.</p>
</div>
<div class="section" id="router-example-with-group-of-routees">
<h3>Router Example with Group of Routees</h3>
<p>Let's take a look at how to use a cluster aware router with a group of routees,
i.e. router sending to the paths of the routees.</p>
<p>The example application provides a service to calculate statistics for a text.
When some text is sent to the service it splits it into words, and delegates the task
to count number of characters in each word to a separate worker, a routee of a router.
The character count for each word is sent back to an aggregator that calculates
the average number of characters per word when all results have been collected.</p>
<p>Messages:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">StatsJob</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">StatsResult</span><span class="o">(</span><span class="n">meanWordLength</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JobFailed</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div>
</div>
<p>The worker that counts number of characters in each word:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StatsWorker</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">cache</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">word</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
      <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
          <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">word</span><span class="o">.</span><span class="n">length</span>
          <span class="n">cache</span> <span class="o">+=</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
          <span class="n">x</span>
      <span class="o">}</span>

      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">length</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The service that receives text from users and splits it up into words, delegates to workers and aggregates:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StatsService</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="c1">// This router is used both with lookup and deploy of routees. If you</span>
  <span class="c1">// have a router with only lookup of routees you can use Props.empty</span>
  <span class="c1">// instead of Props[StatsWorker.class].</span>
  <span class="k">val</span> <span class="n">workerRouter</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">FromConfig</span><span class="o">.</span><span class="n">props</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsWorker</span><span class="o">]),</span>
    <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;workerRouter&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">StatsJob</span><span class="o">(</span><span class="n">text</span><span class="o">)</span> <span class="k">if</span> <span class="n">text</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">replyTo</span> <span class="k">=</span> <span class="n">sender</span><span class="o">()</span> <span class="c1">// important to not close over sender()</span>
      <span class="c1">// create actor that collects replies from workers</span>
      <span class="k">val</span> <span class="n">aggregator</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span>
        <span class="n">classOf</span><span class="o">[</span><span class="kt">StatsAggregator</span><span class="o">],</span> <span class="n">words</span><span class="o">.</span><span class="n">size</span><span class="o">,</span> <span class="n">replyTo</span><span class="o">))</span>
      <span class="n">words</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">word</span> <span class="k">=&gt;</span>
        <span class="n">workerRouter</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span>
          <span class="nc">ConsistentHashableEnvelope</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">word</span><span class="o">),</span> <span class="n">aggregator</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">StatsAggregator</span><span class="o">(</span><span class="n">expectedResults</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">results</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="n">context</span><span class="o">.</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">wordCount</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span>
      <span class="n">results</span> <span class="k">=</span> <span class="n">results</span> <span class="o">:+</span> <span class="n">wordCount</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">results</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">expectedResults</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">meanWordLength</span> <span class="k">=</span> <span class="n">results</span><span class="o">.</span><span class="n">sum</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">results</span><span class="o">.</span><span class="n">size</span>
        <span class="n">replyTo</span> <span class="o">!</span> <span class="nc">StatsResult</span><span class="o">(</span><span class="n">meanWordLength</span><span class="o">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">=&gt;</span>
      <span class="n">replyTo</span> <span class="o">!</span> <span class="nc">JobFailed</span><span class="o">(</span><span class="s">&quot;Service unavailable, try again later&quot;</span><span class="o">)</span>
      <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note, nothing cluster specific so far, just plain actors.</p>
<p>All nodes start <tt class="docutils literal"><span class="pre">StatsService</span></tt> and <tt class="docutils literal"><span class="pre">StatsWorker</span></tt> actors. Remember, routees are the workers in this case.
The router is configured with <tt class="docutils literal"><span class="pre">routees.paths</span></tt>:</p>
<div class="highlight-scala"><pre>akka.actor.deployment {
  /statsService/workerRouter {
    router = consistent-hashing-group
    routees.paths = ["/user/statsWorker"]
    cluster {
      enabled = on
      allow-local-routees = on
      use-role = compute
    }
  }
}
</pre>
</div>
<p>This means that user requests can be sent to <tt class="docutils literal"><span class="pre">StatsService</span></tt> on any node and it will use
<tt class="docutils literal"><span class="pre">StatsWorker</span></tt> on all nodes.</p>
<p>The <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a> tutorial named
<a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-cluster-scala">Akka Cluster Samples with Scala</a>.
contains the full source code and instructions of how to run the <strong>Router Example with Group of Routees</strong>.</p>
</div>
<div class="section" id="router-with-pool-of-remote-deployed-routees">
<h3>Router with Pool of Remote Deployed Routees</h3>
<p>When using a <tt class="docutils literal"><span class="pre">Pool</span></tt> with routees created and deployed on the cluster member nodes
the configuration for a router looks like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">statsService</span><span class="o">/</span><span class="n">singleton</span><span class="o">/</span><span class="n">workerRouter</span> <span class="o">{</span>
      <span class="n">router</span> <span class="k">=</span> <span class="n">consistent</span><span class="o">-</span><span class="n">hashing</span><span class="o">-</span><span class="n">pool</span>
      <span class="n">cluster</span> <span class="o">{</span>
        <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
        <span class="n">max</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">node</span> <span class="k">=</span> <span class="mi">3</span>
        <span class="n">allow</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">routees</span> <span class="k">=</span> <span class="n">on</span>
        <span class="n">use</span><span class="o">-</span><span class="n">role</span> <span class="k">=</span> <span class="n">compute</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It is possible to limit the deployment of routees to member nodes tagged with a certain role by
specifying <tt class="docutils literal"><span class="pre">use-role</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">max-total-nr-of-instances</span></tt> defines total number of routees in the cluster, but the number of routees
per node, <tt class="docutils literal"><span class="pre">max-nr-of-instances-per-node</span></tt>, will not be exceeded. By default <tt class="docutils literal"><span class="pre">max-total-nr-of-instances</span></tt>
is set to a high value (10000) that will result in new routees added to the router when nodes join the cluster.
Set it to a lower value if you want to limit total number of routees.</p>
<p>The same type of router could also have been defined in code:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterPool</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterPoolSettings</span>
<span class="k">import</span> <span class="nn">akka.routing.ConsistentHashingPool</span>

<span class="k">val</span> <span class="n">workerRouter</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span>
  <span class="nc">ClusterRouterPool</span><span class="o">(</span><span class="nc">ConsistentHashingPool</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="nc">ClusterRouterPoolSettings</span><span class="o">(</span>
    <span class="n">totalInstances</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">maxInstancesPerNode</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span>
    <span class="n">allowLocalRoutees</span> <span class="k">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">useRole</span> <span class="k">=</span> <span class="nc">None</span><span class="o">)).</span><span class="n">props</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsWorker</span><span class="o">]),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;workerRouter3&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#cluster-configuration-scala"><em>Configuration</em></a> section for further descriptions of the settings.</p>
</div>
<div class="section" id="router-example-with-pool-of-remote-deployed-routees">
<h3>Router Example with Pool of Remote Deployed Routees</h3>
<p>Let's take a look at how to use a cluster aware router on single master node that creates
and deploys workers. To keep track of a single master we use the <a class="reference internal" href="cluster-singleton.html#cluster-singleton-scala"><em>Cluster Singleton</em></a>
in the contrib module. The <tt class="docutils literal"><span class="pre">ClusterSingletonManager</span></tt> is started on each node.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">ClusterSingletonManager</span><span class="o">.</span><span class="n">props</span><span class="o">(</span>
  <span class="n">singletonProps</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">StatsService</span><span class="o">],</span>
  <span class="n">terminationMessage</span> <span class="k">=</span> <span class="nc">PoisonPill</span><span class="o">,</span>
  <span class="n">settings</span> <span class="k">=</span> <span class="nc">ClusterSingletonManagerSettings</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">withRole</span><span class="o">(</span><span class="s">&quot;compute&quot;</span><span class="o">)),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;statsService&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>We also need an actor on each node that keeps track of where current single master exists and
delegates jobs to the <tt class="docutils literal"><span class="pre">StatsService</span></tt>.  That is provided by the <tt class="docutils literal"><span class="pre">ClusterSingletonProxy</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">ClusterSingletonProxy</span><span class="o">.</span><span class="n">props</span><span class="o">(</span><span class="n">singletonManagerPath</span> <span class="k">=</span> <span class="s">&quot;/user/statsService&quot;</span><span class="o">,</span>
  <span class="n">settings</span> <span class="k">=</span> <span class="nc">ClusterSingletonProxySettings</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">withRole</span><span class="o">(</span><span class="s">&quot;compute&quot;</span><span class="o">)),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;statsServiceProxy&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">ClusterSingletonProxy</span></tt> receives text from users and delegates to the current <tt class="docutils literal"><span class="pre">StatsService</span></tt>, the single
master. It listens to cluster events to lookup the <tt class="docutils literal"><span class="pre">StatsService</span></tt> on the oldest node.</p>
<p>All nodes start <tt class="docutils literal"><span class="pre">ClusterSingletonProxy</span></tt> and the <tt class="docutils literal"><span class="pre">ClusterSingletonManager</span></tt>. The router is now configured like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">statsService</span><span class="o">/</span><span class="n">singleton</span><span class="o">/</span><span class="n">workerRouter</span> <span class="o">{</span>
    <span class="n">router</span> <span class="k">=</span> <span class="n">consistent</span><span class="o">-</span><span class="n">hashing</span><span class="o">-</span><span class="n">pool</span>
    <span class="n">cluster</span> <span class="o">{</span>
      <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">max</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">node</span> <span class="k">=</span> <span class="mi">3</span>
      <span class="n">allow</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">routees</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">use</span><span class="o">-</span><span class="n">role</span> <span class="k">=</span> <span class="n">compute</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a> tutorial named
<a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-cluster-scala">Akka Cluster Samples with Scala</a>.
contains the full source code and instructions of how to run the <strong>Router Example with Pool of Remote Deployed Routees</strong>.</p>
</div>
</div>
<div class="section" id="cluster-metrics">
<h2>Cluster Metrics</h2>
<p>The member nodes of the cluster can collect system health metrics and publish that to other cluster nodes
and to the registered subscribers on the system event bus with the help of <a class="reference internal" href="cluster-metrics.html"><em>Cluster Metrics Extension</em></a>.</p>
</div>
<div class="section" id="how-to-test">
<h2>How to Test</h2>
<p><a class="reference internal" href="../dev/multi-node-testing.html#multi-node-testing"><em>Multi Node Testing</em></a> is useful for testing cluster applications.</p>
<p>Set up your project according to the instructions in <a class="reference internal" href="../dev/multi-node-testing.html#multi-node-testing"><em>Multi Node Testing</em></a> and <a class="reference internal" href="../dev/multi-jvm-testing.html#multi-jvm-testing"><em>Multi JVM Testing</em></a>, i.e.
add the <tt class="docutils literal"><span class="pre">sbt-multi-jvm</span></tt> plugin and the dependency to <tt class="docutils literal"><span class="pre">akka-multi-node-testkit</span></tt>.</p>
<p>First, as described in <a class="reference internal" href="../dev/multi-node-testing.html#multi-node-testing"><em>Multi Node Testing</em></a>, we need some scaffolding to configure the <tt class="docutils literal"><span class="pre">MultiNodeSpec</span></tt>.
Define the participating roles and their <a class="reference internal" href="#cluster-configuration-scala"><em>Configuration</em></a> in an object extending <tt class="docutils literal"><span class="pre">MultiNodeConfig</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.remote.testkit.MultiNodeConfig</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>

<span class="k">object</span> <span class="nc">StatsSampleSpecConfig</span> <span class="k">extends</span> <span class="nc">MultiNodeConfig</span> <span class="o">{</span>
  <span class="c1">// register the named roles (nodes) of the test</span>
  <span class="k">val</span> <span class="n">first</span> <span class="k">=</span> <span class="n">role</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">second</span> <span class="k">=</span> <span class="n">role</span><span class="o">(</span><span class="s">&quot;second&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">third</span> <span class="k">=</span> <span class="n">role</span><span class="o">(</span><span class="s">&quot;thrid&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">nodeList</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">,</span> <span class="n">third</span><span class="o">)</span>

  <span class="c1">// Extract individual sigar library for every node.</span>
  <span class="n">nodeList</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">role</span> <span class="k">=&gt;</span>
    <span class="n">nodeConfig</span><span class="o">(</span><span class="n">role</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">      # Disable legacy metrics in akka-cluster.</span>
<span class="s">      akka.cluster.metrics.enabled=off</span>
<span class="s">      # Enable metrics extension in akka-cluster-metrics.</span>
<span class="s">      akka.extensions=[&quot;akka.cluster.metrics.ClusterMetricsExtension&quot;]</span>
<span class="s">      # Sigar native library extract location during tests.</span>
<span class="s">      akka.cluster.metrics.native-library-extract-folder=target/native/${role.name}</span>
<span class="s">      &quot;&quot;&quot;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// this configuration will be used for all nodes</span>
  <span class="c1">// note that no fixed host names and ports are used</span>
  <span class="n">commonConfig</span><span class="o">(</span><span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">    akka.actor.provider = cluster</span>
<span class="s">    akka.remote.log-remote-lifecycle-events = off</span>
<span class="s">    akka.cluster.roles = [compute]</span>
<span class="s">     // router lookup config ...</span>
<span class="s">    &quot;&quot;&quot;</span><span class="o">))</span>

<span class="o">}</span>
</pre></div>
</div>
<p>Define one concrete test class for each role/node. These will be instantiated on the different nodes (JVMs). They can be
implemented differently, but often they are the same and extend an abstract test class, as illustrated here.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// need one concrete test class per node</span>
<span class="k">class</span> <span class="nc">StatsSampleSpecMultiJvmNode1</span> <span class="k">extends</span> <span class="nc">StatsSampleSpec</span>
<span class="k">class</span> <span class="nc">StatsSampleSpecMultiJvmNode2</span> <span class="k">extends</span> <span class="nc">StatsSampleSpec</span>
<span class="k">class</span> <span class="nc">StatsSampleSpecMultiJvmNode3</span> <span class="k">extends</span> <span class="nc">StatsSampleSpec</span>
</pre></div>
</div>
<p>Note the naming convention of these classes. The name of the classes must end with <tt class="docutils literal"><span class="pre">MultiJvmNode1</span></tt>, <tt class="docutils literal"><span class="pre">MultiJvmNode2</span></tt>
and so on. It is possible to define another suffix to be used by the <tt class="docutils literal"><span class="pre">sbt-multi-jvm</span></tt>, but the default should be
fine in most cases.</p>
<p>Then the abstract <tt class="docutils literal"><span class="pre">MultiNodeSpec</span></tt>, which takes the <tt class="docutils literal"><span class="pre">MultiNodeConfig</span></tt> as constructor parameter.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">org.scalatest.BeforeAndAfterAll</span>
<span class="k">import</span> <span class="nn">org.scalatest.WordSpecLike</span>
<span class="k">import</span> <span class="nn">org.scalatest.Matchers</span>
<span class="k">import</span> <span class="nn">akka.remote.testkit.MultiNodeSpec</span>
<span class="k">import</span> <span class="nn">akka.testkit.ImplicitSender</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">StatsSampleSpec</span> <span class="k">extends</span> <span class="nc">MultiNodeSpec</span><span class="o">(</span><span class="nc">StatsSampleSpecConfig</span><span class="o">)</span>
  <span class="k">with</span> <span class="nc">WordSpecLike</span> <span class="k">with</span> <span class="nc">Matchers</span> <span class="k">with</span> <span class="nc">BeforeAndAfterAll</span>
  <span class="k">with</span> <span class="nc">ImplicitSender</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">StatsSampleSpecConfig._</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">initialParticipants</span> <span class="k">=</span> <span class="n">roles</span><span class="o">.</span><span class="n">size</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">beforeAll</span><span class="o">()</span> <span class="k">=</span> <span class="n">multiNodeSpecBeforeAll</span><span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">afterAll</span><span class="o">()</span> <span class="k">=</span> <span class="n">multiNodeSpecAfterAll</span><span class="o">()</span>
</pre></div>
</div>
<p>Most of this can of course be extracted to a separate trait to avoid repeating this in all your tests.</p>
<p>Typically you begin your test by starting up the cluster and let the members join, and create some actors.
That can be done like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;illustrate how to startup cluster&quot;</span> <span class="n">in</span> <span class="n">within</span><span class="o">(</span><span class="mi">15</span> <span class="n">seconds</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">subscribe</span><span class="o">(</span><span class="n">testActor</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberUp</span><span class="o">])</span>
  <span class="n">expectMsgClass</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">CurrentClusterState</span><span class="o">])</span>

  <span class="k">val</span> <span class="n">firstAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">first</span><span class="o">).</span><span class="n">address</span>
  <span class="k">val</span> <span class="n">secondAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">second</span><span class="o">).</span><span class="n">address</span>
  <span class="k">val</span> <span class="n">thirdAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">third</span><span class="o">).</span><span class="n">address</span>

  <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span> <span class="n">join</span> <span class="n">firstAddress</span>

  <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsWorker</span><span class="o">],</span> <span class="s">&quot;statsWorker&quot;</span><span class="o">)</span>
  <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsService</span><span class="o">],</span> <span class="s">&quot;statsService&quot;</span><span class="o">)</span>

  <span class="n">receiveN</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">}.</span><span class="n">toSet</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span>
    <span class="nc">Set</span><span class="o">(</span><span class="n">firstAddress</span><span class="o">,</span> <span class="n">secondAddress</span><span class="o">,</span> <span class="n">thirdAddress</span><span class="o">))</span>

  <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">unsubscribe</span><span class="o">(</span><span class="n">testActor</span><span class="o">)</span>

  <span class="n">testConductor</span><span class="o">.</span><span class="n">enter</span><span class="o">(</span><span class="s">&quot;all-up&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>From the test you interact with the cluster using the <tt class="docutils literal"><span class="pre">Cluster</span></tt> extension, e.g. <tt class="docutils literal"><span class="pre">join</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span> <span class="n">join</span> <span class="n">firstAddress</span>
</pre></div>
</div>
<p>Notice how the <cite>testActor</cite> from <a class="reference internal" href="testing.html#akka-testkit"><em>testkit</em></a> is added as <a class="reference internal" href="#cluster-subscriber-scala"><em>subscriber</em></a>
to cluster changes and then waiting for certain events, such as in this case all members becoming 'Up'.</p>
<p>The above code was running for all roles (JVMs). <tt class="docutils literal"><span class="pre">runOn</span></tt> is a convenient utility to declare that a certain block
of code should only run for a specific role.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;show usage of the statsService from one node&quot;</span> <span class="n">in</span> <span class="n">within</span><span class="o">(</span><span class="mi">15</span> <span class="n">seconds</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">runOn</span><span class="o">(</span><span class="n">second</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertServiceOk</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="n">testConductor</span><span class="o">.</span><span class="n">enter</span><span class="o">(</span><span class="s">&quot;done-2&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">assertServiceOk</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">service</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="n">node</span><span class="o">(</span><span class="n">third</span><span class="o">)</span> <span class="o">/</span> <span class="s">&quot;user&quot;</span> <span class="o">/</span> <span class="s">&quot;statsService&quot;</span><span class="o">)</span>
  <span class="c1">// eventually the service should be ok,</span>
  <span class="c1">// first attempts might fail because worker actors not started yet</span>
  <span class="n">awaitAssert</span> <span class="o">{</span>
    <span class="n">service</span> <span class="o">!</span> <span class="nc">StatsJob</span><span class="o">(</span><span class="s">&quot;this is the text that will be analyzed&quot;</span><span class="o">)</span>
    <span class="n">expectMsgType</span><span class="o">[</span><span class="kt">StatsResult</span><span class="o">](</span><span class="mf">1.</span><span class="n">second</span><span class="o">).</span><span class="n">meanWordLength</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span>
      <span class="mf">3.875</span> <span class="o">+-</span> <span class="mf">0.001</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>Once again we take advantage of the facilities in <a class="reference internal" href="testing.html#akka-testkit"><em>testkit</em></a> to verify expected behavior.
Here using <tt class="docutils literal"><span class="pre">testActor</span></tt> as sender (via <tt class="docutils literal"><span class="pre">ImplicitSender</span></tt>) and verifying the reply with <tt class="docutils literal"><span class="pre">expectMsgPF</span></tt>.</p>
<p>In the above code you can see <tt class="docutils literal"><span class="pre">node(third)</span></tt>, which is useful facility to get the root actor reference of
the actor system for a specific role. This can also be used to grab the <tt class="docutils literal"><span class="pre">akka.actor.Address</span></tt> of that node.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">firstAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">first</span><span class="o">).</span><span class="n">address</span>
<span class="k">val</span> <span class="n">secondAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">second</span><span class="o">).</span><span class="n">address</span>
<span class="k">val</span> <span class="n">thirdAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">third</span><span class="o">).</span><span class="n">address</span>
</pre></div>
</div>
</div>
<div class="section" id="jmx">
<span id="cluster-jmx-scala"></span><h2>JMX</h2>
<p>Information and management of the cluster is available as JMX MBeans with the root name <tt class="docutils literal"><span class="pre">akka.Cluster</span></tt>.
The JMX information can be displayed with an ordinary JMX console such as JConsole or JVisualVM.</p>
<p>From JMX you can:</p>
<ul class="simple">
<li>see what members that are part of the cluster</li>
<li>see status of this node</li>
<li>see roles of each member</li>
<li>join this node to another node in cluster</li>
<li>mark any node in the cluster as down</li>
<li>tell any node in the cluster to leave</li>
</ul>
<p>Member nodes are identified by their address, in format <cite>akka.&lt;protocol&gt;://&lt;actor-system-name&gt;&#64;&lt;hostname&gt;:&lt;port&gt;</cite>.</p>
</div>
<div class="section" id="command-line-management">
<span id="cluster-command-line-scala"></span><h2>Command Line Management</h2>
<p>The cluster can be managed with the script <cite>bin/akka-cluster</cite> provided in the
Akka distribution.</p>
<p>Run it without parameters to see instructions about how to use the script:</p>
<div class="highlight-scala"><pre>Usage: bin/akka-cluster &lt;node-hostname&gt; &lt;jmx-port&gt; &lt;command&gt; ...

Supported commands are:
           join &lt;node-url&gt; - Sends request a JOIN node with the specified URL
          leave &lt;node-url&gt; - Sends a request for node with URL to LEAVE the cluster
           down &lt;node-url&gt; - Sends a request for marking node with URL as DOWN
             member-status - Asks the member node for its current status
                   members - Asks the cluster for addresses of current members
               unreachable - Asks the cluster for addresses of unreachable members
            cluster-status - Asks the cluster for its current status (member ring,
                             unavailable nodes, meta data etc.)
                    leader - Asks the cluster who the current leader is
              is-singleton - Checks if the cluster is a singleton cluster (single
                             node cluster)
              is-available - Checks if the member node is available
Where the &lt;node-url&gt; should be on the format of
  'akka.&lt;protocol&gt;://&lt;actor-system-name&gt;@&lt;hostname&gt;:&lt;port&gt;'

Examples: bin/akka-cluster localhost 9999 is-available
          bin/akka-cluster localhost 9999 join akka.tcp://MySystem@darkstar:2552
          bin/akka-cluster localhost 9999 cluster-status</pre>
</div>
<p>To be able to use the script you must enable remote monitoring and management when starting the JVMs of the cluster nodes,
as described in <a class="reference external" href="http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html">Monitoring and Management Using JMX Technology</a></p>
<p>Example of system properties to enable remote monitoring and management:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="nc">Dcom</span><span class="o">.</span><span class="n">sun</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">jmxremote</span><span class="o">.</span><span class="n">port</span><span class="k">=</span><span class="mi">9999</span> <span class="o">\</span>
<span class="o">-</span><span class="nc">Dcom</span><span class="o">.</span><span class="n">sun</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">jmxremote</span><span class="o">.</span><span class="n">authenticate</span><span class="k">=</span><span class="kc">false</span> <span class="o">\</span>
<span class="o">-</span><span class="nc">Dcom</span><span class="o">.</span><span class="n">sun</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">jmxremote</span><span class="o">.</span><span class="n">ssl</span><span class="k">=</span><span class="kc">false</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration">
<span id="cluster-configuration-scala"></span><h2>Configuration</h2>
<p>There are several configuration properties for the cluster. We refer to the
<a class="reference internal" href="../general/configuration.html#config-akka-cluster"><em>reference configuration</em></a> for more information.</p>
<div class="section" id="cluster-info-logging">
<h3>Cluster Info Logging</h3>
<p>You can silence the logging of cluster events at info level with configuration property:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">log</span><span class="o">-</span><span class="n">info</span> <span class="k">=</span> <span class="n">off</span>
</pre></div>
</div>
</div>
<div class="section" id="cluster-dispatcher">
<span id="cluster-dispatcher-scala"></span><h3>Cluster Dispatcher</h3>
<p>Under the hood the cluster extension is implemented with actors and it can be necessary
to create a bulkhead for those actors to avoid disturbance from other actors. Especially
the heartbeating actors that is used for failure detection can generate false positives
if they are not given a chance to run at regular intervals.
For this purpose you can define a separate dispatcher to be used for the cluster actors:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">use</span><span class="o">-</span><span class="n">dispatcher</span> <span class="k">=</span> <span class="n">cluster</span><span class="o">-</span><span class="n">dispatcher</span>

<span class="n">cluster</span><span class="o">-</span><span class="n">dispatcher</span> <span class="o">{</span>
  <span class="k">type</span> <span class="o">=</span> <span class="s">&quot;Dispatcher&quot;</span>
  <span class="n">executor</span> <span class="k">=</span> <span class="s">&quot;fork-join-executor&quot;</span>
  <span class="n">fork</span><span class="o">-</span><span class="n">join</span><span class="o">-</span><span class="n">executor</span> <span class="o">{</span>
    <span class="n">parallelism</span><span class="o">-</span><span class="n">min</span> <span class="k">=</span> <span class="mi">2</span>
    <span class="n">parallelism</span><span class="o">-</span><span class="n">max</span> <span class="k">=</span> <span class="mi">4</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Normally it should not be necessary to configure a separate dispatcher for the Cluster.
The default-dispatcher should be sufficient for performing the Cluster tasks, i.e. <tt class="docutils literal"><span class="pre">akka.cluster.use-dispatcher</span></tt>
should not be changed. If you have Cluster related problems when using the default-dispatcher that is typically an
indication that you are running blocking or CPU intensive actors/tasks on the default-dispatcher.
Use dedicated dispatchers for such actors/tasks instead of running them on the default-dispatcher,
because that may starve system internal tasks.
Related config properties: <tt class="docutils literal"><span class="pre">akka.cluster.use-dispatcher</span> <span class="pre">=</span> <span class="pre">akka.cluster.cluster-dispatcher</span></tt>.
Corresponding default values: <tt class="docutils literal"><span class="pre">akka.cluster.use-dispatcher</span> <span class="pre">=</span></tt>.</p>
</div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>