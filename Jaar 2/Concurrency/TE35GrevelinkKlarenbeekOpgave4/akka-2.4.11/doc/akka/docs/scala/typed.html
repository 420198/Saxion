


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Akka Typed &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Experimental Modules" href="../experimental/index.html" />
    <link rel="next" title="External Contributions" href="../contrib/index.html" />
    <link rel="prev" title="Persistence Query" href="persistence-query.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Akka Typed</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="../contrib/index.html">External Contributions</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="persistence-query.html">Persistence Query</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="akka-typed">
<span id="typed-scala"></span><h1>Akka Typed</h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This module is currently experimental in the sense of being the subject of
active research. This means that API or semantics can change without warning
or deprecation period and it is not recommended to use this module in
production just yet—you have been warned.</p>
</div>
<p>As discussed in <a class="reference internal" href="../general/actor-systems.html#actor-systems"><em>Actor Systems</em></a> (and following chapters) Actors are about
sending messages between independent units of computation, but how does that
look like? In all of the following these imports are assumed:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.typed._</span>
<span class="k">import</span> <span class="nn">akka.typed.ScalaDSL._</span>
<span class="k">import</span> <span class="nn">akka.typed.AskPattern._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
</pre></div>
</div>
<p>With these in place we can define our first Actor, and of course it will say
hello!</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">object</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Greet</span><span class="o">(</span><span class="n">whom</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">[</span><span class="kt">Greeted</span><span class="o">])</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Greeted</span><span class="o">(</span><span class="n">whom</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">greeter</span> <span class="k">=</span> <span class="nc">Static</span><span class="o">[</span><span class="kt">Greet</span><span class="o">]</span> <span class="o">{</span> <span class="n">msg</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Hello ${msg.whom}!&quot;</span><span class="o">)</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">replyTo</span> <span class="o">!</span> <span class="nc">Greeted</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">whom</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This small piece of code defines two message types, one for commanding the
Actor to greet someone and one that the Actor will use to confirm that it has
done so. The <tt class="xref py py-class docutils literal"><span class="pre">Greet</span></tt> type contains not only the information of whom to
greet, it also holds an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> that the sender of the message
supplies so that the <tt class="xref py py-class docutils literal"><span class="pre">HelloWorld</span></tt> Actor can send back the confirmation
message.</p>
<p>The behavior of the Actor is defined as the <tt class="xref py py-meth docutils literal"><span class="pre">greeter</span></tt> value with the help
of the <tt class="xref py py-class docutils literal"><span class="pre">Static</span></tt> behavior constructor—there are many different ways of
formulating behaviors as we shall see in the following. The “static” behavior
is not capable of changing in response to a message, it will stay the same
until the Actor is stopped by its parent.</p>
<p>The type of the messages handled by this behavior is declared to be of class
<tt class="xref py py-class docutils literal"><span class="pre">Greet</span></tt>, which implies that the supplied function’s <tt class="docutils literal"><span class="pre">msg</span></tt> argument is
also typed as such. This is why we can access the <tt class="docutils literal"><span class="pre">whom</span></tt> and <tt class="docutils literal"><span class="pre">replyTo</span></tt>
members without needing to use a pattern match.</p>
<p>On the last line we see the <tt class="xref py py-class docutils literal"><span class="pre">HelloWorld</span></tt> Actor send a message to another
Actor, which is done using the <tt class="docutils literal"><span class="pre">!</span></tt> operator (pronounced “tell”). Since the
<tt class="docutils literal"><span class="pre">replyTo</span></tt> address is declared to be of type <tt class="docutils literal"><span class="pre">ActorRef[Greeted]</span></tt> the
compiler will only permit us to send messages of this type, other usage will
not be accepted.</p>
<p>The accepted message types of an Actor together with all reply types defines
the protocol spoken by this Actor; in this case it is a simple request–reply
protocol but Actors can model arbitrarily complex protocols when needed. The
protocol is bundled together with the behavior that implements it in a nicely
wrapped scope—the <tt class="docutils literal"><span class="pre">HelloWorld</span></tt> object.</p>
<p>Now we want to try out this Actor, so we must start an ActorSystem to host it:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">HelloWorld._</span>
<span class="c1">// using global pool since we want to run tasks after system.terminate</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>

<span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ActorSystem</span><span class="o">[</span><span class="kt">Greet</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="n">greeter</span><span class="o">)</span>

<span class="k">val</span> <span class="n">future</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Greeted</span><span class="o">]</span> <span class="k">=</span> <span class="n">system</span> <span class="o">?</span> <span class="o">(</span><span class="nc">Greet</span><span class="o">(</span><span class="s">&quot;world&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="n">greeting</span> <span class="k">&lt;-</span> <span class="n">future</span><span class="o">.</span><span class="n">recover</span> <span class="o">{</span> <span class="k">case</span> <span class="n">ex</span> <span class="k">=&gt;</span> <span class="n">ex</span><span class="o">.</span><span class="n">getMessage</span> <span class="o">}</span>
  <span class="n">done</span> <span class="k">&lt;-</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;result: $greeting&quot;</span><span class="o">);</span> <span class="n">system</span><span class="o">.</span><span class="n">terminate</span><span class="o">()</span> <span class="o">}</span>
<span class="o">}</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;system terminated&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>After importing the Actor’s protocol definition we start an Actor system from
the defined behavior.</p>
<p>As Carl Hewitt said, one Actor is no Actor—it would be quite lonely with
nobody to talk to. In this sense the example is a little cruel because we only
give the <tt class="docutils literal"><span class="pre">HelloWorld</span></tt> Actor a fake person to talk to—the “ask” pattern
(represented by the <tt class="docutils literal"><span class="pre">?</span></tt> operator) can be used to send a message such that the
reply fulfills a Promise to which we get back the corresponding Future.</p>
<p>Note that the <tt class="xref py py-class docutils literal"><span class="pre">Future</span></tt> that is returned by the “ask” operation is
properly typed already, no type checks or casts needed. This is possible due to
the type information that is part of the message protocol: the <tt class="docutils literal"><span class="pre">?</span></tt> operator
takes as argument a function that accepts an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef[U]</span></tt> (which
explains the <tt class="docutils literal"><span class="pre">_</span></tt> hole in the expression on line 7 above) and the <tt class="docutils literal"><span class="pre">replyTo</span></tt>
parameter which we fill in is of type <tt class="docutils literal"><span class="pre">ActorRef[Greeted]</span></tt>, which
means that the value that fulfills the <tt class="xref py py-class docutils literal"><span class="pre">Promise</span></tt> can only be of type
<tt class="xref py py-class docutils literal"><span class="pre">Greeted</span></tt>.</p>
<p>We use this here to send the <tt class="xref py py-class docutils literal"><span class="pre">Greet</span></tt> command to the Actor and when the
reply comes back we will print it out and tell the actor system to shut down.
Once that is done as well we print the <tt class="docutils literal"><span class="pre">&quot;system&nbsp;terminated&quot;</span></tt> messages and the
program ends. The <tt class="docutils literal"><span class="pre">recovery</span></tt> combinator on the original <tt class="xref py py-class docutils literal"><span class="pre">Future</span></tt> is
needed in order to ensure proper system shutdown even in case something went
wrong; the <tt class="docutils literal"><span class="pre">flatMap</span></tt> and <tt class="docutils literal"><span class="pre">map</span></tt> combinators that the <tt class="docutils literal"><span class="pre">for</span></tt> expression gets
turned into care only about the “happy path” and if the <tt class="docutils literal"><span class="pre">future</span></tt> failed with
a timeout then no <tt class="docutils literal"><span class="pre">greeting</span></tt> would be extracted and nothing would happen.</p>
<p>This shows that there are aspects of Actor messaging that can be type-checked
by the compiler, but this ability is not unlimited, there are bounds to what we
can statically express. Before we go on with a more complex (and realistic)
example we make a small detour to highlight some of the theory behind this.</p>
<div class="section" id="a-little-bit-of-theory">
<h2>A Little Bit of Theory</h2>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a> as defined by Hewitt, Bishop and Steiger in 1973 is a
computational model that expresses exactly what it means for computation to be
distributed. The processing units—Actors—can only communicate by exchanging
messages and upon reception of a message an Actor can do the following three
fundamental actions:</p>
<blockquote>
<div><ol class="arabic simple">
<li>send a finite number of messages to Actors it knows</li>
<li>create a finite number of new Actors</li>
<li>designate the behavior to be applied to the next message</li>
</ol>
</div></blockquote>
<p>The Akka Typed project expresses these actions using behaviors and addresses.
Messages can be sent to an address and behind this façade there is a behavior
that receives the message and acts upon it. The binding between address and
behavior can change over time as per the third point above, but that is not
visible on the outside.</p>
<p>With this preamble we can get to the unique property of this project, namely
that it introduces static type checking to Actor interactions: addresses are
parameterized and only messages that are of the specified type can be sent to
them. The association between an address and its type parameter must be made
when the address (and its Actor) is created. For this purpose each behavior is
also parameterized with the type of messages it is able to process. Since the
behavior can change behind the address façade, designating the next behavior is
a constrained operation: the successor must handle the same type of messages as
its predecessor. This is necessary in order to not invalidate the addresses
that refer to this Actor.</p>
<p>What this enables is that whenever a message is sent to an Actor we can
statically ensure that the type of the message is one that the Actor declares
to handle—we can avoid the mistake of sending completely pointless messages.
What we cannot statically ensure, though, is that the behavior behind the
address will be in a given state when our message is received. The fundamental
reason is that the association between address and behavior is a dynamic
runtime property, the compiler cannot know it while it translates the source
code.</p>
<p>This is the same as for normal Java objects with internal variables: when
compiling the program we cannot know what their value will be, and if the
result of a method call depends on those variables then the outcome is
uncertain to a degree—we can only be certain that the returned value is of a
given type.</p>
<p>We have seen above that the return type of an Actor command is described by the
type of reply-to address that is contained within the message. This allows a
conversation to be described in terms of its types: the reply will be of type
A, but it might also contain an address of type B, which then allows the other
Actor to continue the conversation by sending a message of type B to this new
address. While we cannot statically express the “current” state of an Actor, we
can express the current state of a protocol between two Actors, since that is
just given by the last message type that was received or sent.</p>
<p>In the next section we demonstrate this on a more realistic example.</p>
</div>
<div class="section" id="a-more-complex-example">
<h2>A More Complex Example</h2>
<p>Consider an Actor that runs a chat room: client Actors may connect by sending
a message that contains their screen name and then they can post messages. The
chat room Actor will disseminate all posted messages to all currently connected
client Actors. The protocol definition could look like the following:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Command</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">GetSession</span><span class="o">(</span><span class="n">screenName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">[</span><span class="kt">SessionEvent</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">Command</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SessionEvent</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SessionGranted</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">[</span><span class="kt">PostMessage</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">SessionEvent</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SessionDenied</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">SessionEvent</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MessagePosted</span><span class="o">(</span><span class="n">screenName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">SessionEvent</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PostMessage</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div>
</div>
<p>Initially the client Actors only get access to an <tt class="docutils literal"><span class="pre">ActorRef[GetSession]</span></tt>
which allows them to make the first step. Once a client’s session has been
established it gets a <tt class="xref py py-class docutils literal"><span class="pre">SessionGranted</span></tt> message that contains a <tt class="docutils literal"><span class="pre">handle</span></tt> to
unlock the next protocol step, posting messages. The <tt class="xref py py-class docutils literal"><span class="pre">PostMessage</span></tt>
command will need to be sent to this particular address that represents the
session that has been added to the chat room. The other aspect of a session is
that the client has revealed its own address, via the <tt class="docutils literal"><span class="pre">replyTo</span></tt> argument, so that subsequent
<tt class="xref py py-class docutils literal"><span class="pre">MessagePosted</span></tt> events can be sent to it.</p>
<p>This illustrates how Actors can express more than just the equivalent of method
calls on Java objects. The declared message types and their contents describe a
full protocol that can involve multiple Actors and that can evolve over
multiple steps. The implementation of the chat room protocol would be as simple
as the following:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">private</span> <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PostSessionMessage</span><span class="o">(</span><span class="n">screenName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Command</span>

<span class="k">val</span> <span class="n">behavior</span><span class="k">:</span> <span class="kt">Behavior</span><span class="o">[</span><span class="kt">GetSession</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ContextAware</span><span class="o">[</span><span class="kt">Command</span><span class="o">]</span> <span class="o">{</span> <span class="n">ctx</span> <span class="k">=&gt;</span>
    <span class="k">var</span> <span class="n">sessions</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">[</span><span class="kt">SessionEvent</span><span class="o">]]</span>

    <span class="nc">Static</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">GetSession</span><span class="o">(</span><span class="n">screenName</span><span class="o">,</span> <span class="n">client</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">sessions</span> <span class="o">::=</span> <span class="n">client</span>
        <span class="k">val</span> <span class="n">wrapper</span> <span class="k">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">spawnAdapter</span> <span class="o">{</span>
          <span class="n">p</span><span class="k">:</span> <span class="kt">PostMessage</span> <span class="o">=&gt;</span> <span class="nc">PostSessionMessage</span><span class="o">(</span><span class="n">screenName</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">message</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="n">client</span> <span class="o">!</span> <span class="nc">SessionGranted</span><span class="o">(</span><span class="n">wrapper</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">PostSessionMessage</span><span class="o">(</span><span class="n">screenName</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">mp</span> <span class="k">=</span> <span class="nc">MessagePosted</span><span class="o">(</span><span class="n">screenName</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
        <span class="n">sessions</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="o">!</span> <span class="n">mp</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}.</span><span class="n">narrow</span> <span class="c1">// only expose GetSession to the outside</span>
</pre></div>
</div>
<p>The core of this behavior is again static, the chat room itself does not change
into something else when sessions are established, but we introduce a variable
that tracks the opened sessions. When a new <tt class="xref py py-class docutils literal"><span class="pre">GetSession</span></tt> command comes
in we add that client to the list and then we need to create the session’s
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> that will be used to post messages. In this case we want to
create a very simple Actor that just repackages the <tt class="xref py py-class docutils literal"><span class="pre">PostMessage</span></tt>
command into a <tt class="xref py py-class docutils literal"><span class="pre">PostSessionMessage</span></tt> command which also includes the
screen name. Such a wrapper Actor can be created by using the
<tt class="xref py py-meth docutils literal"><span class="pre">spawnAdapter</span></tt> method on the <tt class="xref py py-class docutils literal"><span class="pre">ActorContext</span></tt>, so that we can then
go on to reply to the client with the <tt class="xref py py-class docutils literal"><span class="pre">SessionGranted</span></tt> result.</p>
<p>The behavior that we declare here can handle both subtypes of <tt class="xref py py-class docutils literal"><span class="pre">Command</span></tt>.
<tt class="xref py py-class docutils literal"><span class="pre">GetSession</span></tt> has been explained already and the
<tt class="xref py py-class docutils literal"><span class="pre">PostSessionMessage</span></tt> commands coming from the wrapper Actors will
trigger the dissemination of the contained chat room message to all connected
clients. But we do not want to give the ability to send
<tt class="xref py py-class docutils literal"><span class="pre">PostSessionMessage</span></tt> commands to arbitrary clients, we reserve that
right to the wrappers we create—otherwise clients could pose as completely
different screen names (imagine the <tt class="xref py py-class docutils literal"><span class="pre">GetSession</span></tt> protocol to include
authentication information to further secure this). Therefore we narrow the
behavior down to only accepting <tt class="xref py py-class docutils literal"><span class="pre">GetSession</span></tt> commands before exposing it
to the world, hence the type of the <tt class="docutils literal"><span class="pre">behavior</span></tt> value is
<tt class="xref py py-class docutils literal"><span class="pre">Behavior[GetSession]</span></tt> instead of <tt class="xref py py-class docutils literal"><span class="pre">Behavior[Command]</span></tt>.</p>
<p>Narrowing the type of a behavior is always a safe operation since it only
restricts what clients can do. If we were to widen the type then clients could
send other messages that were not foreseen while writing the source code for
the behavior.</p>
<p>If we did not care about securing the correspondence between a session and a
screen name then we could change the protocol such that <tt class="xref py py-class docutils literal"><span class="pre">PostMessage</span></tt> is
removed and all clients just get an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef[PostSessionMessage]</span></tt> to
send to. In this case no wrapper would be needed and we could just use
<tt class="docutils literal"><span class="pre">ctx.self</span></tt>. The type-checks work out in that case because
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef[-T]</span></tt> is contravariant in its type parameter, meaning that we
can use a <tt class="xref py py-class docutils literal"><span class="pre">ActorRef[Command]</span></tt> wherever an
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef[PostSessionMessage]</span></tt> is needed—this makes sense because the
former simply speaks more languages than the latter. The opposite would be
problematic, so passing an <tt class="xref py py-class docutils literal"><span class="pre">ActorRef[PostSessionMessage]</span></tt> where
<tt class="xref py py-class docutils literal"><span class="pre">ActorRef[Command]</span></tt> is required will lead to a type error.</p>
<p>The final piece of this behavior definition is the <tt class="xref py py-class docutils literal"><span class="pre">ContextAware</span></tt>
decorator that we use in order to obtain access to the <tt class="xref py py-class docutils literal"><span class="pre">ActorContext</span></tt>
within the <tt class="xref py py-class docutils literal"><span class="pre">Static</span></tt> behavior definition. This decorator invokes the
provided function when the first message is received and thereby creates the
real behavior that will be used going forward—the decorator is discarded after
it has done its job.</p>
<div class="section" id="trying-it-out">
<h3>Trying it out</h3>
<p>In order to see this chat room in action we need to write a client Actor that can use it:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">ChatRoom._</span>

<span class="k">val</span> <span class="n">gabbler</span><span class="k">:</span> <span class="kt">Behavior</span><span class="o">[</span><span class="kt">SessionEvent</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Total</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">SessionDenied</span><span class="o">(</span><span class="n">reason</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;cannot start chat room session: $reason&quot;</span><span class="o">)</span>
      <span class="nc">Stopped</span>
    <span class="k">case</span> <span class="nc">SessionGranted</span><span class="o">(</span><span class="n">handle</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">handle</span> <span class="o">!</span> <span class="nc">PostMessage</span><span class="o">(</span><span class="s">&quot;Hello World!&quot;</span><span class="o">)</span>
      <span class="nc">Same</span>
    <span class="k">case</span> <span class="nc">MessagePosted</span><span class="o">(</span><span class="n">screenName</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;message has been posted by &#39;$screenName&#39;: $message&quot;</span><span class="o">)</span>
      <span class="nc">Stopped</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>From this behavior we can create an Actor that will accept a chat room session,
post a message, wait to see it published, and then terminate. The last step
requires the ability to change behavior, we need to transition from the normal
running behavior into the terminated state. This is why this Actor uses a
different behavior constructor named <tt class="xref py py-class docutils literal"><span class="pre">Total</span></tt>. This constructor takes as
argument a function from the handled message type, in this case
<tt class="xref py py-class docutils literal"><span class="pre">SessionEvent</span></tt>, to the next behavior. That next behavior must again be
of the same type as we discussed in the theory section above. Here we either
stay in the very same behavior or we terminate, and both of these cases are so
common that there are special values <tt class="docutils literal"><span class="pre">Same</span></tt> and <tt class="docutils literal"><span class="pre">Stopped</span></tt> that can be used.
The behavior is named “total” (as opposed to “partial”) because the declared
function must handle all values of its input type. Since <tt class="xref py py-class docutils literal"><span class="pre">SessionEvent</span></tt>
is a sealed trait the Scala compiler will warn us if we forget to handle one of
the subtypes; in this case it reminded us that alternatively to
<tt class="xref py py-class docutils literal"><span class="pre">SessionGranted</span></tt> we may also receive a <tt class="xref py py-class docutils literal"><span class="pre">SessionDenied</span></tt> event.</p>
<p>Now to try things out we must start both a chat room and a gabbler and of
course we do this inside an Actor system. Since there can be only one guardian
supervisor we could either start the chat room from the gabbler (which we don’t
want—it complicates its logic) or the gabbler from the chat room (which is
nonsensical) or we start both of them from a third Actor—our only sensible
choice:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">main</span><span class="k">:</span> <span class="kt">Behavior</span><span class="o">[</span><span class="kt">akka.NotUsed</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Full</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Sig</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">PreStart</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">chatRoom</span> <span class="k">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">spawn</span><span class="o">(</span><span class="nc">ChatRoom</span><span class="o">.</span><span class="n">behavior</span><span class="o">,</span> <span class="s">&quot;chatroom&quot;</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">gabblerRef</span> <span class="k">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">spawn</span><span class="o">(</span><span class="n">gabbler</span><span class="o">,</span> <span class="s">&quot;gabbler&quot;</span><span class="o">)</span>
      <span class="n">ctx</span><span class="o">.</span><span class="n">watch</span><span class="o">(</span><span class="n">gabblerRef</span><span class="o">)</span>
      <span class="n">chatRoom</span> <span class="o">!</span> <span class="nc">GetSession</span><span class="o">(</span><span class="s">&quot;ol’ Gabbler&quot;</span><span class="o">,</span> <span class="n">gabblerRef</span><span class="o">)</span>
      <span class="nc">Same</span>
    <span class="k">case</span> <span class="nc">Sig</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">ref</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="nc">Stopped</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;ChatRoomDemo&quot;</span><span class="o">,</span> <span class="n">main</span><span class="o">)</span>
<span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">system</span><span class="o">.</span><span class="n">whenTerminated</span><span class="o">,</span> <span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
</pre></div>
</div>
<p>In good tradition we call the <tt class="docutils literal"><span class="pre">main</span></tt> Actor what it is, it directly
corresponds to the <tt class="docutils literal"><span class="pre">main</span></tt> method in a traditional Java application. This
Actor will perform its job on its own accord, we do not need to send messages
from the outside, so we declare it to be of type <tt class="docutils literal"><span class="pre">NotUsed</span></tt>. Actors receive not
only external messages, they also are notified of certain system events,
so-called Signals. In order to get access to those we choose to implement this
particular one using the <tt class="xref py py-class docutils literal"><span class="pre">Full</span></tt> behavior decorator. The name stems from
the fact that within this we have full access to all aspects of the Actor. The
provided function will be invoked for signals (wrapped in <tt class="xref py py-class docutils literal"><span class="pre">Sig</span></tt>) or user
messages (wrapped in <tt class="xref py py-class docutils literal"><span class="pre">Msg</span></tt>) and the wrapper also contains a reference to
the <tt class="xref py py-class docutils literal"><span class="pre">ActorContext</span></tt>.</p>
<p>This particular main Actor reacts to two signals: when it is started it will
first receive the <tt class="xref py py-class docutils literal"><span class="pre">PreStart</span></tt> signal, upon which the chat room and the
gabbler are created and the session between them is initiated, and when the
gabbler is finished we will receive the <tt class="xref py py-class docutils literal"><span class="pre">Terminated</span></tt> event due to having
called <tt class="docutils literal"><span class="pre">ctx.watch</span></tt> for it. This allows us to shut down the Actor system: when
the main Actor terminates there is nothing more to do.</p>
<p>Therefore after creating the Actor system with the <tt class="docutils literal"><span class="pre">main</span></tt> Actor’s
<tt class="xref py py-class docutils literal"><span class="pre">Props</span></tt> we just await its termination.</p>
</div>
</div>
<div class="section" id="status-of-this-project-and-relation-to-akka-actors">
<h2>Status of this Project and Relation to Akka Actors</h2>
<p>Akka Typed is the result of many years of research and previous attempts
(including Typed Channels in the 2.2.x series) and it is on its way to
stabilization, but maturing such a profound change to the core concept of Akka
will take a long time. We expect that this module will stay experimental for
multiple major releases of Akka and the plain <tt class="docutils literal"><span class="pre">akka.actor.Actor</span></tt> will not be
deprecated or go away anytime soon.</p>
<p>Being a research project also entails that the reference documentation is not
as detailed as it will be for a final version, please refer to the API
documentation for greater depth and finer detail.</p>
<div class="section" id="main-differences">
<h3>Main Differences</h3>
<p>The most prominent difference is the removal of the <tt class="docutils literal"><span class="pre">sender()</span></tt> functionality.
This turned out to be the Achilles heel of the Typed Channels project, it is
the feature that makes its type signatures and macros too complex to be viable.
The solution chosen in Akka Typed is to explicitly include the properly typed
reply-to address in the message, which both burdens the user with this task but
also places this aspect of protocol design where it belongs.</p>
<p>The other prominent difference is the removal of the <tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> trait. In
order to avoid closing over unstable references from different execution
contexts (e.g. Future transformations) we turned all remaining methods that
were on this trait into messages: the behavior receives the
<tt class="xref py py-class docutils literal"><span class="pre">ActorContext</span></tt> as an argument during processing and the lifecycle hooks
have been converted into Signals.</p>
<p>A side-effect of this is that behaviors can now be tested in isolation without
having to be packaged into an Actor, tests can run fully synchronously without
having to worry about timeouts and spurious failures. Another side-effect is
that behaviors can nicely be composed and decorated, see the <tt class="xref py py-class docutils literal"><span class="pre">And</span></tt>,
<tt class="xref py py-class docutils literal"><span class="pre">Or</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Widened</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">ContextAware</span></tt> combinators; nothing about
these is special or internal, new combinators can be written as external
libraries or tailor-made for each project.</p>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>