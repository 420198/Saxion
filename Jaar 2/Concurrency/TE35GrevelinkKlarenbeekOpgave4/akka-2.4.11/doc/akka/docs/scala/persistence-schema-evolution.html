


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Persistence - Schema Evolution &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Actors" href="index-actors.html" />
    <link rel="next" title="Persistence Query" href="persistence-query.html" />
    <link rel="prev" title="Persistence" href="persistence.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Persistence - Schema Evolution</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="persistence-query.html">Persistence Query</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="persistence.html">Persistence</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4.11
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="persistence-schema-evolution">
<span id="persistence-schema-evolution-scala"></span><h1>Persistence - Schema Evolution</h1>
<p>When working on long running projects using <a class="reference internal" href="persistence.html#persistence-scala"><em>Persistence</em></a>, or any kind of <a class="reference external" href="http://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a> architectures,
schema evolution becomes one of the more important technical aspects of developing your application.
The requirements as well as our own understanding of the business domain may (and will) change in time.</p>
<p>In fact, if a project matures to the point where you need to evolve its schema to adapt to changing business
requirements you can view this as first signs of its success – if you wouldn't need to adapt anything over an apps
lifecycle that could mean that no-one is really using it actively.</p>
<p>In this chapter we will investigate various schema evolution strategies and techniques from which you can pick and
choose the ones that match your domain and challenge at hand.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This page proposes a number of possible solutions to the schema evolution problem and explains how some of the
utilities Akka provides can be used to achieve this, it is by no means a complete (closed) set of solutions.</p>
<p class="last">Sometimes, based on the capabilities of your serialization formats, you may be able to evolve your schema in
different ways than outlined in the sections below. If you discover useful patterns or techniques for schema
evolution feel free to submit Pull Requests to this page to extend it.</p>
</div>
<div class="section" id="schema-evolution-in-event-sourced-systems">
<h2>Schema evolution in event-sourced systems</h2>
<p>In recent years we have observed a tremendous move towards immutable append-only datastores, with event-sourcing being
the prime technique successfully being used in these settings. For an excellent overview why and how immutable data makes scalability
and systems design much simpler you may want to read Pat Helland's excellent <a class="reference external" href="http://www.cidrdb.org/cidr2015/Papers/CIDR15_Paper16.pdf">Immutability Changes Everything</a> whitepaper.</p>
<p>Since with <a class="reference external" href="http://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a> the <strong>events are immutable</strong> and usually never deleted – the way schema evolution is handled
differs from how one would go about it in a mutable database setting (e.g. in typical CRUD database applications).</p>
<p>The system needs to be able to continue to work in the presence of &quot;old&quot; events which were stored under the &quot;old&quot; schema.
We also want to limit complexity in the business logic layer, exposing a consistent view over all of the events of a given
type to <tt class="xref py py-class docutils literal"><span class="pre">PersistentActor</span></tt> s and <a class="reference internal" href="persistence-query.html#persistence-query-scala"><em>persistence queries</em></a>. This allows the business logic layer to focus on solving business problems
instead of having to explicitly deal with different schemas.</p>
<dl class="docutils">
<dt>In summary, schema evolution in event sourced systems exposes the following characteristics:</dt>
<dd><ul class="first last simple">
<li>Allow the system to continue operating without large scale migrations to be applied,</li>
<li>Allow the system to read &quot;old&quot; events from the underlying storage, however present them in a &quot;new&quot; view to the application logic,</li>
<li>Transparently promote events to the latest versions during recovery (or queries) such that the business logic need not consider multiple versions of events</li>
</ul>
</dd>
</dl>
<div class="section" id="types-of-schema-evolution">
<h3>Types of schema evolution</h3>
<p>Before we explain the various techniques that can be used to safely evolve the schema of your persistent events
over time, we first need to define what the actual problem is, and what the typical styles of changes are.</p>
<p>Since events are never deleted, we need to have a way to be able to replay (read) old events, in such way
that does not force the <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> to be aware of all possible versions of an event that it may have
persisted in the past. Instead, we want the Actors to work on some form of &quot;latest&quot; version of the event and provide some
means of either converting old &quot;versions&quot; of stored events into this &quot;latest&quot; event type, or constantly evolve the event
definition - in a backwards compatible way - such that the new deserialization code can still read old events.</p>
<p>The most common schema changes you will likely are:</p>
<ul class="simple">
<li><a class="reference internal" href="#add-field-scala"><em>adding a field to an event type</em></a>,</li>
<li><a class="reference internal" href="#rename-field-scala"><em>remove or rename field in event type</em></a>,</li>
<li><a class="reference internal" href="#remove-event-class-scala"><em>remove event type</em></a>,</li>
<li><a class="reference internal" href="#split-large-event-into-smaller-scala"><em>split event into multiple smaller events</em></a>.</li>
</ul>
<p>The following sections will explain some patterns which can be used to safely evolve your schema when facing those changes.</p>
</div>
</div>
<div class="section" id="picking-the-right-serialization-format">
<h2>Picking the right serialization format</h2>
<p>Picking the serialization format is a very important decision you will have to make while building your application.
It affects which kind of evolutions are simple (or hard) to do, how much work is required to add a new datatype, and,
last but not least, serialization performance.</p>
<p>If you find yourself realising you have picked &quot;the wrong&quot; serialization format, it is always possible to change
the format used for storing new events, however you would have to keep the old deserialization code in order to
be able to replay events that were persisted using the old serialization scheme. It is possible to &quot;rebuild&quot;
an event-log from one serialization format to another one, however it may be a more involved process if you need
to perform this on a live system.</p>
<p>Binary serialization formats that we have seen work well for long-lived applications include the very flexible IDL based:
<a class="reference external" href="https://developers.google.com/protocol-buffers">Google Protobuf</a>, <a class="reference external" href="https://thrift.apache.org/">Apache Thrift</a> or <a class="reference external" href="https://avro.apache.org">Apache Avro</a>. Avro schema evolution is more &quot;entire schema&quot; based, instead of
single fields focused like in protobuf or thrift, and usually requires using some kind of schema registry.</p>
<p>Users who want their data to be human-readable directly in the write-side
datastore may opt to use plain-old <a class="reference external" href="http://json.org">JSON</a> as the storage format, though that comes at a cost of lacking support for schema
evolution and relatively large marshalling latency.</p>
<p>There are plenty excellent blog posts explaining the various trade-offs between popular serialization formats,
one post we would like to highlight is the very well illustrated <a class="reference external" href="http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html">Schema evolution in Avro, Protocol Buffers and Thrift</a>
by Martin Kleppmann.</p>
<div class="section" id="provided-default-serializers">
<h3>Provided default serializers</h3>
<p>Akka Persistence provides <a class="reference external" href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a> based serializers (using <a class="reference internal" href="serialization.html#serialization-scala"><em>Akka Serialization</em></a>)
for it's own message types such as <tt class="docutils literal"><span class="pre">PersistentRepr</span></tt>, <tt class="docutils literal"><span class="pre">AtomicWrite</span></tt> and snapshots. Journal plugin implementations
<em>may</em> choose to use those provided serializers, or pick a serializer which suits the underlying database better.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Serialization is <strong>NOT</strong> handled automatically by Akka Persistence itself. Instead, it only provides the above described
serializers, and in case a <tt class="docutils literal"><span class="pre">AsyncWriteJournal</span></tt> plugin implementation chooses to use them directly, the above serialization
scheme will be used.</p>
<p>Please refer to your write journal's documentation to learn more about how it handles serialization!</p>
<p class="last">For example, some journals may choose to not use Akka Serialization <em>at all</em> and instead store the data in a format
that is more &quot;native&quot; for the underlying datastore, e.g. using JSON or some other kind of format that the target
datastore understands directly.</p>
</div>
<p>The below figure explains how the default serialization scheme works, and how it fits together with serializing the
user provided message itself, which we will from here on refer to as the <tt class="docutils literal"><span class="pre">payload</span></tt> (highlighted in yellow):</p>
<div class="figure align-center">
<img alt="../_images/persistent-message-envelope1.png" src="../_images/persistent-message-envelope1.png" />
<p class="caption">Akka Persistence provided serializers wrap the user payload in an envelope containing all persistence-relevant information.
<strong>If the Journal uses provided Protobuf serializers for the wrapper types (e.g. PersistentRepr), then the payload will
be serialized using the user configured serializer, and if none is provided explicitly, Java serialization will be used for it.</strong></p>
</div>
<p>The blue colored regions of the <tt class="docutils literal"><span class="pre">PersistentMessage</span></tt> indicate what is serialized using the generated protocol buffers
serializers, and the yellow payload indicates the user provided event (by calling <tt class="docutils literal"><span class="pre">persist(payload)(...)</span></tt>).
As you can see, the <tt class="docutils literal"><span class="pre">PersistentMessage</span></tt> acts as an envelope around the payload, adding various fields related to the
origin of the event (<tt class="docutils literal"><span class="pre">persistenceId</span></tt>, <tt class="docutils literal"><span class="pre">sequenceNr</span></tt> and more).</p>
<p>More advanced techniques (e.g. <a class="reference internal" href="#remove-event-class-scala"><em>Remove event class and ignore events</em></a>) will dive into using the manifests for increasing the
flexibility of the persisted vs. exposed types even more. However for now we will focus on the simpler evolution techniques,
concerning simply configuring the payload serializers.</p>
<p>By default the <tt class="docutils literal"><span class="pre">payload</span></tt> will be serialized using Java Serialization. This is fine for testing and initial phases
of your development (while you're still figuring out things and the data will not need to stay persisted forever).
However, once you move to production you should really <em>pick a different serializer for your payloads</em>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not rely on Java serialization (which will be picked by Akka by default if you don't specify any serializers)
for <em>serious</em> application development! It does not lean itself well to evolving schemas over long periods of time,
and its performance is also not very high (it never was designed for high-throughput scenarios).</p>
</div>
</div>
<div class="section" id="configuring-payload-serializers">
<h3>Configuring payload serializers</h3>
<p>This section aims to highlight the complete basics on how to define custom serializers using <a class="reference internal" href="serialization.html#serialization-scala"><em>Akka Serialization</em></a>.
Many journal plugin implementations use Akka Serialization, thus it is tremendously important to understand how to configure
it to work with your event classes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Read the <a class="reference internal" href="serialization.html#serialization-scala"><em>Akka Serialization</em></a> docs to learn more about defining custom serializers,
to improve performance and maintainability of your system. Do not depend on Java serialization for production deployments.</p>
</div>
<p>The below snippet explains in the minimal amount of lines how a custom serializer can be registered.
For more in-depth explanations on how serialization picks the serializer to use etc, please refer to its documentation.</p>
<p>First we start by defining our domain model class, here representing a person:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">surname</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div>
</div>
<p>Next we implement a serializer (or extend an existing one to be able to handle the new <tt class="docutils literal"><span class="pre">Person</span></tt> class):</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Simplest possible serializer, uses a string representation of the Person class.</span>
<span class="cm"> *</span>
<span class="cm"> * Usually a serializer like this would use a library like:</span>
<span class="cm"> * protobuf, kryo, avro, cap&#39;n proto, flatbuffers, SBE or some other dedicated serializer backend</span>
<span class="cm"> * to perform the actual to/from bytes marshalling.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">SimplestPossiblePersonSerializer</span> <span class="k">extends</span> <span class="nc">SerializerWithStringManifest</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Utf8</span> <span class="k">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="n">forName</span><span class="o">(</span><span class="s">&quot;UTF-8&quot;</span><span class="o">)</span>

  <span class="k">val</span> <span class="nc">PersonManifest</span> <span class="k">=</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">Person</span><span class="o">].</span><span class="n">getName</span>

  <span class="c1">// unique identifier of the serializer</span>
  <span class="k">def</span> <span class="n">identifier</span> <span class="k">=</span> <span class="mi">1234567</span>

  <span class="c1">// extract manifest to be stored together with serialized object</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span>

  <span class="c1">// serialize the object</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="s">&quot;&quot;&quot;${p.name}|${p.surname}&quot;&quot;&quot;</span><span class="o">.</span><span class="n">getBytes</span><span class="o">(</span><span class="nc">Utf8</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="n">s</span><span class="s">&quot;Unable to serialize to bytes, clazz was: ${obj.getClass}!&quot;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// deserialize the object, using the manifest to indicate which logic to apply</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span>
    <span class="n">manifest</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">PersonManifest</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">nameAndSurname</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="nc">Utf8</span><span class="o">)</span>
        <span class="k">val</span> <span class="nc">Array</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">surname</span><span class="o">)</span> <span class="k">=</span> <span class="n">nameAndSurname</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;[|]&quot;</span><span class="o">)</span>
        <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">surname</span><span class="o">)</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
        <span class="n">s</span><span class="s">&quot;Unable to deserialize from bytes, manifest was: $manifest! Bytes length: &quot;</span> <span class="o">+</span>
          <span class="n">bytes</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>And finally we register the serializer and bind it to handle the <tt class="docutils literal"><span class="pre">docs.persistence.Person</span></tt> class:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="n">application</span><span class="o">.</span><span class="n">conf</span>
<span class="n">akka</span> <span class="o">{</span>
  <span class="n">actor</span> <span class="o">{</span>
    <span class="n">serializers</span> <span class="o">{</span>
      <span class="n">person</span> <span class="k">=</span> <span class="s">&quot;docs.persistence.SimplestPossiblePersonSerializer&quot;</span>
    <span class="o">}</span>

    <span class="n">serialization</span><span class="o">-</span><span class="n">bindings</span> <span class="o">{</span>
      <span class="s">&quot;docs.persistence.Person&quot;</span> <span class="k">=</span> <span class="n">person</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Deserialization will be performed by the same serializer which serialized the message initially
because of the <tt class="docutils literal"><span class="pre">identifier</span></tt> being stored together with the message.</p>
<p>Please refer to the <a class="reference internal" href="serialization.html#serialization-scala"><em>Akka Serialization</em></a> documentation for more advanced use of serializers,
especially the <a class="reference internal" href="serialization.html#string-manifest-serializer-scala"><em>Serializer with String Manifest</em></a> section since it is very useful for Persistence based applications
dealing with schema evolutions, as we will see in some of the examples below.</p>
</div>
</div>
<div class="section" id="schema-evolution-in-action">
<h2>Schema evolution in action</h2>
<p>In this section we will discuss various schema evolution techniques using concrete examples and explaining
some of the various options one might go about handling the described situation. The list below is by no means
a complete guide, so feel free to adapt these techniques depending on your serializer's capabilities
and/or other domain specific limitations.</p>
<div class="section" id="add-fields">
<span id="add-field-scala"></span><h3>Add fields</h3>
<p><strong>Situation:</strong>
You need to add a field to an existing message type. For example, a <tt class="docutils literal"><span class="pre">SeatReservation(letter:String,</span> <span class="pre">row:Int)</span></tt> now
needs to have an associated code which indicates if it is a window or aisle seat.</p>
<p><strong>Solution:</strong>
Adding fields is the most common change you'll need to apply to your messages so make sure the serialization format
you picked for your payloads can handle it apropriately, i.e. such changes should be <em>binary compatible</em>.
This is easily achieved using the right serializer toolkit – we recommend something like <a class="reference external" href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a> or
<a class="reference external" href="https://thrift.apache.org/">Apache Thrift</a> however other tools may fit your needs just as well – picking a serializer backend is something
you should research before picking one to run with. In the following examples we will be using protobuf, mostly because
we are familiar with it, it does its job well and Akka is using it internally as well.</p>
<p>While being able to read messages with missing fields is half of the solution, you also need to deal with the missing
values somehow. This is usually modeled as some kind of default value, or by representing the field as an <tt class="docutils literal"><span class="pre">Option[T]</span></tt>
See below for an example how reading an optional field from a serialized protocol buffers message might look like.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">SeatType</span> <span class="o">{</span> <span class="k">def</span> <span class="n">code</span><span class="k">:</span> <span class="kt">String</span> <span class="o">}</span>
<span class="k">object</span> <span class="nc">SeatType</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fromString</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Window</span><span class="o">.</span><span class="n">code</span> <span class="k">=&gt;</span> <span class="nc">Window</span>
    <span class="k">case</span> <span class="nc">Aisle</span><span class="o">.</span><span class="n">code</span>  <span class="k">=&gt;</span> <span class="nc">Aisle</span>
    <span class="k">case</span> <span class="nc">Other</span><span class="o">.</span><span class="n">code</span>  <span class="k">=&gt;</span> <span class="nc">Other</span>
    <span class="k">case</span> <span class="k">_</span>           <span class="k">=&gt;</span> <span class="nc">Unknown</span>
  <span class="o">}</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Window</span> <span class="k">extends</span> <span class="nc">SeatType</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">code</span> <span class="k">=</span> <span class="s">&quot;W&quot;</span> <span class="o">}</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Aisle</span> <span class="k">extends</span> <span class="nc">SeatType</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">code</span> <span class="k">=</span> <span class="s">&quot;A&quot;</span> <span class="o">}</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Other</span> <span class="k">extends</span> <span class="nc">SeatType</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">code</span> <span class="k">=</span> <span class="s">&quot;O&quot;</span> <span class="o">}</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Unknown</span> <span class="k">extends</span> <span class="nc">SeatType</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">code</span> <span class="k">=</span> <span class="s">&quot;&quot;</span> <span class="o">}</span>

<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">SeatReserved</span><span class="o">(</span><span class="n">letter</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">seatType</span><span class="k">:</span> <span class="kt">SeatType</span><span class="o">)</span>
</pre></div>
</div>
<p>Next we prepare an protocol definition using the protobuf Interface Description Language, which we'll use to generate
the serializer code to be used on the Akka Serialization layer (notice that the schema aproach allows us to easily rename
fields, as long as the numeric identifiers of the fields do not change):</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// FlightAppModels.proto</span>
<span class="n">option</span> <span class="n">java_package</span> <span class="k">=</span> <span class="s">&quot;docs.persistence.proto&quot;</span><span class="o">;</span>
<span class="n">option</span> <span class="n">optimize_for</span> <span class="k">=</span> <span class="nc">SPEED</span><span class="o">;</span>

<span class="n">message</span> <span class="nc">SeatReserved</span> <span class="o">{</span>
  <span class="n">required</span> <span class="n">string</span> <span class="n">letter</span>   <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">required</span> <span class="n">uint32</span> <span class="n">row</span>      <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
  <span class="n">optional</span> <span class="n">string</span> <span class="n">seatType</span> <span class="k">=</span> <span class="mi">3</span><span class="o">;</span> <span class="c1">// the new field</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The serializer implementation uses the protobuf generated classes to marshall the payloads.
Optional fields can be handled explicitly or missing values by calling the <tt class="docutils literal"><span class="pre">has...</span></tt> methods on the protobuf object,
which we do for <tt class="docutils literal"><span class="pre">seatType</span></tt> in order to use a <tt class="docutils literal"><span class="pre">Unknown</span></tt> type in case the event was stored before we had introduced
the field to this event type:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Example serializer impl which uses protocol buffers generated classes (proto.*)</span>
<span class="cm"> * to perform the to/from binary marshalling.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">AddedFieldsSerializerWithProtobuf</span> <span class="k">extends</span> <span class="nc">SerializerWithStringManifest</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span> <span class="k">=</span> <span class="mi">67876</span>

  <span class="k">final</span> <span class="k">val</span> <span class="nc">SeatReservedManifest</span> <span class="k">=</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">SeatReserved</span><span class="o">].</span><span class="n">getName</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span>
    <span class="n">manifest</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SeatReservedManifest</span> <span class="k">=&gt;</span>
        <span class="c1">// use generated protobuf serializer</span>
        <span class="n">seatReserved</span><span class="o">(</span><span class="nc">FlightAppModels</span><span class="o">.</span><span class="nc">SeatReserved</span><span class="o">.</span><span class="n">parseFrom</span><span class="o">(</span><span class="n">bytes</span><span class="o">))</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Unable to handle manifest: &quot;</span> <span class="o">+</span> <span class="n">manifest</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">o</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">SeatReserved</span> <span class="o">=&gt;</span>
      <span class="nc">FlightAppModels</span><span class="o">.</span><span class="nc">SeatReserved</span><span class="o">.</span><span class="n">newBuilder</span>
        <span class="o">.</span><span class="n">setRow</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">row</span><span class="o">)</span>
        <span class="o">.</span><span class="n">setLetter</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">letter</span><span class="o">)</span>
        <span class="o">.</span><span class="n">setSeatType</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">seatType</span><span class="o">.</span><span class="n">code</span><span class="o">)</span>
        <span class="o">.</span><span class="n">build</span><span class="o">().</span><span class="n">toByteArray</span>
  <span class="o">}</span>

  <span class="c1">// -- fromBinary helpers --</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">seatReserved</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">FlightAppModels.SeatReserved</span><span class="o">)</span><span class="k">:</span> <span class="kt">SeatReserved</span> <span class="o">=</span>
    <span class="nc">SeatReserved</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">getLetter</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">getRow</span><span class="o">,</span> <span class="n">seatType</span><span class="o">(</span><span class="n">p</span><span class="o">))</span>

  <span class="c1">// handle missing field by assigning &quot;Unknown&quot; value</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">seatType</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">FlightAppModels.SeatReserved</span><span class="o">)</span><span class="k">:</span> <span class="kt">SeatType</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">hasSeatType</span><span class="o">)</span> <span class="nc">SeatType</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">getSeatType</span><span class="o">)</span> <span class="k">else</span> <span class="nc">SeatType</span><span class="o">.</span><span class="nc">Unknown</span>

<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rename-fields">
<span id="rename-field-scala"></span><h3>Rename fields</h3>
<p><strong>Situation:</strong>
When first designing the system the <tt class="docutils literal"><span class="pre">SeatReverved</span></tt> event featured an <tt class="docutils literal"><span class="pre">code</span></tt> field.
After some time you discover that what was originally called <tt class="docutils literal"><span class="pre">code</span></tt> actually means <tt class="docutils literal"><span class="pre">seatNr</span></tt>, thus the model
should be changed to reflect this concept more accurately.</p>
<p><strong>Solution 1 - using IDL based serializers:</strong>
First, we will discuss the most efficient way of dealing with such kinds of schema changes – IDL based serializers.</p>
<p>IDL stands for Interface Description Language, and means that the schema of the messages that will be stored is based
on this description. Most IDL based serializers also generate the serializer / deserializer code so that using them
is not too hard. Examples of such serializers are protobuf or thrift.</p>
<p>Using these libraries rename operations are &quot;free&quot;, because the field name is never actually stored in the binary
representation of the message. This is one of the advantages of schema based serializers, even though that they
add the overhead of having to maintain the schema. When using serializers like this, no additional code change
(except renaming the field and method used during serialization) is needed to perform such evolution:</p>
<div class="figure align-center">
<img alt="../_images/persistence-serializer-rename1.png" src="../_images/persistence-serializer-rename1.png" />
</div>
<p>This is how such a rename would look in protobuf:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// protobuf message definition, BEFORE:</span>
<span class="n">message</span> <span class="nc">SeatReserved</span> <span class="o">{</span>
  <span class="n">required</span> <span class="n">string</span> <span class="n">code</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// protobuf message definition, AFTER:</span>
<span class="n">message</span> <span class="nc">SeatReserved</span> <span class="o">{</span>
  <span class="n">required</span> <span class="n">string</span> <span class="n">seatNr</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// field renamed, id remains the same</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It is important to learn about the strengths and limitations of your serializers, in order to be able to move
swiftly and refactor your models fearlessly as you go on with the project.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Learn in-depth about the serialization engine you're using as it will impact how you can aproach schema evolution.</p>
<p class="last">Some operations are &quot;free&quot; in certain serialization formats (more often than not: removing/adding optional fields,
sometimes renaming fields etc.), while some other operations are strictly not possible.</p>
</div>
<p><strong>Solution 2 - by manually handling the event versions:</strong>
Another solution, in case your serialization format does not support renames as easily as the above mentioned formats,
is versioning your schema. For example, you could have made your events carry an additional field called <tt class="docutils literal"><span class="pre">_version</span></tt>
which was set to <tt class="docutils literal"><span class="pre">1</span></tt> (because it was the initial schema), and once you change the schema you bump this number to <tt class="docutils literal"><span class="pre">2</span></tt>,
and write an adapter which can perform the rename.</p>
<p>This approach is popular when your serialization format is something like JSON, where renames can not be performed
automatically by the serializer. You can do these kinds of &quot;promotions&quot; either manually (as shown in the example below)
or using a library like <a class="reference external" href="https://github.com/scalapenos/stamina">Stamina</a> which helps to create those <tt class="docutils literal"><span class="pre">V1-&gt;V2-&gt;V3-&gt;...-&gt;Vn</span></tt> promotion chains without much boilerplate.</p>
<div class="figure align-center">
<img alt="../_images/persistence-manual-rename1.png" src="../_images/persistence-manual-rename1.png" />
</div>
<p>The following snippet showcases how one could apply renames if working with plain JSON (using <tt class="docutils literal"><span class="pre">spray.json.JsObject</span></tt>):</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">JsonRenamedFieldAdapter</span> <span class="k">extends</span> <span class="nc">EventAdapter</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">marshaller</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ExampleJsonMarshaller</span>

  <span class="k">val</span> <span class="n">V1</span> <span class="k">=</span> <span class="s">&quot;v1&quot;</span>
  <span class="k">val</span> <span class="n">V2</span> <span class="k">=</span> <span class="s">&quot;v2&quot;</span>

  <span class="c1">// this could be done independently for each event type</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">V2</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsObject</span> <span class="o">=</span>
    <span class="n">marshaller</span><span class="o">.</span><span class="n">toJson</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">EventSeq</span> <span class="o">=</span> <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">json</span><span class="k">:</span> <span class="kt">JsObject</span> <span class="o">=&gt;</span> <span class="nc">EventSeq</span><span class="o">(</span><span class="n">marshaller</span><span class="o">.</span><span class="n">fromJson</span><span class="o">(</span><span class="n">manifest</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">V1</span>      <span class="k">=&gt;</span> <span class="n">rename</span><span class="o">(</span><span class="n">json</span><span class="o">,</span> <span class="s">&quot;code&quot;</span><span class="o">,</span> <span class="s">&quot;seatNr&quot;</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">V2</span>      <span class="k">=&gt;</span> <span class="n">json</span> <span class="c1">// pass-through</span>
      <span class="k">case</span> <span class="n">unknown</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Unknown manifest: $unknown&quot;</span><span class="o">)</span>
    <span class="o">}))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="n">event</span><span class="o">.</span><span class="n">getClass</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Can only work with JSON, was: %s&quot;</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">rename</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsObject</span><span class="o">,</span> <span class="n">from</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsObject</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">value</span> <span class="k">=</span> <span class="n">json</span><span class="o">.</span><span class="n">fields</span><span class="o">(</span><span class="n">from</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">withoutOld</span> <span class="k">=</span> <span class="n">json</span><span class="o">.</span><span class="n">fields</span> <span class="o">-</span> <span class="n">from</span>
    <span class="nc">JsObject</span><span class="o">(</span><span class="n">withoutOld</span> <span class="o">+</span> <span class="o">(</span><span class="n">to</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">))</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>As you can see, manually handling renames induces some boilerplate onto the EventAdapter, however much of it
you will find is common infrastructure code that can be either provided by an external library (for promotion management)
or put together in a simple helper trait.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The technique of versioning events and then promoting them to the latest version using JSON transformations
can of course be applied to more than just field renames – it also applies to adding fields and all kinds of
changes in the message format.</p>
</div>
</div>
<div class="section" id="remove-event-class-and-ignore-events">
<span id="remove-event-class-scala"></span><h3>Remove event class and ignore events</h3>
<p><strong>Situation:</strong>
While investigating app performance you notice that insane amounts of <tt class="docutils literal"><span class="pre">CustomerBlinked</span></tt> events are being stored
for every customer each time he/she blinks. Upon investigation you decide that the event does not add any value
and should be deleted. You still have to be able to replay from a journal which contains those old CustomerBlinked events though.</p>
<p><strong>Naive solution - drop events in EventAdapter:</strong></p>
<p>The problem of removing an event type from the domain model is not as much its removal, as the implications
for the recovery mechanisms that this entails. For example, a naive way of filtering out certain kinds of events from
being delivered to a recovering <tt class="docutils literal"><span class="pre">PersistentActor</span></tt> is pretty simple, as one can simply filter them out in an <a class="reference internal" href="persistence.html#event-adapters-scala"><em>EventAdapter</em></a>:</p>
<div class="figure align-center">
<img alt="../_images/persistence-drop-event1.png" src="../_images/persistence-drop-event1.png" />
<p class="caption">The <tt class="docutils literal"><span class="pre">EventAdapter</span></tt> can drop old events (<strong>O</strong>) by emitting an empty <tt class="xref py py-class docutils literal"><span class="pre">EventSeq</span></tt>.
Other events can simply be passed through (<strong>E</strong>).</p>
</div>
<p>This however does not address the underlying cost of having to deserialize all the events during recovery,
even those which will be filtered out by the adapter. In the next section we will improve the above explained mechanism
to avoid deserializing events which would be filtered out by the adapter anyway, thus allowing to save precious time
during a recovery containing lots of such events (without actually having to delete them).</p>
<p><strong>Improved solution - deserialize into tombstone:</strong></p>
<p>In the just described technique we have saved the PersistentActor from receiving un-wanted events by filtering them
out in the <tt class="docutils literal"><span class="pre">EventAdapter</span></tt>, however the event itself still was deserialized and loaded into memory.
This has two notable <em>downsides</em>:</p>
<blockquote>
<div><ul class="simple">
<li>first, that the deserialization was actually performed, so we spent some of out time budget on the
deserialization, even though the event does not contribute anything to the persistent actors state.</li>
<li>second, that we are <em>unable to remove the event class</em> from the system – since the serializer still needs to create
the actuall instance of it, as it does not know it will not be used.</li>
</ul>
</div></blockquote>
<p>The solution to these problems is to use a serializer that is aware of that event being no longer needed, and can notice
this before starting to deserialize the object.</p>
<p>This aproach allows us to <em>remove the original class from our classpath</em>, which makes for less &quot;old&quot; classes lying around in the project.
This can for example be implemented by using an <tt class="docutils literal"><span class="pre">SerializerWithStringManifest</span></tt>
(documented in depth in <a class="reference internal" href="serialization.html#string-manifest-serializer-scala"><em>Serializer with String Manifest</em></a>). By looking at the string manifest, the serializer can notice
that the type is no longer needed, and skip the deserialization all-together:</p>
<div class="figure align-center">
<img alt="../_images/persistence-drop-event-serializer1.png" src="../_images/persistence-drop-event-serializer1.png" />
<p class="caption">The serializer is aware of the old event types that need to be skipped (<strong>O</strong>), and can skip deserializing them alltogether
by simply returning a &quot;tombstone&quot; (<strong>T</strong>), which the EventAdapter converts into an empty EventSeq.
Other events (<strong>E</strong>) can simply be passed through.</p>
</div>
<p>The serializer detects that the string manifest points to a removed event type and skips attempting to deserialize it:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">object</span> <span class="nc">EventDeserializationSkipped</span>

<span class="k">class</span> <span class="nc">RemovedEventsAwareSerializer</span> <span class="k">extends</span> <span class="nc">SerializerWithStringManifest</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">utf8</span> <span class="k">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="n">forName</span><span class="o">(</span><span class="s">&quot;UTF-8&quot;</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8337</span>

  <span class="k">val</span> <span class="nc">SkipEventManifestsEvents</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span>
    <span class="s">&quot;docs.persistence.CustomerBlinked&quot;</span> <span class="c1">// ...</span>
  <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">o</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">getBytes</span><span class="o">(</span><span class="n">utf8</span><span class="o">)</span> <span class="c1">// example serialization</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span>
    <span class="n">manifest</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">m</span> <span class="k">if</span> <span class="nc">SkipEventManifestsEvents</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">EventDeserializationSkipped</span>

      <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="n">utf8</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The EventAdapter we implemented is aware of <tt class="docutils literal"><span class="pre">EventDeserializationSkipped</span></tt> events (our &quot;Tombstones&quot;),
and emits and empty <tt class="docutils literal"><span class="pre">EventSeq</span></tt> whenever such object is encoutered:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SkippedEventsAwareAdapter</span> <span class="k">extends</span> <span class="nc">EventAdapter</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">event</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">EventDeserializationSkipped</span> <span class="k">=&gt;</span> <span class="nc">EventSeq</span><span class="o">.</span><span class="n">empty</span>
    <span class="k">case</span> <span class="k">_</span>                           <span class="k">=&gt;</span> <span class="nc">EventSeq</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="detach-domain-model-from-data-model">
<span id="detach-domain-from-data-model-scala"></span><h3>Detach domain model from data model</h3>
<p><strong>Situation:</strong>
You want to separate the application model (often called the &quot;<em>domain model</em>&quot;) completely from the models used to
persist the corresponding events (the &quot;<em>data model</em>&quot;). For example because the data representation may change
independently of the domain model.</p>
<p>Another situation where this technique may be useful is when your serialization tool of choice requires generated
classes to be used for serialization and deserialization of objects, like for example <a class="reference external" href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a> do,
yet you do not want to leak this implementation detail into the domain model itself, which you'd like to model as
plain Scala case classes.</p>
<p><strong>Solution:</strong>
In order to detach the domain model, which is often represented using pure scala (case) classes, from the data model
classes which very often may be less user-friendly yet highly optimised for throughput and schema evolution
(like the classes generated by protobuf for example), it is possible to use a simple EventAdapter which maps between
these types in a 1:1 style as illustrated below:</p>
<div class="figure align-center">
<img alt="../_images/persistence-detach-models1.png" src="../_images/persistence-detach-models1.png" />
<p class="caption">Domain events (<strong>A</strong>) are adapted to the data model events (<strong>D</strong>) by the <tt class="docutils literal"><span class="pre">EventAdapter</span></tt>.
The data model can be a format natively understood by the journal, such that it can store it more efficiently or
include additional data for the event (e.g. tags), for ease of later querying.</p>
</div>
<p>We will use the following domain and data models to showcase how the separation can be implemented by the adapter:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/** Domain model - highly optimised for domain language and maybe &quot;fluent&quot; usage */</span>
<span class="k">object</span> <span class="nc">DomainModel</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Seat</span><span class="o">(</span><span class="n">code</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">bookFor</span><span class="o">(</span><span class="n">customer</span><span class="k">:</span> <span class="kt">Customer</span><span class="o">)</span><span class="k">:</span> <span class="kt">SeatBooked</span> <span class="o">=</span> <span class="nc">SeatBooked</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">customer</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SeatBooked</span><span class="o">(</span><span class="n">code</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">customer</span><span class="k">:</span> <span class="kt">Customer</span><span class="o">)</span>
<span class="o">}</span>

<span class="cm">/** Data model - highly optimised for schema evolution and persistence */</span>
<span class="k">object</span> <span class="nc">DataModel</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SeatBooked</span><span class="o">(</span><span class="n">code</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">customerName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">EventAdapter</span></tt> takes care of converting from one model to the other one (in both directions),
alowing the models to be completely detached from each other, such that they can be optimised independently
as long as the mapping logic is able to convert between them:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DetachedModelsAdapter</span> <span class="k">extends</span> <span class="nc">EventAdapter</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">DomainModel</span><span class="o">.</span><span class="nc">SeatBooked</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">customer</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">DataModel</span><span class="o">.</span><span class="nc">SeatBooked</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fromJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">EventSeq</span> <span class="o">=</span> <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">DataModel</span><span class="o">.</span><span class="nc">SeatBooked</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">customerName</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">EventSeq</span><span class="o">(</span><span class="nc">DomainModel</span><span class="o">.</span><span class="nc">SeatBooked</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="nc">DomainModel</span><span class="o">.</span><span class="nc">Customer</span><span class="o">(</span><span class="n">customerName</span><span class="o">)))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The same technique could also be used directly in the Serializer if the end result of marshalling is bytes.
Then the serializer can simply convert the bytes do the domain object by using the generated protobuf builders.</p>
</div>
<div class="section" id="store-events-as-human-readable-data-model">
<span id="store-human-readable-scala"></span><h3>Store events as human-readable data model</h3>
<p><strong>Situation:</strong>
You want to keep your persisted events in a human-readable format, for example JSON.</p>
<p><strong>Solution:</strong>
This is a special case of the <a class="reference internal" href="#detach-domain-from-data-model-scala"><em>Detach domain model from data model</em></a> pattern, and thus requires some co-operation
from the Journal implementation to achieve this.</p>
<p>An example of a Journal which may implement this pattern is MongoDB, however other databases such as PostgreSQL
and Cassandra could also do it because of their built-in JSON capabilities.</p>
<p>In this aproach, the <tt class="xref py py-class docutils literal"><span class="pre">EventAdapter</span></tt> is used as the marshalling layer: it serializes the events to/from JSON.
The journal plugin notices that the incoming event type is JSON (for example by performing a <tt class="docutils literal"><span class="pre">match</span></tt> on the incoming
event) and stores the incoming object directly.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">JsonDataModelAdapter</span> <span class="k">extends</span> <span class="nc">EventAdapter</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

  <span class="k">val</span> <span class="n">marshaller</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ExampleJsonMarshaller</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsObject</span> <span class="o">=</span>
    <span class="n">marshaller</span><span class="o">.</span><span class="n">toJson</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">EventSeq</span> <span class="o">=</span> <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">json</span><span class="k">:</span> <span class="kt">JsObject</span> <span class="o">=&gt;</span>
      <span class="nc">EventSeq</span><span class="o">(</span><span class="n">marshaller</span><span class="o">.</span><span class="n">fromJson</span><span class="o">(</span><span class="n">json</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
        <span class="s">&quot;Unable to fromJournal a non-JSON object! Was: &quot;</span> <span class="o">+</span> <span class="n">event</span><span class="o">.</span><span class="n">getClass</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This technique only applies if the Akka Persistence plugin you are using provides this capability.
Check the documentation of your favourite plugin to see if it supports this style of persistence.</p>
<p class="last">If it doesn't, you may want to skim the <a class="reference external" href="http://akka.io/community/#journal-plugins">list of existing journal plugins</a>, just in case some other plugin
for your favourite datastore <em>does</em> provide this capability.</p>
</div>
<p><strong>Alternative solution:</strong></p>
<p>In fact, an AsyncWriteJournal implementation could natively decide to not use binary serialization at all,
and <em>always</em> serialize the incoming messages as JSON - in which case the <tt class="docutils literal"><span class="pre">toJournal</span></tt> implementation of the
<tt class="xref py py-class docutils literal"><span class="pre">EventAdapter</span></tt> would be an identity function, and the <tt class="docutils literal"><span class="pre">fromJournal</span></tt> would need to de-serialize messages
from JSON.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If in need of human-readable events on the <em>write-side</em> of your application reconsider whether preparing materialized views
using <a class="reference internal" href="persistence-query.html#persistence-query-scala"><em>Persistence Query</em></a> would not be an efficient way to go about this, without compromising the
write-side's throughput characteristics.</p>
<p class="last">If indeed you want to use a human-readable representation on the write-side, pick a Persistence plugin
that provides that functionality, or – implement one yourself.</p>
</div>
</div>
<div class="section" id="split-large-event-into-fine-grained-events">
<span id="split-large-event-into-smaller-scala"></span><h3>Split large event into fine-grained events</h3>
<p><strong>Situation:</strong>
While refactoring your domain events, you find that one of the events has become too large (coarse-grained)
and needs to be split up into multiple fine-grained events.</p>
<p><strong>Solution:</strong>
Let us consider a situation where an event represents &quot;user details changed&quot;. After some time we discover that this
event is too coarse, and needs to be split into &quot;user name changed&quot; and &quot;user address changed&quot;, because somehow
users keep changing their usernames a lot and we'd like to keep this as a separate event.</p>
<p>The write side change is very simple, we simply persist <tt class="docutils literal"><span class="pre">UserNameChanged</span></tt> or <tt class="docutils literal"><span class="pre">UserAddressChanged</span></tt> depending
on what the user actually intended to change (instead of the composite <tt class="docutils literal"><span class="pre">UserDetailsChanged</span></tt> that we had in version 1
of our model).</p>
<div class="figure align-center">
<img alt="../_images/persistence-event-adapter-1-n1.png" src="../_images/persistence-event-adapter-1-n1.png" />
<p class="caption">The <tt class="docutils literal"><span class="pre">EventAdapter</span></tt> splits the incoming event into smaller more fine grained events during recovery.</p>
</div>
<p>During recovery however, we now need to convert the old <tt class="docutils literal"><span class="pre">V1</span></tt> model into the <tt class="docutils literal"><span class="pre">V2</span></tt> representation of the change.
Depending if the old event contains a name change, we either emit the <tt class="docutils literal"><span class="pre">UserNameChanged</span></tt> or we don't,
and the address change is handled similarily:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">trait</span> <span class="nc">V1</span>
<span class="k">trait</span> <span class="nc">V2</span>

<span class="c1">// V1 event:</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UserDetailsChanged</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="n">V1</span>

<span class="c1">// corresponding V2 events:</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UserNameChanged</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="n">V2</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UserAddressChanged</span><span class="o">(</span><span class="n">address</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="n">V2</span>

<span class="c1">// event splitting adapter:</span>
<span class="k">class</span> <span class="nc">UserEventsAdapter</span> <span class="k">extends</span> <span class="nc">EventAdapter</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">manifest</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">EventSeq</span> <span class="o">=</span> <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">UserDetailsChanged</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">EventSeq</span><span class="o">(</span><span class="nc">UserAddressChanged</span><span class="o">(</span><span class="n">address</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">UserDetailsChanged</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">=&gt;</span> <span class="nc">EventSeq</span><span class="o">(</span><span class="nc">UserNameChanged</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">UserDetailsChanged</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">EventSeq</span><span class="o">(</span>
        <span class="nc">UserNameChanged</span><span class="o">(</span><span class="n">name</span><span class="o">),</span>
        <span class="nc">UserAddressChanged</span><span class="o">(</span><span class="n">address</span><span class="o">))</span>
    <span class="k">case</span> <span class="n">event</span><span class="k">:</span> <span class="kt">V2</span> <span class="o">=&gt;</span> <span class="nc">EventSeq</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toJournal</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">event</span>
<span class="o">}</span>
</pre></div>
</div>
<p>By returning an <tt class="xref py py-class docutils literal"><span class="pre">EventSeq</span></tt> from the event adapter, the recovered event can be converted to multiple events before
being delivered to the persistent actor.</p>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Sep 30, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>